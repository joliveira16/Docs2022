[{"uri":"/Teaching/Common.html","title":"Common","content":"#r \u0022nuget: FSharp.Data\u0022\n\nopen System\nopen System.IO\nopen FSharp.Data\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\n\nmodule Secrets =\n    let envVars = System.Environment.GetEnvironmentVariables() \n    let localPath = \u0022../secrets.fsx\u0022\n    let localPath2 = \u0022secrets.fsx\u0022\n    let tiingoKey = \n        let var = \u0022TIINGO_KEY\u0022\n        if envVars.Contains var then \n            envVars.[var] :?\u003E string\n        elif File.Exists(localPath) then \n            File.ReadAllText(localPath)\n                .Replace(\u0022let tiingoKey = \u0022,\u0022\u0022)\n                .Replace(\u0022\\\u0022\u0022,\u0022\u0022)\n        else \n            File.ReadAllText(localPath2)\n                .Replace(\u0022let tiingoKey = \u0022,\u0022\u0022)\n                .Replace(\u0022\\\u0022\u0022,\u0022\u0022)\n    \n\n\ntype Frequency = Daily | Monthly\ntype ReturnObs = { Symbol : string; Date : DateTime; Return : float }\n\nmodule Tiingo =\n\n    type TiingoCsv = CsvProvider\u003C\u0022date,close,high,low,open,volume,adjClose,adjHigh,adjLow,adjOpen,adjVolume,divCash,splitFactor\n2020-10-01,9.77,10.25,9.69,10.09,4554055,9.77,10.25,9.69,10.09,4554055.0,0.0,1.0\u0022\u003E\n\n    type TiingoRequest = { Symbol : string; Start : DateTime; End : DateTime }\n\n    type TiingoObs =\n        {\n            Date : DateTime\n            Close : decimal\n            High : decimal\n            Low : decimal\n            Open : decimal \n            Volume : int\n            AdjClose : decimal\n            AdjHigh : decimal\n            AdjLow : decimal\n            AdjOpen : decimal\n            AdjVolume : decimal\n            DivCash : decimal\n            SplitFactor : decimal\n        }\n\n    ///\u003Csummary\u003EConstructs a Tiingo request. By default is to get the past year of data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022symbol\u0022\u003EThe ticker symbol such as \u0022AAPL\u0022,\u0022MSFT\u0022 etc.\u003C/param\u003E\n    let request symbol = { Symbol = symbol; Start = DateTime.Now.AddYears(-1); End = DateTime.Now}\n    ///\u003Csummary\u003ESets the Tiingo request start date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022startOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let startOn startOn request = { request with Start = startOn }\n    ///\u003Csummary\u003ESets the Tiingo request end date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022endOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let endOn endOn request = { request with End = endOn }\n\n    let private cache = Runtime.Caching.createInMemoryCache (TimeSpan(hours=12,minutes=0,seconds=0))\n\n    ///\u003Csummary\u003EDownloads Tiingo data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to download.\u003C/param\u003E\n    let get request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            cache.Set(key,result)\n            result\n        |\u003E TiingoCsv.Parse\n        |\u003E fun parsed -\u003E\n            parsed.Rows\n            |\u003E Seq.map(fun row -\u003E\n                { Date = row.Date\n                  Close = row.Close\n                  High = row.High\n                  Low = row.Low\n                  Open = row.Open\n                  Volume = row.Volume\n                  AdjClose = row.AdjClose\n                  AdjHigh = row.AdjHigh\n                  AdjLow = row.AdjLow\n                  AdjOpen = row.AdjOpen\n                  AdjVolume = row.AdjVolume\n                  DivCash = row.DivCash\n                  SplitFactor = row.SplitFactor \n                  })\n            |\u003E Seq.toArray      \n    \n    // using a class, keeping private for now.\n    type private Download(symbol:string,?startOn:DateTime,?endOn:DateTime) =\n        let startOn = defaultArg startOn (DateTime.Now.AddYears(-1))\n        let endOn = defaultArg endOn (DateTime.Now)\n        let data = get { Symbol = symbol; Start = startOn; End = endOn }\n        member this.Rows = data\n \n    // Probably deprecated\n    let private getFromCacheDirectory cacheDirectory request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        let cacheFile = cacheDirectory \u002B key\n        if File.Exists(cacheFile) then\n            File.ReadAllText(cacheFile)\n        else    \n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            File.WriteAllText(cacheFile,result)\n            result\n        |\u003E TiingoCsv.Parse\n    \n    let private returnHelper symbol (xs:TiingoObs seq) =\n        xs\n        |\u003E Seq.sortBy(fun x -\u003E x.Date)\n        |\u003E Seq.pairwise\n        |\u003E Seq.map(fun (yesterday, today) -\u003E\n            { Symbol = symbol \n              Date = today.Date\n              Return =  float (today.AdjClose / yesterday.AdjClose) - 1.0})\n        |\u003E Seq.toArray      \n\n    let getReturns request =\n        get request\n        |\u003E (returnHelper request.Symbol)\n\n    // Marking as private so people don\u0027t use it by accident\n    let private getInternetFileCache request =\n        let cache = Runtime.Caching.createInternetFileCache \u0022tiingo\u0022 (TimeSpan.FromDays 30.0)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = request.ToString()\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let res =\n                Http.RequestString\n                        ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                            httpMethod = \u0022GET\u0022,\n                            query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                        \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022format\u0022,\u0022csv\u0022],\n                            headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv ])\n            cache.Set(key, res)\n            res\n        |\u003E TiingoCsv.Parse\n\nmodule French =\n    //open System.Net\n    open System.IO.Compression\n\n    type private FF3Csv = CsvProvider\u003C\u0022Date (string),Mkt-RF,SMB,HML,RF\n        19260701,    0.10,   -0.24,   -0.28,   0.009\u0022\u003E\n    type FF3Obs = \n        { Date : DateTime \n          MktRf : float\n          Smb : float \n          Hml : float\n          Rf : float \n          Frequency : Frequency } \n\n    type private FF5Csv = CsvProvider\u003C\u0022Date (string),Mkt-RF,SMB,HML,RMW,CMA,RF\n        19260701,    0.10,   -0.24,   -0.28,0.0,1.2,  0.009\u0022\u003E\n\n    type FF5Obs = \n        { Date : DateTime \n          MktRf : float\n          Smb : float \n          Hml : float\n          Rmw : float\n          Cma : float\n          Rf : float \n          Frequency : Frequency } \n\n    let private frenchDay x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMMdd\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n    let private frenchMonth x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMM\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n\n    let private cache = \n        let today = DateTime.Now\n        let nextMonth = today.AddMonths(1)\n        let eom = DateTime(nextMonth.Year, nextMonth.Month, 1).AddSeconds(-1.0) \n        Runtime.Caching.createInternetFileCache \u0022French\u0022 (eom - today)\n\n    let private getData (dataset:string) =\n        match cache.TryRetrieve(dataset) with\n        | Some data -\u003E data\n        | None -\u003E\n            //let dataset = \u0022F-F_Research_Data_Factors_CSV\u0022\n            let urlString = $\u0022http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/{dataset}.zip\u0022\n            let request = Http.RequestStream(urlString, httpMethod = \u0022GET\u0022,headers = [HttpRequestHeaders.Accept HttpContentTypes.Any])\n            use archive = new ZipArchive(request.ResponseStream,ZipArchiveMode.Read)\n            let file = archive.GetEntry($\u0022{dataset}\u0022.Replace(\u0022_CSV\u0022,\u0022.CSV\u0022))\n            use reader = new StreamReader(file.Open())\n            let data  = reader.ReadToEnd()\n            cache.Set(dataset,data)\n            data\n    let getFF3 frequency =\n            let (dataset, dateParser) =\n                match frequency with\n                | Monthly -\u003E \u0022F-F_Research_Data_Factors_CSV\u0022, frenchMonth\n                | Daily -\u003E \u0022F-F_Research_Data_Factors_daily_CSV\u0022, frenchDay\n            let data = new StringReader(getData dataset)\n            [| while data.Peek() \u003C\u003E -1 do\n                    data.ReadLine() |]\n            |\u003E Array.skipWhile(fun line -\u003E not (line.Contains(\u0022Mkt-RF\u0022)))\n            |\u003E Array.skip 1\n            |\u003E Array.takeWhile(fun line -\u003E line \u003C\u003E \u0022\u0022)\n            |\u003E Array.map(fun line -\u003E \n                let parsedLine = FF3Csv.ParseRows(line).[0] \n                { Date = dateParser parsedLine.Date\n                  MktRf = float parsedLine.\u0060\u0060Mkt-RF\u0060\u0060 / 100.0\n                  Smb = float parsedLine.SMB / 100.0\n                  Hml = float parsedLine.HML / 100.0\n                  Rf = float parsedLine.RF / 100.0 \n                  Frequency = frequency })\n\n    let getFF5 frequency =\n        let (dataset, dateParser) =\n            match frequency with\n            | Monthly -\u003E \u0022F-F_Research_Data_5_Factors_2x3_CSV\u0022, frenchMonth\n            | Daily -\u003E \u0022F-F_Research_Data_5_Factors_2x3_daily_CSV\u0022, frenchDay\n        let data = new StringReader(getData dataset)\n        [| while data.Peek() \u003C\u003E -1 do\n                data.ReadLine() |]\n        |\u003E Array.skipWhile(fun line -\u003E not (line.Contains(\u0022Mkt-RF\u0022)))\n        |\u003E Array.skip 1\n        |\u003E Array.takeWhile(fun line -\u003E line \u003C\u003E \u0022\u0022)\n        |\u003E Array.map(fun line -\u003E \n            let parsedLine = FF5Csv.ParseRows(line).[0] \n            { Date = dateParser parsedLine.Date\n              MktRf = float parsedLine.\u0060\u0060Mkt-RF\u0060\u0060 / 100.0\n              Smb = float parsedLine.SMB / 100.0\n              Hml = float parsedLine.HML / 100.0\n              Rmw = float parsedLine.RMW / 100.0\n              Cma = float parsedLine.CMA / 100.0\n              Rf = float parsedLine.RF / 100.0 \n              Frequency = frequency })\n\nmodule Fred =\n    type Series = CsvProvider\u003C\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id=GS10\u0022,\n                              Schema=\u0022Date,Value (float)\u0022,\n                              MissingValues=\u0022.\u0022\u003E\n    let private fredUrl series = $\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id={series}\u0022\n    \n    ///\u003Csummary\u003EGets a FRED data series as a CsvProvider\u003C/summary\u003E\n        /// \u003Cparam name=\u0022series\u0022\u003EThe series name such as GS10, EXUSEU, etc.\u003C/param\u003E\n    let get (series:string) =  Series.Load(fredUrl series)\n    "},{"uri":"/Teaching/football-1-download-data.html","title":"Webscraping HTML to CSV","content":"(**\n---\ntitle: Webscraping HTML to CSV\ncategory: Assignments\ncategoryindex: 2\nindex: 0\n---\n*)\n\n(***hide***)\n// specific link:\n// https://fbref.com/en/comps/Big5/2019-2020/stats/players/2019-2020-Big-5-European-Leagues-Stats\n\n// most recent link:\n// \u0022https://fbref.com/en/comps/Big5/stats/players/Big-5-European-Leagues-Stats\u0022\n\n(**\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n# Webscraping HTML to CSV\n\n\u003E Developed with [Davide Costa](https://github.com/DavideGCosta)\n\nFor the **Football Players\u0027 Exercises** we are trying to scrape data from [Sports Reference\u0027s](https://www.sports-reference.com/) [Football Reference](https://fbref.com/en/) website. The particular data that we want to scrape is player data from the [Big 5 European Leauges table](https://fbref.com/en/comps/Big5/stats/players/Big-5-European-Leagues-Stats). This data consists on the stats of the players that played in the big 5 football european leagues in the most recent season. Since we need to scrape the data from a webpage and store it in a csv file we will need to use 2 type providers from [FSharp.Data](https://fsharp.github.io/FSharp.Data/):\n\n- We\u0027ll use the [HTML Type Provider](https://fsprojects.github.io/FSharp.Data/library/HtmlProvider.html) to scrape the html from the webpage and access the players\u0027 table.  \n- We\u0027ll use the [CSV Type Provider](https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html) to save the data to a csv file.  \n\nBoth type providers are located in \u0060FSharp.Data\u0060 assembly. To use it we need to load and open \u0060FSharp.Data\u0060.\n*)\n\n#r \u0022nuget: FSharp.Data\u0022\nopen FSharp.Data\n\n(**\n## Get the players\u0027 table using HTML type provider.\nWe need to define the type of data that we\u0027re going to access.\nWe do this by providing a sample of the data.\nThe type provider uses the sample to generate code to read data with that format. \n*)\n\ntype Big5EuropeanLeagues = \n    HtmlProvider\u003C\u0022https://fbref.com/en/comps/Big5/2021-2022/stats/players/2021-2022-Big-5-European-Leagues-Stats\u0022\u003E\n\n(**\nThe type \u0060Big5EuropeanLeagues\u0060 contains information about the structure of the web page. It knows what the html is, it knows what the html tables are, etc.\n*)\n\n(**\nNow that we have the \u0060Big5EuropeanLeagues\u0060 HTML type defined we can use \u0060GetSample()\u0060 to load the sample webpage\nthat we used to define the type.  \n\n*)\nlet big5 = Big5EuropeanLeagues.GetSample()\n\n(**\nNow, we have the HTML of the webpage stored in the variable \u0060big5\u0060. Let\u0027s observe the first 200 characters of the HTML.\n*)\n(***do-not-eval***)\nbig5.Html.ToString()[..200]\n(***hide***)\nbig5.Html.ToString().[..200]\n(*** include-it ***)\n(**\nFrom the tables available in the webpage, let\u0027s assign the player stats table to a variable called \u0060footballers\u0060.\n*)\n\nlet footballers = big5.Tables.\u0060\u0060Player Standard Stats 2021-2022 Big 5 European Leagues\u0060\u0060\n\n(**\nNow let\u0027s observe the first 3 table rows. The \u0060Rows\u0060 property gives us an array of rows.\nWe can index into the array using \u0060[..2]\u0060 to limit it to the first 3 rows.\n*)\n(***do-not-eval***)\nfootballers.Rows[..2]\n(***hide***)\nfootballers.Rows.[..2]\n(*** include-it ***)\n(**\nLet\u0027s look at the header fields in the table using the property \u0060Headers\u0060.\n*)\nfootballers.Headers\n(*** include-it ***)\n(**\nLet\u00B4s look at the first 5 rows of fields \u0060Player\u0060 and \u0060Age\u0060.\n*)\n(***do-not-eval***)\n[ for row in footballers.Rows[..4] do row.Player, row.Age]\n(***hide***)\n[ for row in footballers.Rows.[..4] do row.Player, row.Age]\n(*** include-it ***)\n\n(**\n## Clean the data\n\nThe table data is not exactly what we need. To work with it, we need to clean it up.\n\n### Repeated headers\n\nThe table header line repeats after every 25 players.\nWe can see this if we look at the 26th row of the table.\n\n*)\n\n(***do-not-eval***)\nfootballers.Rows[25]\n(***hide***)\nfootballers.Rows.[25]\n(***include-it***)\n\n(**\nWe can remove these lines by using [Array.filter](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-arraymodule.html#filter). \u0060Array.filter\u0060 applies a function to each element of the array and\nreturns only those elements where the function evaluates to \u0060true\u0060.\nWe\u0027ll create a function that evaluates to \u0060true\u0060 if the player\u0027s name *does not* equal \u0060\u0022Player\u0022\u0060\n*)\n\nlet footballersNoHeaders = \n    footballers.Rows\n    // 1. Rows where row.Player does not equal \u0022Player\u0022\n    |\u003E Array.filter (fun row -\u003E row.Player \u003C\u003E \u0022Player\u0022) \n\n(**\n### Removing missing values\n\nIn order to make some arithmetic operations with age and goals scored, we need to convert the data into integers or floats/decimals. But some players\u0027 age and goals scored is missing, and converting empty strings (\u0022\u0022) into these types returns an error.  \nWe remove those lines by removing filtering to rows where age and goals are not \u0022\u0022.\n*)\n\nlet footballersClean =\n    footballersNoHeaders\n    |\u003E Array.filter (fun row -\u003E \n        row.Age \u003C\u003E \u0022\u0022 \u0026\u0026 \n        row.\u0060\u0060Performance - Gls\u0060\u0060 \u003C\u003E \u0022\u0022)\n\n(**\nNow we have the data we need, but\nthere are more than 2500 rows.  \n*)\n\nfootballersClean.Length\n\n(**\nFor our exercises we don\u0027t need so many observations,\nso let\u0027s transform it to get the best players by position!\n*)\n\nlet playersByPosition =\n    footballersClean\n    // 1. filter out odd positions with few players\n    |\u003E Array.filter(fun x -\u003E x.Pos \u003C\u003E \u0022GK,FW\u0022 \u0026\u0026 x.Pos \u003C\u003E \u0022FW,DF\u0022 \u0026\u0026 x.Pos \u003C\u003E \u0022DF,FW\u0022 )\n    // 2. group players by position\n    |\u003E Array.groupBy(fun x -\u003E x.Pos)\n    // 3. sort positions.\n    |\u003E Array.sortBy (fun (position, _players) -\u003E position)\n\n\nlet bestPlayersByPosition =\n    // This will get top 25 players for each position\n    // We create a new list by looping through each position group.\n    [| for (position, playersInPosition) in playersByPosition do\n        // 4. Sort best to worst (and convert to list at the end)\n        let bestToWorst =\n            playersInPosition\n            |\u003E Array.sortByDescending (fun player -\u003E\n                int player.\u0060\u0060Performance - Gls\u0060\u0060, player.Matches)\n        // 5. Truncate to top 25\n        let top25 = bestToWorst |\u003E Array.truncate 25         \n        top25 |]\n    // 6. concatenate to a single big array\n    |\u003E Array.concat\n    \nlet bestPlayers = \n    // sort best by position to overall top goal scorers,\n    // with ties broken by alphabetical sorting on \n    // the players name and squad.\n    bestPlayersByPosition\n    |\u003E Array.sortByDescending (fun player -\u003E \n        int player.\u0060\u0060Performance - Gls\u0060\u0060,\n        player.Player,\n        player.Squad)\n\n(**\n## Create a Csv and store the Data using Csv Provider.  \nNow that the data is scraped from the webpage and stored to \u0060FootballPlayersParsedTable\u0060 variable.\nWe need to save the data to a Csv file in order to use it in the Exercises.\n*)\n\n(**\nFirst we need to construct a sample of the data that will be stored in the comma separated (csv) File.\nBy running \u0060footballers.Headers\u0060 as done previously, we can easily observe that the table has fields that will not be used.  \nThe csv file doesn\u0027t need to contain all those fields, we only need: \n\n- \u0060Player\u0060 (Players\u0027 Name)  \n- \u0060Nation\u0060 (Players\u0027 Nationality)  \n- \u0060Pos\u0060 (Players\u0027 Position)  \n- \u0060Squad\u0060 (Players\u0027 Team)  \n- \u0060Comp\u0060 (Players\u0027 League)  \n- \u0060Age\u0060 (Players\u0027 Age)   \n- \u0060Playing Time - MP\u0060 (Players\u0027 Matches Played)  \n- \u0060Performance - Gls\u0060 (Players\u0027 Goals Scored)  \n\nThe csv type provider will infer csv field types from a sample that you give it.\nIt can infer the types from rows of the sample or from explicitly defined types\nadded in parentheses after column names.\nWe\u0027ll use explicit column type definitions in our sample.\n\n*)\n\n[\u003CLiteral\u003E]\nlet FootballPlayersCsvSample = \n    \u0022Player (string),\u0022 \u002B\n    \u0022Nation (string),\u0022 \u002B\n    \u0022Position (string),\u0022 \u002B\n    \u0022Team (string),\u0022 \u002B\n    \u0022League (string),\u0022 \u002B\n    \u0022Age (int),\u0022 \u002B\n    \u0022MatchesPlayed (int),\u0022 \u002B\n    \u0022GoalsScored (int)\u0022\n\n// the sample csv file that we\u0027ve created:\nFootballPlayersCsvSample\n(***include-it***)\n\n\n(**\nWith the sample created, now we define the type from the sample.\n*)\n\ntype FootballPlayersCsv = CsvProvider\u003CFootballPlayersCsvSample,ResolutionFolder = __SOURCE_DIRECTORY__\u003E\n\n(**\nNow that we have the data and the Csv sample let\u0027s create a \u0022list of CSV rows\u0022.\n*)\n\nlet bestPlayersCsvRows = \n    [ for player in bestPlayers do\n        FootballPlayersCsv.Row( \n            player = player.Player,\n            nation = player.Nation,\n            position = player.Pos,\n            team = player.Squad,\n            league = player.Comp,\n            // For the age variable just take the year (first two digits).\n            // Sometimes 29 and 185 days old is given as \u002229-185\u0022 and we\n            // want to throw away the days part.\n            age = int player.Age.[0..1], \n            matchesPlayed = int player.\u0060\u0060Playing Time - MP\u0060\u0060,\n            goalsScored = int player.\u0060\u0060Performance - Gls\u0060\u0060 ) ]\n\n(**\nNote that we use \u0060int\u0060 to convert \u0060age\u0060, \u0060matchesPlayed\u0060 and \u0060goalsScored\u0060 because those fields\u0027 values are \u0060strings\u0060 in the html table and we want \u0060integers\u0060 instead.  \n*)\n\n(**\nLet\u0027s look at the first 5 csv rows. We don\u0027t need to use \u0060bestPlayersCsvRows.Rows\u0060 because the variable is already a list of csv rows.  \n*)\n\n(***do-not-eval***)\nbestPlayersCsvRows[0..4]\n(***hide***)\nbestPlayersCsvRows.[0..4]\n(*** include-it ***)\n(**\nRather than a \u0022list of Csv rows\u0022, we want a \u0022Csv file\u0022.  Here\u0027s how we do that.\n*)\nlet bestPlayersCsvFile = new FootballPlayersCsv(bestPlayersCsvRows)\n\n(**\nOk, let\u0027s write the file. Remember that \u0060__SOURCE_DIRECTORY__\u0060 is a magic variable that points \nto whatever folder this code file (aka the source code file) is contained in.\nSo this will write the data to a csv file named \u0022FootballPlayers.csv\u0022 in the current directory.\n*)\n\nlet filePath = System.IO.Path.Combine(__SOURCE_DIRECTORY__,\u0022FootballPlayers.csv\u0022)\nbestPlayersCsvFile.Save(filePath)\n\n(**\nAnd if you want to read the data back in from the file to see that it works:\n*)\nlet backIn = FootballPlayersCsv.Load(filePath)\n\nbackIn.Rows\n|\u003E Seq.truncate 5\n|\u003E Seq.iter (printfn \u0022%A\u0022)\n(*** include-output ***)\n"},{"uri":"/Teaching/football-collection-functions.html","title":"Collection functions (with solutions)","content":"(**\n---\ntitle: Collection functions (with solutions)\ncategory: Assignments\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n\n# Using List collection functions and calculating summary statistics.\n\n\u003E Developed with [Davide Costa](https://github.com/DavideGCosta)\n\n\nYou should now feel comfortable with the footballer dataset and how to work with\ntuples, records, anonymous records. You should also know how to perform simple transformations.\nWith a large and heterogeneous dataset, it\u0027s useful to understand how to sort, group, \nand filter the data, and also many other interesting List functions.  \n\nIt is a good idea to browse the documentation for lists at the [F# language reference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/Lists)\nand the [F# core library](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html) documentation sites before you start. \nFor further discussion of collection functions, the related [F# for fun and profit](https://fsharpforfunandprofit.com/posts/list-module-functions/)\npage is also useful.\n\n*)\n\n(*** condition:prepare ***)\n#r \u0022nuget: FSharp.Formatting\u0022\n\ntype H2 = H2 of string \ntype H3 = H3 of string \n\nlet makeNumberedHeading (htmlTag:string) (text:string) =\n    let name = text.Replace(\u0022 \u0022, \u0022-\u0022)\n    let snippet = sprintf $\u0022\u003C{htmlTag} class=numbered\u003E\u003Ca name={name} class=anchor href=#{name}\u003E{text}\u003C/a\u003E\u003C/{htmlTag}\u003E\u0022\n    snippet \nfsi.AddPrinter(fun (H2 text) -\u003E makeNumberedHeading \u0022h2\u0022 text)\nfsi.AddPrinter(fun (H3 text) -\u003E makeNumberedHeading \u0022h3\u0022 text)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n### Reference needed nuget packages and open namespaces\n*)\n\n#r \u0022nuget:FSharp.Data\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n\nopen FSharp.Data\nopen FSharp.Stats\nopen FSharp.Stats.Correlation\n\n(**\n### Load the Csv file.  \n\n*)\n\nlet [\u003CLiteral\u003E] CsvPath = __SOURCE_DIRECTORY__ \u002B \u0022/FootballPlayers.csv\u0022\ntype FootballPlayersCsv = CsvProvider\u003CCsvPath\u003E\n\nlet playerStatsTable = \n    FootballPlayersCsv.GetSample().Rows\n    |\u003E Seq.toList\n\n(**\n## EXERCISES - PART 2\n\n- [List Functions.](#List-Functions)\n\n    1. [List.take](#1-List-take)\n    1. [List.truncate](#2-List-truncate)\n    1. [List.distinct](#3-List-distinct)\n    1. [List.countBy](#4-List-countBy)\n    1. [List.filter](#5-List-filter)\n    1. [List.sort and List.sortDescending](#6-List-sort-and-List-sortDescending)\n    1. [List.sortBy and List.sortByDescending](#7-List-sortBy-and-List-sortByDescending)\n    1. [List.splitInto](#8-List-splitInto)\n    1. [List.groupBy](#9-List-groupBy)\n\n- [Statistics List Functions.](#Statistics-List-Functions)\n    1. [List.max](#1-List-max)\n    1. [List.min](#2-List-min)\n    1. [List.maxBy](#3-List-maxBy)\n    1. [List.minBy](#4-List-minBy)\n    1. [List.sum](#5-List-sum)\n    1. [List.sumBy](#6-List-sumBy)\n    1. [List.average](#7-List-average)\n    1. [List.averageBy](#8-List-averageBy)\n    1. [Seq.stDev](#9-Seq-stDev)\n    1. [Seq.pearsonOfPairs](#10-Seq-pearsonOfPairs)\n\n- [Further Statistics practice.](#Further-Statistics-practice)\n    1. [List.countBy, List.filter and List.averageBy](#1-List-countBy-List-filter-and-List-averageBy)\n    1. [List.groupBy, List.map and transformations](#2-List-groupBy-List-map-and-transformations)\n    1. [List.sortDescending, List.splitInto, List.map and Seq.stDev](#3-List-sortDescending-List-splitInto-List-map-and-Seq-stDev)\n*)\n\n\n(**\n## List Functions.\n\n*)\n\n\n(**\n### 1 List.take\n\n\u0060List.take 5\u0060 takes the first 5 rows.  \n\u0060List.take 2\u0060 takes the first 2 rows  \n\n*)\n\n(**\nExample: Take the first 4 rows from \u0060playerStatsTable\u0060 with \u0060List.take\u0060.\n*)\nplayerStatsTable\n|\u003E List.take 4\n(*** include-fsi-output ***)\n\n(**\n- Take the first 7 rows from \u0060playerStatsTable\u0060 with \u0060List.take\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListTake, define-output: ListTake ***)\n\nplayerStatsTable\n|\u003E List.take 7\n\n(*** condition:html, include:ListTake ***)\n(*** condition:html, include-fsi-output:ListTake ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 2 List.truncate\n\u0060List.truncate 5\u0060 takes the first 5 rows.  \n\u0060List.truncate 2\u0060 takes the first 2 rows  \n\nYou must have noted that \u0060List.take\u0060 and \u0060List.truncate\u0060 return similar outputs, but these are not exactly the same.\n\u0060List.take\u0060 gives you the exact number of items that you specify in the parameters, \nwhile \u0060List.truncate\u0060 takes at maximum the number of items you specified in the parameters.\nThus, in most cases both give you the exact same output, except if you ask for more items then the ones available in the List (List length). \nIn this particular scenario \u0060List.truncate\u0060 returns the maximum number of elements (all the elements in the List), \nwhile \u0060List.take\u0060 returns an error, since it is supposed to take the exact number of elements you asked for, which is impossible in this particular case. \n*)\n\n(**\nExample: Take the first 4 rows from \u0060playerStatsTable\u0060 with \u0060List.truncate\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.truncate 4\n(*** include-fsi-output ***)\n\n(**\n- Take the first 7 rows from \u0060playerStatsTable\u0060 with \u0060List.truncate\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListTruncate, define-output: ListTruncate ***)\n\nplayerStatsTable\n|\u003E List.truncate 7\n\n(*** condition:html, include:ListTruncate ***)\n(*** condition:html, include-fsi-output:ListTruncate ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 3 List.distinct\n\n\u0060List.distinct\u0060 returns the unique elements from the List.  \n\u0060[\u0022hello\u0022; \u0022world\u0022; \u0022hello\u0022; \u0022hi\u0022] |\u003E List.distinct\u0060 returns \u0060[\u0022hello\u0022; \u0022world\u0022; \u0022hi\u0022]\u0060\n*)\n\n(**\nExample: From \u0060playerStatsTable\u0060 \u0060Nation\u0060 field find the unique elements with \u0060List.distinct\u0060.  \n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Nation)\n|\u003E List.distinct\n(*** include-fsi-output ***)\n\n(**\n- From \u0060playerStatsTable\u0060 \u0060League\u0060 field find the unique elements with \u0060List.distinct\u0060.  \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListDistinct, define-output: ListDistinct ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.League)\n|\u003E List.distinct\n\n(*** condition:html, include:ListDistinct ***)\n(*** condition:html, include-fsi-output:ListDistinct ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 4 List.countBy\n \n\u0060List.countBy\u0060 returns a list of paired tuples with the unique elements and their counts.\n*)\n\n(**\nExample: From \u0060playerStatsTable\u0060 \u0060Team\u0060 field find the unique elements and their counts with \u0060List.countBy\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.countBy(fun x -\u003E x.Team)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- From \u0060playerStatsTable\u0060 \u0060League\u0060 field find the unique elements and their counts with \u0060List.countBy\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListCountBy, define-output: ListCountBy ***)\n\nplayerStatsTable\n|\u003E List.countBy(fun x -\u003E x.League)\n\n(*** condition:html, include:ListCountBy ***)\n(*** condition:html, include-fsi-output:ListCountBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 5 List.filter\n\n\u0060List.filter\u0060 allows you to extract a subset of the dataset based on one or multiple conditions.\n*)\n\n(**\nExample: \u0060Filter\u0060 the \u0060playerStatsTable\u0060 to get only portuguese players. (\u0060Nation = \u0022pt POR\u0022\u0060).  \nRemember that we have to look to the dataset to find the string correspondent to portuguese players,\nwhich in this case is \u0060\u0022pt POR\u0022\u0060\n*)\n\nplayerStatsTable\n|\u003E List.filter(fun x -\u003E x.Nation = \u0022pt POR\u0022)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- \u0060Filter\u0060 the \u0060playerStatsTable\u0060 to get only 16 year-old players. (\u0060Age = 16\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListFilter, define-output: ListFilter ***)\n\nplayerStatsTable\n|\u003E List.filter(fun x -\u003E x.Age = 16)\n\n(*** condition:html, include:ListFilter ***)\n(*** condition:html, include-fsi-output:ListFilter ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 6 List.sort and List.sortDescending\n\n- \u0060[1; 4; 5; 3; 6] |\u003E List.sort\u0060 returns \u0060[1; 3; 4; 5; 6]\u0060 (ascending sort).\n- \u0060[1; 4; 5; 3; 6] |\u003E List.sortDescending\u0060 returns \u0060[6; 5; 4; 3; 1]\u0060 (descending sort).\n*)\n\n(**\nExample: map \u0060playerStatsTable\u0060 to get a list of \u0060Age\u0060 and sort it (ascending).  \n\nSince we want to sort the age List we first use \u0060List.map\u0060 to get only that List.\nThen we use \u0060List.sort\u0060 to sort it.\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age)\n|\u003E List.sort\n|\u003E List.truncate 60 //just to observe the first 60 values, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- map \u0060playerStatsTable\u0060 to get a list of \u0060GoalsScored\u0060 and sort it (ascending).  \nHint:\nTo sort the GoalsScored List you first need to use \u0060List.map\u0060 to get only that List.\nThen use \u0060List.sort\u0060 to sort it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSort, define-output: ListSort ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored)\n|\u003E List.sort\n|\u003E List.truncate 60 //just to observe the first 60 values, not a part of the exercise.\n\n(*** condition:html, include:ListSort ***)\n(*** condition:html, include-fsi-output:ListSort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\nExample: Map \u0060playerStatsTable\u0060 to get a list of \u0060Age\u0060 and sort it (descending).  \n  \nSince we want to sort the age List we first use \u0060List.map\u0060 to get only that List.\nThen we use \u0060List.sortDescending\u0060 to sort it.\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age)\n|\u003E List.sortDescending\n|\u003E List.truncate 60 //just to observe the first 60 values, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Map \u0060playerStatsTable\u0060 to get a list of \u0060GoalsScored\u0060 and sort it (descending).  \nHint:\nTo sort the GoalsScored List you first need to use \u0060List.map\u0060 to get only that List.\nThen use \u0060List.sortDescending\u0060 to sort it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSortDescending, define-output: ListSortDescending ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored)\n|\u003E List.sortDescending\n|\u003E List.truncate 60 //just to observe the first 60 values, not a part of the exercise.\n\n(*** condition:html, include:ListSortDescending ***)\n(*** condition:html, include-fsi-output:ListSortDescending ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 7 List.sortBy and List.sortByDescending\n\n\u0060List.sortBy\u0060 is very usefull to sort the dataset accordingly to a certain dataset field.  \n*)\n\n(**\nExample: sort (ascending) \u0060playerStatsTable\u0060 by \u0060Age\u0060 (\u0060List.sortBy\u0060).\n*)\n\nplayerStatsTable\n|\u003E List.sortBy(fun x -\u003E x.Age)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- sort (ascending) \u0060playerStatsTable\u0060 by \u0060GoalsScored\u0060 (\u0060List.sortBy\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSortBy, define-output: ListSortBy ***)\n\nplayerStatsTable\n|\u003E List.sortBy(fun x -\u003E x.GoalsScored)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:ListSortBy ***)\n(*** condition:html, include-fsi-output:ListSortBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n(**\nExample: sort (descending) \u0060playerStatsTable\u0060 by \u0060Age\u0060 (\u0060List.sortByDescending\u0060).\n*)\n\nplayerStatsTable\n|\u003E List.sortByDescending(fun x -\u003E x.Age)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- sort (descending) \u0060playerStatsTable\u0060 by \u0060GoalsScored\u0060 (\u0060List.sortByDescending\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSortByDescending, define-output: ListSortByDescending ***)\n\nplayerStatsTable\n|\u003E List.sortByDescending(fun x -\u003E x.GoalsScored)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:ListSortByDescending ***)\n(*** condition:html, include-fsi-output:ListSortByDescending ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 8 List.splitInto\n\n\u0060List.splitInto\u0060 is very usefull to split your dataset into multiple subsets.\nThis function is commonly used to generate quantiles by splitting a sorted List.\nFor instance, for investment strategies financial assets are usually sorted by a certain signal \nand then splitted into quantiles. If the signal has a positive sign, it means that the long strategy consists of going long \non the first quantile stocks, and the long-short strategy consists of going long on the first quantile stocks and short on the last quantile stocks.\n\nNote: \u0060List.splitInto\u0060 receives one parameter which refers to the number of groups you want to create out of the dataset.  \n*)\n\n(**\nExample: Sort the \u0060playerStatsTable\u0060 by \u0060GoalsScored\u0060 and then split the dataset into 4 groups using \u0060List.sortBy\u0060 and \u0060List.splitInto\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.sortBy(fun x -\u003E x.GoalsScored)\n|\u003E List.splitInto 4\n|\u003E List.truncate 2 //just to observe the first 2 groups Lists, not a part of the exercise.\n|\u003E List.map(fun x -\u003E x |\u003E List.truncate 5) //just to observe the first 5 rows of each group List, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Sort the \u0060playerStatsTable\u0060 by \u0060Age\u0060 and then split the dataset into 5 groups using \u0060List.sortBy\u0060 and \u0060List.splitInto\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSplitInto, define-output: ListSplitInto ***)\n\nplayerStatsTable\n|\u003E List.sortBy(fun x -\u003E x.Age)\n|\u003E List.splitInto 5\n|\u003E List.truncate 2 //just to observe the first 2 groups Lists, not a part of the exercise.\n|\u003E List.map(fun x -\u003E x |\u003E List.truncate 5) //just to observe the first 5 rows of each group List, not a part of the exercise.\n\n\n(*** condition:html, include:ListSplitInto ***)\n(*** condition:html, include-fsi-output:ListSplitInto ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 9 List.groupBy\n\n\u0060List.groupBy\u0060 allows you to group elements of a list.\nIt takes a key-generating function and a list as inputs.\nThe function is executed on each element of the List, returning a list of tuples\nwhere the first element of each tuple is the key and the second is a list of the elements for which the function produced that key.\n\n*)\n\n(**\nExample: Group the \u0060playerStatsTable\u0060 by \u0060Nation\u0060 using \u0060List.groupBy\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.Nation)\n|\u003E List.truncate 2 //just to observe the first 2 groups Lists, not a part of the exercise.\n|\u003E List.map(fun (x, xs) -\u003E x, xs |\u003E List.truncate 5) //just to observe the first 5 rows of each group List, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Group the \u0060playerStatsTable\u0060 by \u0060Age\u0060 using \u0060List.groupBy\u0060.  \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListGroupBy, define-output: ListGroupBy ***)\n\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.Age)\n|\u003E List.map(fun (x, xs) -\u003E x, xs |\u003E List.truncate 5) //just to observe the first 5 rows of each group List, not a part of the exercise.\n|\u003E List.truncate 2 //just to observe the first 2 groups Lists, not a part of the exercise.\n\n(*** condition:html, include:ListGroupBy ***)\n(*** condition:html, include-fsi-output:ListGroupBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Statistics List Functions \n*)\n\n(**\n### 1 List.max\n\n\u0060[1; 4; 5; 3; 6] |\u003E List.max\u0060 returns \u00606\u0060 (the highest value in the List).\n*)\n\n(**\nExample: Map \u0060playerStatsTable\u0060 to get the \u0060Age\u0060 List, and find the maximum (\u0060List.max\u0060).\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age)\n|\u003E List.max\n(*** include-fsi-output ***)\n\n(**\n- Map \u0060playerStatsTable\u0060 to get the \u0060GoalsScored\u0060 List, and find the maximum (\u0060List.max\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListMax, define-output: ListMax ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored)\n|\u003E List.max\n\n(*** condition:html, include:ListMax ***)\n(*** condition:html, include-fsi-output:ListMax ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 2 List.min\n\n\u0060[1; 4; 5; 3; 6] |\u003E List.min\u0060 returns \u00601\u0060 (the lowest value in the List).\n*)\n\n(**\nExample: Map \u0060playerStatsTable\u0060 to get the \u0060Age\u0060 List, and find the minimum (\u0060List.min\u0060).\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age)\n|\u003E List.min\n(*** include-fsi-output ***)\n\n(**\n- Map \u0060playerStatsTable\u0060 to get the \u0060GoalsScored\u0060 List, and find the minimum (\u0060List.min\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListMin, define-output: ListMin ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored)\n|\u003E List.min\n\n(*** condition:html, include:ListMin ***)\n(*** condition:html, include-fsi-output:ListMin ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 3 List.maxBy\n\nSometimes you want the element with the \u0022maximum y\u0022 where \u0022y\u0022 is the result of applying a particular function to a list element. This is what \u0060List.maxBy\u0060 is for. This function is best understood by seeing an example.\n*)\n\n(**\nExample: Find the player in \u0060playerStatsTable\u0060 with the maximum \u0060Age\u0060 using \u0060maxBy\u0060. What we need to do then is write a function that takes a player as input and outputs the players age. \u0060List.maxBy\u0060 will then find the player that is the maxiumum after transforming it using this function.\n*)\n\nplayerStatsTable\n|\u003E List.maxBy(fun x -\u003E x.Age)\n(*** include-fsi-output ***)\n\n(**\n- Find the maximum \u0060playerStatsTable\u0060 row by \u0060GoalsScored\u0060 using \u0060maxBy\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListMaxBy, define-output: ListMaxBy ***)\n\nplayerStatsTable\n|\u003E List.maxBy(fun x -\u003E x.GoalsScored)\n\n(*** condition:html, include:ListMaxBy ***)\n(*** condition:html, include-fsi-output:ListMaxBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 4 List.minBy\n\nSometimes you want the element with the \u0022minimum y\u0022 where \u0022y\u0022 is the result of applying a particular function to a list element. This is what \u0060List.minBy\u0060 is for.  \n*)\n\n(**\nExample: Find the player in \u0060playerStatsTable\u0060 with the minimum \u0060Age\u0060 using \u0060minBy\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.minBy(fun x -\u003E x.Age)\n(*** include-fsi-output ***)\n\n(**\n- Find the minimum \u0060playerStatsTable\u0060 row by \u0060GoalsScored\u0060 using \u0060minBy\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListMinBy, define-output: ListMinBy ***)\n\nplayerStatsTable\n|\u003E List.minBy(fun x -\u003E x.GoalsScored)\n\n(*** condition:html, include:ListMinBy ***)\n(*** condition:html, include-fsi-output:ListMinBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 5 List.sum\n\n\u0060[1; 4; 5; 3; 6] |\u003E List.sum\u0060 returns \u006019\u0060 (sum of the List elements).\n*)\n\n(**\nExample: Calculate the total number of years lived by all players. Hint: transform (\u0060List.map\u0060) each element of \u0060playerStatsTable\u0060 into an integer representing the player\u0027s \u0060Age\u0060 and then get the sum (\u0060List.sum\u0060) of all the players\u0027 ages (the result should be an \u0060int\u0060).\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age)\n|\u003E List.sum\n(*** include-fsi-output ***)\n\n(**\n- Calculate the total goals scored (\u0060GoalsScored\u0060) by all players in \u0060playerStatsTable\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSum, define-output: ListSum ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored)\n|\u003E List.sum\n\n(*** condition:html, include:ListSum ***)\n(*** condition:html, include-fsi-output:ListSum ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 6 List.sumBy\n\nWe are using a dataset that has multiple fields per List element. If you want to get the sum for particular fields it convenient to use \u0060List.sumBy\u0060.\nIt takes a function and transforms each element using that function and afterward sums all the transformed elements. It is like an \u0060List.map\u0060 and \u0060List.sum\u0060 combined into one function.\n*)\n\n(**\nExample: Use \u0060List.sumBy\u0060 to calculate the total number of years lived by all players in \u0060playerStatsTable\u0060. Remember that each player has lived \u0060Age\u0060 years.\n*)\n\nplayerStatsTable\n|\u003E List.sumBy(fun x -\u003E x.Age)\n(*** include-fsi-output ***)\n\n(**\n- Find the sum of the \u0060GoalsScored\u0060 by all players in \u0060playerStatsTable\u0060 using \u0060List.sumBy\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListSumBy, define-output: ListSumBy ***)\n\nplayerStatsTable\n|\u003E List.sumBy(fun x -\u003E x.GoalsScored)\n\n(*** condition:html, include:ListSumBy ***)\n(*** condition:html, include-fsi-output:ListSumBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n\n### 7 List.average\n\n\u0060[1.0; 2.0; 5.0; 2.0] |\u003E List.average\u0060 returns \u00602.5\u0060 (the average of all the List elements).\n*)\n\n(**\nExample: Transform \u0060playerStatsTable\u0060 into a list of the players\u0027 ages (\u0060Age\u0060) and find the average \u0060Age\u0060 (\u0060List.average\u0060).  \nThe field \u0060x.Age\u0060 needs to be transformed from \u0060int\u0060 to \u0060float\u0060 because \u0060List.average\u0060 only works with \u0060floats\u0060 or \u0060decimals\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E float x.Age)\n|\u003E List.average\n(*** include-fsi-output ***)\n\n(**\n- Use \u0060List.map\u0060 to transform \u0060playerStatsTable\u0060 into a list of the players\u0027 \u0060GoalsScored\u0060 and find the average \u0060GoalsScored\u0060 (\u0060List.average\u0060).  \nHint: The variable \u0060x.GoalsScored\u0060 needs to be transformed from \u0060int\u0060 to \u0060float\u0060 since \u0060List.average\u0060 only works with \u0060floats\u0060 or \u0060decimals\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListAverage, define-output: ListAverage ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E float x.GoalsScored)\n|\u003E List.average\n\n(*** condition:html, include:ListAverage ***)\n(*** condition:html, include-fsi-output:ListAverage ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 8 List.averageBy\n\nWe are using a dataset that has multiple fields per List element. If you want to get the average for particular fields it convenient to use \u0060List.averageBy\u0060.\nIt takes a function and transforms each element using that function and afterward averages all the transformed elements. It is like an \u0060List.map\u0060 and \u0060List.average\u0060 combined into one function.\n*)\n\n(**\nExample: Find the average \u0060Age\u0060 using \u0060List.averageBy\u0060.  \nThe \u0060Age\u0060 needs to be transformed from \u0060int\u0060 to \u0060float\u0060 since \u0060List.averageBy\u0060 only works with \u0060floats\u0060 or \u0060decimals\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.averageBy(fun x -\u003E float x.Age)\n(*** include-fsi-output ***)\n\n(**\n- Find the average \u0060GoalsScored\u0060 using \u0060List.averageBy\u0060.  \nHint: The \u0060GoalsScored\u0060 needs to be transformed from \u0060int\u0060 to \u0060float\u0060 since \u0060List.averageBy\u0060 only works with \u0060floats\u0060 or \u0060decimals\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListAverageBy, define-output: ListAverageBy ***)\n\nplayerStatsTable\n|\u003E List.averageBy(fun x -\u003E float x.GoalsScored)\n\n(*** condition:html, include:ListAverageBy ***)\n(*** condition:html, include-fsi-output:ListAverageBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 9 Seq.stDev\n\nFor \u0060Seq.stDev\u0060 to work, we loaded the \u0060FSharp.Stats nuget\u0060 (\u0060#r \u0022nuget: FSharp.Stats\u0022\u0060).\nThis nuget contains the standard deviation function.\nBesides this we also opened the module \u0060FSharp.Stats\u0060 (\u0060open FSharp.Stats\u0060).\n[FSharp.Stats documentation](https://fslab.org/FSharp.Stats/)\n*)\n\n(**\nExample: Use \u0060List.map\u0060 to transform \u0060playerStatsTable\u0060 by \u0060GoalsScored\u0060 and find the standard deviation. (\u0060Seq.stDev\u0060).  \nNote that for \u0060Seq.stDev\u0060 to work the values need to be \u0060floats\u0060 or \u0060decimals\u0060, so we need to transform the \u0060GoalsScored\u0060 from \u0060int\u0060 to \u0060float\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E float x.GoalsScored)\n|\u003E Seq.stDev\n(*** include-fsi-output ***)\n\n(**\n- Transform \u0060playerStatsTable\u0060 into a list of the players\u0027 \u0060Age\u0060\u0027s and find the standard deviation. (\u0060Seq.stDev\u0060).  \nHint: You need to transform \u0060Age\u0060 values from \u0060int\u0060 to \u0060floats\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ListStDev, define-output: ListStDev ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E float x.Age)\n|\u003E Seq.stDev\n\n(*** condition:html, include:ListStDev ***)\n(*** condition:html, include-fsi-output:ListStDev ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 10 Seq.pearsonOfPairs\n\nIn order to perform correlations we have to load and open the namespace \u0060FSharp.Stats\u0060.  \nAlso, we \u0060open FSharpe.Stats.Correlation\u0060 to allow a easier access to the correlation functions.  \n\nIt will be helpfull to check the [FSharp.Stats.Correlation Documentation](https://fslab.org/FSharp.Stats/reference/fsharp-stats-correlation-seq.html#pearson) before starting the exercises.  \n*)\n\n(**\nExample: Test the correlation between \u0060MatchesPlayed\u0060 and \u0060GoalsScored\u0060 using \u0060pearsonOfPairs\u0060.  \n\n\u0060Seq.pearsonOfPairs\u0060 expects a list of tuples (x1 * x2), computing the correlation between x1 and x2. \nSo we use \u0060List.map\u0060 to get a list of tuples with (\u0060MatchesPlayed\u0060, \u0060GoalsScored\u0060).\nThen we only need to pipe (\u0060|\u003E\u0060) to \u0060Seq.pearsonOfPairs\u0060. \n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.MatchesPlayed, x.GoalsScored)\n|\u003E Seq.pearsonOfPairs\n(*** include-fsi-output ***)\n\n(**\n- Test the correlation between \u0060MatchesPlayed\u0060 and \u0060Age\u0060 using \u0060pearsonOfPairs\u0060.  \nHints:\n\u0060Seq.pearsonOfPairs\u0060 expects a list of tuples (x1 * x2). Use \u0060List.map\u0060 to get a list of tuples with (\u0060MatchesPlayed\u0060, \u0060Age\u0060).\nThen you only need to pipe (\u0060|\u003E\u0060) to \u0060Seq.pearsonOfPairs\u0060.  \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: pearsonMatchesAndAge, define-output: pearsonMatchesAndAge ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.MatchesPlayed, x.Age)\n|\u003E Seq.pearsonOfPairs\n\n(*** condition:html, include:pearsonMatchesAndAge ***)\n(*** condition:html, include-fsi-output:pearsonMatchesAndAge ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n(**\n- Test the correlation between \u0060GoalsScored\u0060 and \u0060Age\u0060 using \u0060pearsonOfPairs\u0060.  \nHints:\n\u0060Seq.pearsonOfPairs\u0060 expects a list of tuples (x1 * x2). Use \u0060List.map\u0060 to get a list of tuples with (\u0060GoalsScored\u0060, \u0060Age\u0060).\nThen you only need to pipe (\u0060|\u003E\u0060) to \u0060Seq.pearsonOfPairs\u0060.\n\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: pearsonGoalsAndAge, define-output: pearsonGoalsAndAge ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.GoalsScored, x.Age)\n|\u003E Seq.pearsonOfPairs\n\n(*** condition:html, include:pearsonGoalsAndAge ***)\n(*** condition:html, include-fsi-output:pearsonGoalsAndAge ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Further Statistics practice\n\nNow that you should feel confortable with \u0060List.filter\u0060, \u0060List.groupBy\u0060, \u0060List.splitInto\u0060  \nand also some f# statistics functions, let\u0027s combine those concepts together. \n*)\n\n\n(**\n### 1 List.countBy, List.filter and List.averageBy\n\nExample: Find the average goals scored by portuguese players.\n*) \n\n(**\nIn order to find the average goals for portuguese players we know that we need to use \u0060\u0060List.filter\u0060\u0060.\nBut we need to know what is the string correspondent to portuguese players!\nUsing \u0060List.distinct\u0060 or \u0060List.countBy\u0060 we can observe all the \u0060Nation\u0060 strings, which allow us to see that portuguese Nation string is \u0060\u0022pt POR\u0022\u0060.\n*)\n\nplayerStatsTable\n|\u003E List.countBy(fun x -\u003E x.Nation)\n\n(**\nNow that we know what is the Portuguese string we can filter \u0060x.Nation = \u0022pt POR\u0022\u0060 in order to only get portuguese players\u0027 rows!\nThen we can easily pipe it (\u0060|\u003E\u0060) to \u0060List.averageBy (fun x -\u003E float x.Age)\u0060 to get the average age of portuguese players.\n*)\n\nplayerStatsTable\n|\u003E List.filter(fun x -\u003E x.Nation = \u0022pt POR\u0022)\n|\u003E List.averageBy(fun x -\u003E float x.Age)\n(*** include-fsi-output ***)\n\n(**\n- Find the average age for players playing on the Premier League  .\nHint:\nYou\u0027ll first need to use \u0060List.filter\u0060 to get only players from the Premier League (\u0060x.League = \u0022engPremier League\u0022\u0060).  \nThen use averageBy to compute the average by age, don\u0027t forget to use \u0060float x.Age\u0060 to transform age values to float type.  \n*)\n\n\n(*** include-it-raw:preDetails ***)\n(*** define: filterAndAverageBy, define-output: filterAndAverageBy ***)\n\nplayerStatsTable\n|\u003E List.filter(fun x -\u003E x.League = \u0022engPremier League\u0022)\n|\u003E List.averageBy(fun x -\u003E float x.Age)\n\n(*** condition:html, include:filterAndAverageBy ***)\n(*** condition:html, include-fsi-output:filterAndAverageBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 2. List.groupBy, List.map and transformations.\n\n\nExample: Group \u0060playerStatsTable\u0060 by \u0060Team\u0060 and compute the average number of \u0060GoalsScored\u0060.\n*)\n\n//example using record:\ntype TeamAndAvgGls =\n    { Team : string\n      AvgGoalsScored : float }\n\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.Team)\n|\u003E List.map(fun (team, playerStats) -\u003E \n    { Team = team\n      AvgGoalsScored = playerStats |\u003E List.averageBy(fun playerStats -\u003E float playerStats.GoalsScored)})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\nor\n*)\n\n//example using tuple:\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.Team)\n|\u003E List.map(fun (team, playerStats) -\u003E team, playerStats |\u003E List.averageBy(fun playerStats -\u003E float playerStats.GoalsScored))\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Group \u0060playerStatsTable\u0060 by \u0060League\u0060 and then compute the Average \u0060Age\u0060 by group.  \nHint: Use \u0060groupBy\u0060 to group by league (\u0060League\u0060).  \nThen use \u0060averageBy\u0060 to compute the average by age (\u0060Age\u0060) and pipe it \n(\u0060|\u003E\u0060) to \u0060List.map\u0060 to organize the data in a record or tuple with League (\u0060League\u0060) and Average Age.   \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: AvgAgeByGroup, define-output: AvgAgeByGroup ***)\n\n//solution using record:\ntype LeagueAndAvgAge =\n    { League : string \n      AverageAge : float }\n\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.League)\n|\u003E List.map(fun (leagues, playerStats) -\u003E\n    { League = leagues\n      AverageAge = playerStats |\u003E List.averageBy(fun playerStats -\u003E float playerStats.Age) })\n\n//solution using tuples:\nplayerStatsTable\n|\u003E List.groupBy(fun x -\u003E x.League)\n|\u003E List.map(fun (leagues, playerStats) -\u003E \n    leagues, \n    playerStats |\u003E List.averageBy(fun playerStats -\u003E float playerStats.Age) )\n\n\n(*** condition:html, include:AvgAgeByGroup ***)\n(*** condition:html, include-fsi-output:AvgAgeByGroup ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 3 List.sortDescending, List.splitInto, List.map and Seq.stDev\n\n- From \u0060playerStatsTable\u0060 sort the players\u0027 \u0060Age\u0060 (descending), split the dataset into quartiles (4-quantiles) and compute the standard deviation for each quantile.  \nHint: You only need the \u0060Age\u0060 field from the dataset, so you can use \u0060map\u0060 straight away to get the \u0060Age\u0060 List.\nSort that List with \u0060List.sortDescending\u0060, and then split it into 4 parts using \u0060List.splitInto\u0060.\nFinally use \u0060List.map\u0060 to iterate through each quantile and apply the function \u0060Seq.stDev\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: stDevByAgeGroup, define-output: stDevByAgeGroup ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E float x.Age)\n|\u003E List.sortDescending\n|\u003E List.splitInto 4\n|\u003E List.map(fun x -\u003E x |\u003E Seq.stDev)\n\n(*** condition:html, include:stDevByAgeGroup ***)\n(*** condition:html, include-fsi-output:stDevByAgeGroup ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/football-plotting.html","title":"Plotting (with solutions)","content":"(**\n---\ntitle: Plotting (with solutions)\ncategory: Assignments\ncategoryindex: 2\nindex: 4\n---\n*)\n\n(**\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n# Transformations and Plotting\n\n\u003E Developed with [Davide Costa](https://github.com/DavideGCosta)\n\n*)\n\n(*** condition:prepare ***)\n#r \u0022nuget: FSharp.Formatting\u0022\n\ntype H2 = H2 of string \ntype H3 = H3 of string \n\nlet makeNumberedHeading (htmlTag:string) (text:string) =\n    let name = text.Replace(\u0022 \u0022, \u0022-\u0022)\n    let snippet = sprintf $\u0022\u003C{htmlTag} class=numbered\u003E\u003Ca name={name} class=anchor href=#{name}\u003E{text}\u003C/a\u003E\u003C/{htmlTag}\u003E\u0022\n    snippet \nfsi.AddPrinter(fun (H2 text) -\u003E makeNumberedHeading \u0022h2\u0022 text)\nfsi.AddPrinter(fun (H3 text) -\u003E makeNumberedHeading \u0022h3\u0022 text)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n### Reference needed nuget packages and open namespaces\n*)\n\n#r \u0022nuget:FSharp.Data\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.17\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.17\u0022\n\nopen FSharp.Data\nopen FSharp.Stats\nopen FSharp.Stats.Correlation\nopen Plotly.NET\n\n(**\n### Load the Csv file.  \n\n*)\n\nlet [\u003CLiteral\u003E] CsvPath = __SOURCE_DIRECTORY__ \u002B \u0022/FootballPlayers.csv\u0022\ntype FootballPlayersCsv = CsvProvider\u003CCsvPath\u003E\n\nlet playerStatsTable = \n    FootballPlayersCsv.GetSample().Rows\n    |\u003E Seq.toList\n\n(**\n## EXERCISES - PART 3\n\n- [List Functions and Plotting.](#List-Functions-and-Plotting)\n\n    1. [Example: From playerStatsTable create a bar chart with the sum of GoalsScored (y-axis) by League (x-axis)](#1-Example-From-playerStatsTable-create-a-bars-chart-with-the-sum-of-GoalsScored-y-axis-by-League-x-axis)\n    1. [From playerStatsTable create a bar chart with the sum of GoalsScored (y-axis) by Age(x-axis)](#2-From-playerStatsTable-create-a-bars-chart-with-the-sum-of-GoalsScored-y-axis-by-Age-x-axis)\n    1. [Example: From playerStatsTable create a bars chart with the Average of GoalsScored (y-axis) by League (x-axis)](#3-Example-From-playerStatsTable-create-a-bars-chart-with-the-Average-of-GoalsScored-y-axis-by-League-x-axis)\n    1. [From playerStatsTable create a bars chart with the average GoalsScored (y-axis) by Age(x-axis)](#4-From-playerStatsTable-create-a-bars-chart-with-the-average-GoalsScored-per-Match-Played-y-axis-by-Age-x-axis-only-for-Fowrward-Players)\n\n*)\n\n(**\n## List Functions and Plotting\n\nNow that you know how to work with the dataset using the most common List functions, we still need to practice how to create usefull plots with the data.  \n\nFor plotting in F# we load \u0060Plotly.NET\u0060 nuget and open the \u0060Plotly.NET\u0060 namespace.  \nDocumentation links:  \n\n- [Plotly.NET General Documentation](https://plotly.net/)  \n- [Plotly.NET bar and column charts Documentation](https://plotly.net/2_1_bar-and-column-charts.html)  \n- [Plotly.NET line and scatter plots Documentation](https://plotly.net/2_0_line-scatter-plots.html)   \n\nIt will be helpfull to check the documentation before starting the exercises.  \n*)\n\n(**\n### 1 Example: From playerStatsTable create a bar chart with the sum of GoalsScored (y-axis) by League (x-axis).\n\n*)\n\nlet sumGoalsScoredByLeague = \n    playerStatsTable\n    |\u003E List.groupBy(fun x -\u003E x.League)\n    |\u003E List.map(fun (league, playerStats) -\u003E \n        (league,\n         playerStats |\u003E List.sumBy(fun x -\u003E x.GoalsScored)))\n\nlet sumGoalsScoredByLeagueChart =\n    sumGoalsScoredByLeague\n    |\u003E Chart.Column\n    |\u003E Chart.withYAxisStyle(\u0022Sum of Goals Scored\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Top 5 Football Leagues\u0022)\n    |\u003E Chart.withTitle(\u0022Sum of Goals Scored by League\u0022)\n\n(*** do-not-eval ***) \nsumGoalsScoredByLeagueChart\n\n(*** hide ***)\nsumGoalsScoredByLeagueChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### 2 From playerStatsTable create a bar chart with the sum of GoalsScored (y-axis) by Age(x-axis).\nHints:\n*)  \n(**\n\n- Group \u0060playerStatsTable\u0060 by \u0060Age\u0060 using \u0060List.groupBy\u0060.  \n- Map the returned List of tuples, into an List of tuples with two elements.  \n    - First element: age. The first element of the \u0060List.groupBy\u0060 output. Which corresponds to the Age groups.\n    - Second element: sum of goals scored by \u0060Age\u0060, use \u0060List.sumBy\u0060 applied to the second element of the \u0060List.groupBy\u0060 output. Which corresponds to all the rows per \u0060Age\u0060 group.  \n- Then, store this new List of tuples to a variable. (In this case call it \u0060sumGoalsScoredByAge\u0060).  \n- After that in order to create a bar chart we need to follow the syntax: \u0060Chart.Column\u0060.\n- Use the syntax \u0060Chart.withYAxisStyle(\u0022Sum of Goals Score\u0022)\u0060 to label the y-axis.  \n- Use the syntax \u0060Chart.withXAxisStyle(\u0022Age\u0022)\u0060 to label the x-axis.  \n- Use the syntax \u0060Chart.withTitle(\u0022Sum of Goals Score by Age\u0022)\u0060 to give a title to the chart.\n- Then Pipe (\u0060|\u003E\u0060) to \u0060Chart.Show\u0060 if you want to observe the chart.\n\n*)\n\n(*** define: SumGoalsByAge***)\nlet sumGoalsByAge =\n    playerStatsTable\n    |\u003E List.groupBy(fun x -\u003E x.Age)\n    |\u003E List.map(fun (ageGroups, playerStats) -\u003E\n        (ageGroups,\n         playerStats |\u003E List.sumBy(fun x -\u003E x.GoalsScored)))\n\n(*** define: SumGoalsByAgeChart***)\nlet sumGoalsByAgeChart =\n    sumGoalsByAge\n    |\u003E Chart.Column\n    |\u003E Chart.withYAxisStyle(\u0022Sum of Goals Scored\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Age\u0022)\n    |\u003E Chart.withTitle(\u0022Sum of Goals Scored by Age\u0022)\n\n(*** do-not-eval, define: SumGoalsByAgeChartShow ***) \nsumGoalsByAgeChart\n\n(*** hide, define-output:SumGoalsByAgeChartHTML ***)\nsumGoalsByAgeChart |\u003E GenericChart.toChartHTML\n\n(*** condition:html, include-it-raw:preDetails ***)\n(*** condition:html, include:SumGoalsByAge ***)\n(*** condition:html, include:SumGoalsByAgeChart ***)\n(*** condition:html, include:SumGoalsByAgeChartShow ***)\n(*** condition:html, include-it-raw:SumGoalsByAgeChartHTML ***)\n(*** condition:html, include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n### 3 Example: From playerStatsTable create a bar chart with the Average of GoalsScored (y-axis) by League (x-axis).\n*)\n\nlet averageGoalsScoredByLeague = \n    playerStatsTable\n    |\u003E List.groupBy(fun x -\u003E x.League)\n    |\u003E List.map(fun (league, playerStats) -\u003E \n        (league,\n         playerStats |\u003E List.averageBy(fun x -\u003E float x.GoalsScored)))\n\nlet averageGoalsScoredByLeagueChart = \n    averageGoalsScoredByLeague\n    |\u003E Chart.Column\n    |\u003E Chart.withYAxisStyle(\u0022Average of Goals Scored\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Top 5 Football Leagues\u0022)\n    |\u003E Chart.withTitle(\u0022Average of Goals Scored by League\u0022)\n\n(*** do-not-eval ***) \naverageGoalsScoredByLeagueChart\n\n(*** hide ***)\naverageGoalsScoredByLeagueChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### 4 From playerStatsTable create a bars chart with the average GoalsScored per Match Played(y-axis) by Age(x-axis) only for Forward Players.\n\nHints: \n*)\n(**\n\n- Filter \u0060playerStatsTable\u0060 by \u0060Position\u0060 to get only forward position (\u0060Position = \u0022FW\u0022\u0060), use \u0060List.Filter\u0060.\n- Group \u0060playerStatsTable\u0060 by \u0060Age\u0060 using \u0060List.groupBy\u0060.\n- Map the returned List of tuples, into an List of tuples with two elements.\n\n    - First element: age --\u003E The first element of the \u0060List.groupBy\u0060 output. Which corresponds to the Age groups.\n    - Second element: sum of total GoalsScored divided by the total games played by age. \n                      Note that you can get the total games played by using \u0060List.sumBy(fun x -\u003E x.MatchesPlayed)\u0060.\n                      Also remember to transform the variables to \u0060floats\u0060 before dividing to get the exact results.\n                      \n- Then, store this new List of tuples to a variable. (Name it \u0060averageGoalsPerMatchByAgeFW\u0060).\n- After that, in order to create a bars chart we need to follow the syntax: \u0060Chart.Column\u0060, you just need to pipe (\u0060|\u003E\u0060) the variable \u0060averageGoalsPerMatchByAgeFW\u0060 to \u0060Chart.Column\u0060.\n- Use the syntax \u0060Chart.withYAxisStyle(\u0022Average of Goals Scored Per Match\u0022)\u0060 to label the y-axis.\n- Use the syntax \u0060Chart.withXAxisStyle(\u0022Age\u0022)\u0060 to label the x-axis.\n- Use the syntax \u0060Chart.withTitle(\u0022Average of Goals Scored Per Match by Age\u0022)\u0060 to give a title to the chart.\n- Then Pipe (\u0060|\u003E\u0060) to \u0060Chart.Show\u0060 if you want to observe the chart.\n\n*)\n\n\n(*** define: averageGoalsPerMatchByAgeFW***)\nlet averageGoalsPerMatchByAgeFW =\n    // Some players don\u0027t play many games in a season\n    // so we need to normalize their skill by dividing by the number of games played.\n    playerStatsTable\n    |\u003E List.filter(fun x -\u003E x.Position = \u0022FW\u0022 )\n    |\u003E List.groupBy(fun x -\u003E x.Age)\n    |\u003E List.map(fun (age, playerStats) -\u003E\n        // weighted average, where the weight is games played.\n        let totalGamesPlayed = playerStats |\u003E List.sumBy(fun x -\u003E x.MatchesPlayed)\n        (   age,\n            playerStats \n            |\u003E List.sumBy(fun x -\u003E \n                float x.GoalsScored/ float totalGamesPlayed )))\n\n(*** define: averageGoalsPerMatchByAgeFWChart***)\nlet averageGoalsPerMatchByAgeFWChart = \n    averageGoalsPerMatchByAgeFW\n    |\u003E Chart.Column\n    |\u003E Chart.withYAxisStyle(\u0022Average of Goals Scored Per Match\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Age\u0022)\n    |\u003E Chart.withTitle(\u0022Average of Forward Position (FW) Goals Scored per Match By Age\u0022)\n\n(*** do-not-eval, define: averageGoalsPerMatchByAgeFWChartShow ***) \naverageGoalsPerMatchByAgeFWChart\n\n(*** hide, define-output:averageGoalsPerMatchByAgeFWChartHTML ***)\naverageGoalsPerMatchByAgeFWChart |\u003E GenericChart.toChartHTML\n\n(*** condition:html, include-it-raw:preDetails ***)\n(*** condition:html, include:averageGoalsPerMatchByAgeFW ***)\n(*** condition:html, include:averageGoalsPerMatchByAgeFWChart ***)\n(*** condition:html, include:averageGoalsPerMatchByAgeFWChartShow ***)\n(*** condition:html, include-it-raw:averageGoalsPerMatchByAgeFWChartHTML ***)\n(*** condition:html, include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n"},{"uri":"/Teaching/football-tuples-and-records.html","title":"Tuples and Records (with solutions)","content":"(**\n---\ntitle: Tuples and Records (with solutions)\ncategory: Assignments\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n# Working with Tuples and Records.\n\n\u003E Developed with [Davide Costa](https://github.com/DavideGCosta)\n\nThis set of exercises covers creating and manipulating tuples, records, and anonymous records.\nBefore you start it is a good idea to review the relevant sections of\nthe F# language reference (\n[tuples](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/tuples),\n[records](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/records),\nand [anonymous records](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/anonymous-records)\n) and\nF# for fun and profit (\n[tuples](https://fsharpforfunandprofit.com/posts/tuples/) and\n[records](https://fsharpforfunandprofit.com/posts/records/))\nbefore you start.\n*)\n\n\n(*** condition:prepare ***)\n#r \u0022nuget: FSharp.Formatting\u0022\n\ntype H2 = H2 of string \ntype H3 = H3 of string \n\nlet makeNumberedHeading (htmlTag:string) (text:string) =\n    let name = text.Replace(\u0022 \u0022, \u0022-\u0022)\n    let snippet = sprintf $\u0022\u003C{htmlTag} class=numbered\u003E\u003Ca name={name} class=anchor href=#{name}\u003E{text}\u003C/a\u003E\u003C/{htmlTag}\u003E\u0022\n    snippet \nfsi.AddPrinter(fun (H2 text) -\u003E makeNumberedHeading \u0022h2\u0022 text)\nfsi.AddPrinter(fun (H3 text) -\u003E makeNumberedHeading \u0022h3\u0022 text)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n## Import the Football Players Data from the Csv File\n*)\n\n#r \u0022nuget:FSharp.Data\u0022\nopen FSharp.Data\n\n(**\nIn order to import the data correctly we need to create the sample, define the type from the sample and then load the csv file.\nWe\u0027ll use [FSharp.Data CsvProvider](https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html).\n \n### Load the Csv file.  \n\nWe define the type from the csv sample file.\n*)\n\nlet [\u003CLiteral\u003E] CsvPath = __SOURCE_DIRECTORY__ \u002B \u0022/FootballPlayers.csv\u0022\ntype FootballPlayersCsv = CsvProvider\u003CCsvPath\u003E\n\n(**\nThis will load the sample csv file.\n*)\nlet playerStatsTable = \n    FootballPlayersCsv.GetSample().Rows\n    |\u003E Seq.toList\n\n(**\nLet\u0027s see the first 5 rows from the loaded Csv data, stored in \u0060playerStatsTable\u0060.\nAgain, we do this by using the List \u0060List.truncate\u0060 property.\n*)\nplayerStatsTable\n|\u003E List.truncate 5\n(*** include-fsi-output ***)\n\n(**\n## EXERCISES - PART 1\n\n- [Transforming collection elements into new types.](#Transforming-collections)\n\n    1. [Creating tuples.](#Creating-tuples)\n    2. [Creating records.](#Creating-records)\n    3. [Creating anonymous records.](#Creating-anonymous-records)\n\n- [Simple data transformations.](#Simple-transformations)\n    1. [Transformations using tuples.](#Transformations-using-tuples)\n    2. [Transformations using records.](#Transformations-using-records)\n    3. [Transformations using anonymous records.](#Transformations-using-anonymous-records)\n\n- [Creating and transforming TeamRecord.](#Creating-and-transforming-TeamRecord)\n*)\n\n(***hide***)\nH2 \u0022Transforming collections\u0022\n(*** include-it-raw ***)\n\n(***hide***)\nH3 \u0022Creating tuples\u0022\n(*** include-it-raw ***)\n\n\n(**\nExample: Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and nation ( \u0060Player\u0060, \u0060Nation\u0060)\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.Nation)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and team ( \u0060Player\u0060, \u0060Team\u0060)\n*)\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndTeamTuple, define-output: PlayerAndTeamTuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.Team)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndTeamTuple ***)\n(*** condition:html, include-fsi-output:PlayerAndTeamTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and league/competiton ( \u0060Player\u0060, \u0060League\u0060)\n*)\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndLeagueTuple, define-output: PlayerAndLeagueTuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.League)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndLeagueTuple ***)\n(*** condition:html, include-fsi-output:PlayerAndLeagueTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and age ( \u0060Player\u0060, \u0060Age\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndAgeTuple, define-output: PlayerAndAgeTuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.Age)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndAgeTuple ***)\n(*** condition:html, include-fsi-output:PlayerAndAgeTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and matches played ( \u0060Player\u0060, \u0060MatchesPlayed\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndMatchesTuple, define-output: PlayerAndMatchesTuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.MatchesPlayed)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndMatchesTuple ***)\n(*** condition:html, include-fsi-output:PlayerAndMatchesTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into a tuple with the player and goals scored ( \u0060Player\u0060, \u0060GoalsScored\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoalsTuple, define-output: PlayerAndGoalsTuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, x.GoalsScored)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoalsTuple ***)\n(*** condition:html, include-fsi-output:PlayerAndGoalsTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n(**\n\n*)\n\n(*** hide ***)\nH3 \u0022Creating records\u0022\n(*** include-it-raw ***)\n\n\n(**\nExample: Define a record named \u0060PlayerAndNation\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060Nation\u0060 that is a \u0060string\u0060. \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndNation\u0060 record.\n*)\n\ntype PlayerAndNation =\n    { Player : string \n      Nation : string }\n\n(**\nThe above code creates a record type called \u0060PlayerAndNation\u0060.\nThis record contains two fields: \u0060Player\u0060 of \u0060string\u0060 type and \u0060Nation\u0060 of \u0060string\u0060 type.\nRemember, if the types from the csv file are different an error will occur when creating an instance of the record.\n \nCommon types: \n\n- \u0060string\u0060, example: \u0060\u0022hello world\u0022\u0060\n- \u0060int\u0060, example: \u00602\u0060\n- \u0060float\u0060, example: \u00602.0\u0060\n- \u0060decimal\u0060, example: \u00602.0m\u0060\n\nCheck [basic types documentation](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/basic-types)\nto learn about F# basic types.\n\n*)\n\n(**\nNow by having the record type created we can \u0060map\u0060 the \u0060playerStatsTable\u0060 rows to the record \u0060PlayerAndNation\u0060.\n*)\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player\n      Nation = x.Nation })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\nNote that you choose the name of the fields in the record. Instead of \u0060Player\u0060 it could be anything.\nThe following code block for example would have also worked, \nbut the field name for the player is \u0060PlayerName\u0060 instead of \u0060Player\u0060 and \u0060Nationality\u0060 instead of \u0060Nation\u0060:\n*)\ntype PlayerAndNation2 =\n    { PlayerName : string \n      Nationality : string }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { PlayerName = x.Player\n      Nationality = x.Nation })\n\n(**\n- Define a record named \u0060PlayerAndTeam\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060Team\u0060 that is a \u0060string\u0060. \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndTeam\u0060 record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndTeamRecord, define-output: PlayerAndTeamRecord ***)\n\ntype PlayerAndTeam =\n    { Player : string\n      Team : string }\n   \nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player \n      Team = x.Team })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndTeamRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndTeamRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Define a record named \u0060PlayerAndLeague\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060League\u0060 that is a \u0060string\u0060. \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndLeague\u0060 record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndLeagueRecord, define-output: PlayerAndLeagueRecord ***)\n\ntype PlayerAndLeague =\n    { Player : string\n      League : string }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player\n      League = x.League })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndLeagueRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndLeagueRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Define a record named \u0060PlayerAndAge\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060Age\u0060 that is a integer(\u0060int\u0060). \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndAge\u0060 record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndAgeRecord, define-output: PlayerAndAgeRecord ***)\n\ntype PlayerAndAge =\n    { Player : string\n      Age : int }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player\n      Age =  x.Age })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndAgeRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndAgeRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Define a record named \u0060PlayerAndMatchesPlayed\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060MatchesPlayed\u0060 that is a integer(\u0060int\u0060). \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndMatchesPlayed\u0060 record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndMatchesRecord, define-output: PlayerAndMatchesRecord ***)\n\ntype PlayerAndMatchesPlayed =\n    { Player : string\n      MatchesPlayed : int }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player \n      MatchesPlayed = x.MatchesPlayed})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndMatchesRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndMatchesRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Define a record named \u0060PlayerAndGoalsScored\u0060 with a field named \u0060Player\u0060 that is a \u0060string\u0060 and \u0060GoalsScored\u0060 that is a integer(\u0060int\u0060). \nThen transform each element of the \u0060playerStatsTable\u0060 List into a \u0060PlayerAndGoalsScored\u0060 record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoalsRecord, define-output: PlayerAndGoalsRecord ***)\n\ntype PlayerAndGoalsScored = \n    { Player : string\n      GoalsScored : int }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player \n      GoalsScored = x.GoalsScored })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoalsRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndGoalsRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(*** hide ***)\nH3 \u0022Creating anonymous records\u0022\n(*** include-it-raw ***)\n\n(**\nExample: Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060Nation\u0060 field that is a \u0060string\u0060.\n\nWith \u0060Anonymous records\u0060 we don\u0027t need to define the record type beforehand and we don\u0027t need to specify the type of each field.\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player\n       Nation = x.Nation |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060Team\u0060 field that is a \u0060string\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndTeam-AnonymousRecord, define-output: PlayerAndTeam-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player \n       Team = x.Team |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndTeam-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndTeam-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060League\u0060 field that is a \u0060string\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndLeague-AnonymousRecord, define-output: PlayerAndLeague-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player\n       League = x.League |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndLeague-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndLeague-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060Age\u0060 field that is a integer(\u0060int\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndAge-AnonymousRecord, define-output: PlayerAndAge-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player\n       Age =  x.Age |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndAge-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndAge-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060MatchesPlayed\u0060 field that is a integer(\u0060int\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndMatches-AnonymousRecord, define-output: PlayerAndMatches-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player \n       MatchesPlayed = x.MatchesPlayed |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndMatches-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndMatches-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- Transform each element of the \u0060playerStatsTable\u0060 List into an anonymous record with a \u0060Player\u0060 field that is a \u0060string\u0060 and a \u0060GoalsScored\u0060 field that is a integer(\u0060int\u0060).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-AnonymousRecord, define-output: PlayerAndGoals-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player \n       GoalsScored = x.GoalsScored |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(*** hide ***)\nH2 \u0022Simple transformations\u0022\n(*** include-it-raw ***)\n\n(**\nNow that you are used to work with \u0060List.map\u0060 to organize the data into tuples, records and anonymous records.\nLet\u0027s try to do it while applying some simple transformations as sum, multiplication, type transformations and so on.\n*)\n\n(*** hide ***)\nH3 \u0022Transformations using tuples\u0022\n(*** include-it-raw ***)\n\n(**\nExample: map the \u0060playerStatsTable\u0060 to a tuple of player and age, but add 1 to age. ( \u0060Player\u0060, \u0060Age \u002B 1\u0060)\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Age \u002B 1)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n\nWhen to use integers or floats/decimals:\n\n  1. Use integers if the results of the calculations should be integers (1, 2, 3, 4, ...).\n  2. Use floats or decimals if the results of the calculations may be floats or decimals (1.1, 2.1324, ...).\n\n*)\n\n(**\n- map the \u0060playerStatsTable\u0060 to a tuple of player and goals scored, but multiply goals scored by 10. ( \u0060Player\u0060, \u0060GoalsScored * 10\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-Times10-Tuple, define-output: PlayerAndGoals-Times10-Tuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun  x-\u003E x.Player, x.GoalsScored * 10)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-Times10-Tuple ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-Times10-Tuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- map the \u0060playerStatsTable\u0060 to a tuple of player and goals scored, but divide GoalsScored by 2. ( \u0060Player\u0060, \u0060GoalsScored / 2\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-DividedBy2-Tuple, define-output: PlayerAndGoals-DividedBy2-Tuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player,  x.GoalsScored / 2)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-DividedBy2-Tuple ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-DividedBy2-Tuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\nIn this case, look how dividing using integers rounds the results to the nearest integers.\nIf the results are decimals you might prefer to get exact results.\nFor that you can use floats or decimals types.\nIn order to convert a variable to float you have to use the syntax: \u0060float variable\u0060.\n*)\n\n(**\nExample: map the \u0060playerStatsTable\u0060 to a tuple of player and age, but convert age to float. ( \u0060Player\u0060, \u0060float Age\u0060)\n*)\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, float x.Age) \n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- map the \u0060playerStatsTable\u0060 to a tuple of player and goals scored, but convert goalsScored to float. ( \u0060Player\u0060, \u0060float GoalsScored\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: playerAndGoals-Float-Tuple, define-output: playerAndGoals-Float-Tuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, float x.GoalsScored) \n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:playerAndGoals-Float-Tuple ***)\n(*** condition:html, include-fsi-output:playerAndGoals-Float-Tuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- map the \u0060playerStatsTable\u0060 to a tuple of player and goals scored, but divide goalsScored by 2.0. ( \u0060Player\u0060, \u0060GoalsScored / 2.0\u0060)\nHint: convert goals scored to float and divide by 2.0 (you can\u0027t divide by 2 because if you perform math operations with different types, you\u0027ll get an error).\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-DividedBy2-Tuple, define-output: PlayerAndGoals-DividedBy2-Tuple ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E x.Player, float x.GoalsScored / 2.0)\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-DividedBy2-Tuple ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-DividedBy2-Tuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(*** hide ***)\nH3 \u0022Transformations using records\u0022\n(*** include-it-raw ***)\n\n(**\nExample: map the \u0060playerStatsTable\u0060 to a record of player and age, but add 1 to age. ( \u0060Player\u0060, \u0060Age \u002B 1\u0060)\n*)\ntype PlayerAndAgePlus1Int =\n    { Player : string\n      AgePlus1Int : int }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E\n    { Player = x.Player \n      AgePlus1Int = x.Age \u002B 1})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n(**\n- map the \u0060playerStatsTable\u0060 to a record of player and goals scored, but multiply goals scored by 10. ( \u0060Player\u0060, \u0060GoalsScored * 10\u0060)\nHint: You have to create a new type record.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-Times10-Record, define-output: PlayerAndGoals-Times10-Record ***)\n\ntype PlayerAndGls = \n    { Player : string \n      GoalsScored : int}\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player \n      GoalsScored = x.GoalsScored * 10 })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-Times10-Record ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-Times10-Record ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- map the \u0060playerStatsTable\u0060 to a record of player and goals scored, but divide goals scored by 2.0. ( \u0060Player\u0060, \u0060float GoalsScored  / 2.0\u0060)  \nHint: You have to create a new type record, because previous type has goals scored as integers but you want floats.  \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-DividedBy2-Record, define-output: PlayerAndGoals-DividedBy2-Record ***)\n\ntype PlayerAndGlsFloat = \n    { Player : string \n      GoalsScoredFloat : float}\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    { Player = x.Player \n      GoalsScoredFloat = (float x.GoalsScored) / 2.0 })\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-DividedBy2-Record ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-DividedBy2-Record ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(*** hide ***)\nH3 \u0022Transformations using anonymous records\u0022\n(*** include-it-raw ***)\n\n(**\nExample: map the \u0060playerStatsTable\u0060 to an anonymoys record of player and age, but add 1 to age. ( \u0060Player\u0060, \u0060Age \u002B 1\u0060)\n*)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player\n       AgePlus1 = x.Age \u002B 1 |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)\n\n// or \n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E\n    {| Player = x.Player \n       AgePlus1Float = (float x.Age) \u002B 1.0 |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n(*** include-fsi-output ***)  \n\n(**\n- map the \u0060playerStatsTable\u0060 to an anonymous record of player and goals scored, but multiply goals scored by 10. ( \u0060Player\u0060, \u0060GoalsScored * 10\u0060)\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-Times10-AnonymousRecord, define-output: PlayerAndGoals-Times10-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player \n       GoalsScoredFloat = x.GoalsScored * 10 |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n// or \n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E\n    {| Player = x.Player \n       AgePlus1Float = (float x.GoalsScored) * 10.0 |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-Times10-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-Times10-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n- map the \u0060playerStatsTable\u0060 to an anonymous record of player and goals scored, but divide goals scored by 2.0. ( \u0060Player\u0060, \u0060float GoalsScored  / 2.0\u0060)  \nHint: Remember that you have to transform GoalsScored to float.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PlayerAndGoals-DividedBy2-AnonymousRecord, define-output: PlayerAndGoals-DividedBy2-AnonymousRecord ***)\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E \n    {| Player = x.Player \n       GoalsScoredFloat = (float x.GoalsScored) / 2.0 |})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:PlayerAndGoals-DividedBy2-AnonymousRecord ***)\n(*** condition:html, include-fsi-output:PlayerAndGoals-DividedBy2-AnonymousRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(*** hide ***)\nH2 \u0022Creating and transforming TeamRecord\u0022\n(*** include-it-raw ***)\n\n(**\n\nNow that you are used to work with records and perform simple Transformations, map \u0060playerStatsTable\u0060 to a record type that includes:  \n\n- Player (\u0060Player\u0060) - type \u0060string\u0060  \n- Nation (\u0060Nation\u0060) - type \u0060string\u0060  \n- League (\u0060League\u0060) - type \u0060string\u0060  \n- AgeNextYear (\u0060Age \u002B 1\u0060) - type \u0060int\u0060  \n- HalfGoalsScored (\u0060GoalsScored / 2.0\u0060) - type \u0060float\u0060  \n  \nHint: Create a new type.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: TeamRecord, define-output: TeamRecord ***)\n\ntype TeamRecord = \n    { Player : string\n      Nation : string\n      League : string\n      AgeNextYear : int\n      HalfGoalsScored : float }\n\nplayerStatsTable\n|\u003E List.map(fun x -\u003E\n    { Player = x.Player\n      Nation = x.Nation\n      League = x.League\n      AgeNextYear = x.Age \u002B 1\n      HalfGoalsScored = float x.GoalsScored / 2.0})\n|\u003E List.truncate 5 //just to observe the first 5 rows, not a part of the exercise.\n\n(*** condition:html, include:TeamRecord ***)\n(*** condition:html, include-fsi-output:TeamRecord ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n\n"},{"uri":"/Teaching/fundamentals.html","title":"Fundamentals","content":"(**\n---\ntitle: Fundamentals\ncategory: Lectures\ncategoryindex: 1\nindex: 1\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n# Fundamentals\nA good place to start is to define a one-period return calculation.\n\nObjectives:\n\n- [Interactive programming](#Interactive-programming)\n- [How to calculate returns](#Calculating-returns).\n- [Working with data.](#Working-with-data)\n- [How to calculate return volatility](#Volatility)\n*)\n\n(**\n## Interactive programming\n\nWe are going to focus on interactive programming. This is the most productive (and most common) type of analytic programming. In constrast to compiled programs (e.g, C, C\u002B\u002B, Fortran, Java), interactive programs:\n\n- Allow rapid iterative development.\n- You can quickly quickly write and rewrite sections of code, evaluating the output, without having to rerun the entire program.\n- This is especially useful for financial analysis, because we often evaluate large datasets that take a long time to process.\n\nInteractive programming typically involves a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) (Read, Evaluate, Print, Loop). It is common for scripting langauges such as R, Python, Julia, Ruby, and Perl.\n\n### The terminal\n\nThe most basic way that you can run interactive code is at the command line using an interpreter. We can start the F# interactive interpreter by opening a terminal (e.g., terminal.app, cmd, powershell) and running \u0060dotnet fsi\u0060.\n\nOnce fsi is open, we can type a code snippet in the prompt followed by \u0022;;\u0022 to terminate it and it will run.\n\n![fsi](img/fsi.png)\n\n\nIt is fine to run code this way, but we can do better using an IDE (Integrated development environment) that incorportes syntax highlighting, intellisense tooltips, and execution. We will use two common IDE\u0027s: Visual Studio Code with the Ionide extension and Jupyter Notebooks.\n*)\n\n\n(**\n## Calculating returns\n\n### Basic calculations in fsi\n\nLet\u0027s assume that you have \\$120.00 today and that you had \\$100.00 a year ago. Your annual return is then:\n\n*)\n\n(120.0 / 100.0) - 1.0\n\n(*** include-fsi-output ***)\n\n(**\n### Basic numerical types: float, int, and decimal\n\nNotice that I included a decimal point \u0022.\u0022 in the numbers. The decimal point makes it a [floating point](https://en.wikipedia.org/wiki/Floating-point_arithmetic) number. Floating point numbers (floats) are the most commonly used numerical type for mathematical calculations. \n\nIf we left the decimal point off and wrote \u0022120\u0022 without the \u0022.0\u0022 at the end it would be an integer and we would get the wrong answer because integers cannot represent fractions.\n*)\n\n(120/100) - 1\n\n(*** include-fsi-output ***)\n\n(** The other main numerical data type is [decimal](https://en.wikipedia.org/wiki/Decimal_data_type). *)\n\n(120m/100m) - 1m\n\n(*** include-fsi-output ***)\n\n(** Decimals are used when you need an exact fractional amount. Floats are insufficient in these circumstances because *\u0022... such representations typically restrict the denominator to a power of two ... 0.3 (3/10) might be represented as 5404319552844595/18014398509481984 (0.299999999999999988897769...)\u0022* ([see wiki](https://en.wikipedia.org/wiki/Decimal_data_type)).\n\n### Static type checking\n\nFinally, since F# is staticly typed, we must do arithmetic using numbers that are all the same type. If we mix floats and integers we will get an error:\n\n\u0060\u0060\u0060fsharp\n(120.0 / 100) - 1.0\n\u0060\u0060\u0060\n\u0060\u0060\u0060output\nfundamentals.fsx(18,10): error FS0001: The type \u0027int\u0027 does not match the type \u0027float\u0027\n\u0060\u0060\u0060\nStatic tying can slow you down a bit writing simple small programs, but as programs get larger and more complex the benefits become apparent. Specifically, static typing as implemented by F#:\n\n- helps you ensure that the code is correct (i.e., the type of the input data matches what the function expects). In the words of Yaron Minksy at Janestreet, you can [\u0022make illegal states unrepresentable\u0022](https://blog.janestreet.com/effective-ml-revisited/) (see [here](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/) for F# examples).\n- it also facilitates editor tooling that can check your code without running it and give tooltip errors (you should have seen a tooltip error in your editor if you type \u0060(120.0 / 100) - 1.0\u0060 in your program file). It\u0027s like clippy on steriods (you are too young, but your parents might get this reference).\n\n![clippy](img/intellisense-example.png)\n\n[Image source](https://blog.codinghorror.com/it-looks-like-youre-writing-a-for-loop/)\n\n *)\n\n(**\n### Assigning values\nWe could also do the same calculations by assigning \\$120.00 and \\$100.0 to named values.\n*)\n\nlet yearAgo = 100.0\nlet today = 120.0\n(today / yearAgo) - 1.0\n\n(*** include-fsi-output ***)\n(** This works for one-off calculations, but if we want to do this more than once, then it makes more sense to define a function to do this calculation. *)\n\n(**\n### Defining functions \nFunctions map (or transform) inputs into outputs.\n\nHere is a simple function named \u0060addOne\u0060.\nIt takes an input x and then it adds 1 to whatever x is.\n*)\n\nlet addOne x = x \u002B 1\n\naddOne 0 // here x is 1\naddOne 1 // here x is 2\naddOne 2 // here x is 3\n\n// We can also chain them\naddOne (addOne (addOne 0)) // = (1 \u002B (1 \u002B (1 \u002B 0)))\n\n(**\nWe can define a function to calcuate a return. \n*)\n\nlet calcReturn pv fv = (fv / pv) - 1.0\n\n(** The type signature tells us that \u0060calcReturn\u0060 is a function with two float inputs (pv and fv) and it maps those two inputs into a float output. The program was able to infer that \u0060pv\u0060 and \u0060fv\u0060 are floats because of the \u00601.0\u0060 float in the calculation.*)\n\n(** We can execute it on simple floats:*)\n// here pv = 100., fv = 110.0\ncalcReturn 100.0 110.0\n(*** include-fsi-output ***)\n\n// here pv = 80.0, fv = 60.0\ncalcReturn 80.0 60.0\n\n(*** include-fsi-output ***)\n\n(** Or we can execute it on our previously defined \u0060yearAgo\u0060 and \u0060today\u0060 values: *)\ncalcReturn yearAgo today\n(*** include-fsi-output ***)\n\n(**\n### Handling dividends\nOur prior return calculation did not handle cash distributions such as dividends. We can incorporate dividends with a small modificaton:\n\n*)\n\nlet simpleReturn beginningPrice endingPrice dividend =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\n(**\nThe examples thus far have used simple (per period) compounding. We can also calculate continuously compounded returns, also known as log returns.\n*)\n\nlet logReturn beginningPrice endingPrice dividend =\n    // This is solving for \u0060r\u0060 in FV = PV*e^(rt) where t=1.\n    log(endingPrice \u002B dividend) - log(beginningPrice)\n\n(** These two calculations give slightly different returns.*)\n\nsimpleReturn 100.0 110.0 0.0 \n(*** include-fsi-output ***)\nlogReturn 100.0 110.0 0.0\n(*** include-fsi-output ***)\n\n(** It is typically not important which version of return you use so long as you are consistent and keep track of what type of return it is when you\u0027re compounding things.\n\n**Practice:** Can you write a function to compound an initial investment of \\$100.00 at 6% for 5 years? You can calculate power and exponents using:*)\n\n2.0**3.0\n(*** include-fsi-output ***)\nlog 2.0\n(*** include-fsi-output ***)\nexp 0.6931\n(*** include-fsi-output ***)\nexp(log(2.0))\n(*** include-fsi-output ***)\n\n(**\n### Tuples \nLooking at our return functions, we\u0027re starting to get several values that we\u0027re passing into the functions individaully. It can be useful to group these values together to make it easy to pass them around. Tuples are a simple way to group values.\n\nFurther information about tuples can be found in the [F# Language reference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/tuples) and the [F# for Fun and Profit](https://fsharpforfunandprofit.com/posts/tuples/) websites.\n*)\n\n(1,2)\n(*** include-fsi-output ***)\n(1,2,3)\n(*** include-fsi-output ***)\n(** Tubles can contain mixed types.*)\n(1,\u00222\u0022)\n(*** include-fsi-output ***)\n(** We can also deconstruct tuples. We can use built-in convenience functions for pairs.*)\nfst (1,2)\n(*** include-fsi-output ***)\nsnd (1,2)\n(*** include-fsi-output ***)\n(** We can also deconstruct tuples using pattern matching.*)\nlet (a, b) = (1, 2)\n(*** include-fsi-output ***)\nlet (c, d, e) = (1, \u00222\u0022, 3.0)\n(*** include-fsi-output ***)\n\n(** Now redefining our simple return function to take a single tuple as the input parameter.*)\n\nlet simpleReturnTuple (beginningPrice, endingPrice, dividend) =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\nsimpleReturnTuple (100.0, 110.0, 0.0)\n(*** include-fsi-output ***)\nlet xx = (100.0, 110.0, 0.0)\nsimpleReturnTuple xx\n(*** include-fsi-output ***)\n\n(**\n### Records\nIf we want more structure than a tuple, then we can define a record.\n\nFor more information on records see the relevant sections of the [F# language reference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/records) or [F# for Fun and Profit](https://fsharpforfunandprofit.com/posts/records/) websites.\n\nYou must first define the record type before you use it:\n*)\n\ntype RecordExample = \n    { BeginningPrice : float \n      EndingPrice : float \n      Dividend : float }      \n\n(** And construct a value with that record type.*)\nlet x = { BeginningPrice = 100.0; EndingPrice = 110.0; Dividend = 0.0}\n(*** include-fsi-output ***)\n(** Similar to tuples, we can deconstruct our record value \u0060x\u0060 using pattern matching.*)\nlet { BeginningPrice = aa; EndingPrice = bb; Dividend = cc} = x\n(*** include-fsi-output ***)\n(** We can also access individual fields by name.*)\nx.EndingPrice / x.BeginningPrice\n(*** include-fsi-output ***)\n\n(** We can define a return function that operates on the \u0060RecordExample\u0060 type explicitly:*)\n\nlet simpleReturnRecord1 { BeginningPrice = beginningPrice; EndingPrice = endingPrice; Dividend = dividend} =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\n(** Or we can let the compiler\u0027s type inference figure out the input type.*)\nlet simpleReturnRecord2 x =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (x.EndingPrice \u002B x.Dividend) / x.BeginningPrice - 1.0\n\n(** Or we can provide a type hint to tell the compiler the type of the input.*)\nlet simpleReturnRecord3 (x : RecordExample) =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (x.EndingPrice \u002B x.Dividend) / x.BeginningPrice - 1.0\n\n(** All 3 can be used interchangably, but when you have many similar types a type hint may be necessary to make the particular type that you want explicit.*)\n\nsimpleReturnRecord1 x\n(*** include-fsi-output ***)\nsimpleReturnRecord2 x\n(*** include-fsi-output ***)\nsimpleReturnRecord3 x\n(*** include-fsi-output ***)\n\n\n\n(**\n### Pipelines and lambda expressions\nThis download code used pipelining and lambda functions, which are two important language features. Pipelines are created using the pipe operator (\u0060|\u003E\u0060) and allow you to pipe the output of one function to the input of another. Lambda expressions allow you to create functions on the fly. \n\n*)\n\n1.0 |\u003E fun x -\u003E x \u002B 1.0 |\u003E fun x -\u003E x ** 2.0\n(*** include-fsi-output ***)\n\n(**\n### Collections: Arrays, Lists, Sequences\n\n*)\n\n(** A simple int array.*)\n\nlet ar = [| 0 .. 10 |] \n(** *)\nar |\u003E Array.take 5\n(*** include-fsi-output ***)\n\n(**\nWhen we look at the type signature of the elements in the array \u0060val ar : int []\u0060, it tells us that we have a integer array, meaning an array in which each element of the array is an integer. Arrays are \u0022zero indexed\u0022, meaning the 0th item is the first in the array. We can access the elements individually or use a range to access multiple together.\n*)\n\nar.[0] // or ar[0] in F# 6\n(*** include-fsi-output ***)\nar.[0 .. 2] // or ar[0 .. 2] in F# 6\n(*** include-fsi-output ***)\n\n(** A simple float array.*)\nlet arr = [| 1.0 .. 10.0 |]\narr.[0]\narr.[0 .. 5]\n(*** include-fsi-output ***)\n\n(** Lists and sequences are similar. *)\n// List\n[ 1.0 .. 10.0 ]\n// Sequence\nseq { 1.0 .. 10.0 }\n\n(** Arrays, lists, and sequences have different properties that can make one data structure preferable to the others in a given setting. We\u0027ll discuss these different properties in due time, but for an overview you can see the F# collection language reference [here](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-collection-types). Sequences are the most different as they are \u0022lazy\u0022, meaning \u0022Sequences are particularly useful when you have a large, ordered collection of data but don\u0027t necessarily expect to use all the elements. Individual sequence elements are computed only as required, so a sequence can perform better than a list if not all the elements are used\u0022 (see F# language reference).\n\nThese collections have several built-in functions for operating on them such as map, filter, groupBy, etc.*)\n\narr\n|\u003E Array.map(fun x -\u003E x \u002B 1.0)\n(*** include-fsi-output ***)\n\narr\n|\u003E Array.filter(fun x -\u003E x \u003C 5.0)\n(*** include-fsi-output ***)\narr\n|\u003E Array.groupBy(fun x -\u003E x \u003C 5.0)\n|\u003E Array.map(fun (group, xs) -\u003E Array.min xs, Array.max xs)\n(*** include-fsi-output ***)\n\n(**\n## Working with data\n\nWith this foundation, let\u0027s now try loading some data. We are going to obtain and process the data using an external F# library called [FSharp.Data](https://github.com/fsprojects/FSharp.Data) that makes the processing easier. \n\n### Namespaces\nFirst, let\u0027s create a file directory to hold data. We are going to use built-in dotnet IO (input-output) libraries to do so.\n\n*)\n\n(***do-not-eval***)\n// Set working directory to the this code file\u0027s directory\nSystem.IO.Directory.SetCurrentDirectory(__SOURCE_DIRECTORY__)\n// Now create cache directory one level above the working directory\nSystem.IO.File.WriteAllLines(\u0022test.txt\u0022,[\u0022first\u0022;\u0022second\u0022]) \n\n(** This illustrates the library namespace hierarchy. If we want to access the function within the hierarchy without typing the full namespace repetitively, we can open it. The following code is equivalent.\n\n\u0060\u0060\u0060\nopen System.IO\nDirectory.SetCurrentDirectory(__SOURCE_DIRECTORY__)\nFile.WriteAllLines(\u0022test.txt\u0022,[\u0022first\u0022;\u0022second\u0022]) \n\u0060\u0060\u0060\n\nIt is common to open the System namespace\n*)\n\nopen System\n\n(**\n### API keys\nWe are going to request the data from the provider [tiingo](https://api.tiingo.com/). Make sure that you are signed up and have your [API token](https://api.tiingo.com/documentation/general/connecting). An [API](https://en.wikipedia.org/wiki/API) (application programming interface) allows you to write code to communicate with another program. In this case we are goig to write code that requests stock price data from tiingo\u0027s web servers.\n\nOnce you have your api key, create a file called \u0060secrets.fsx\u0060 and save it at the root/top level of your project folder. In \u0060secrets.fsx\u0060, assign your key to a value named \u0060tiingoKey\u0060. If you are using git, make sure to add \u0060secrets.fsx\u0060 to your \u0060.gitignore\u0060 file.\n\n\u0060\u0060\u0060fsharp\nlet tiingoKey = \u0022yourSuperSecretApiKey\u0022\n\u0060\u0060\u0060\n\nWe can load this in our interactive session as follows, assuming that \u0060secrets.fsx\u0060 is located one folder above the current one in the file system.\n\n\n    #load \u0022secrets.fsx\u0022\n\nand we can access the value by typing \n\n    Secrets.tiingoKey\n\n*)\n\n(**\n### FSharp.Data Csv Type Provider\nWe\u0027re now going to process our downloaded data using the **FSharp.Data** [Csv Type Provider](http://fsprojects.github.io/FSharp.Data/library/CsvProvider.html). This is code that automatically defines the types of input data based on a sample. We have already reference the nuget packaged and opened the namespace, so we can just use it now.\n*)\n\n#load \u0022Common.fsx\u0022\nopen Common\n\n\nlet aapl = \n    \u0022AAPL\u0022\n    |\u003E Tiingo.request\n    |\u003E Tiingo.get  \n\naapl\n|\u003E Array.take 5\n(***include-it***)\n\n\n(**\n### Plotting\nNow let\u0027s plot the stock price using [Plotly.NET](https://plotly.github.io/Plotly.NET/).\n*)\n\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.17\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.17\u0022\nopen Plotly.NET\n\n\nlet sampleChart =\n    aapl\n    |\u003E Seq.map(fun x -\u003E x.Date, x.AdjClose)\n    |\u003E Chart.Line\n\n(***do-not-eval***)\nsampleChart |\u003E Chart.show   \n\n(***hide***)\nsampleChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) \n\n(**\nLet\u0027s calculate returns for this data. Typically we calculate close-close returns. Looking at the data, we could use the \u0060close\u0060, \u0060divCash\u0060, and \u0060splitFacor\u0060 columns to calculate returns accounting for stock splits and dividends (a good at home exercise). But there is also an \u0060adjClose\u0060 column that accounts for both those things. So we we can use this\n*)\n\n// Returns\nlet returns = \n    aapl\n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.pairwise\n    |\u003E Seq.map(fun (a,b) -\u003E b.Date, calcReturn (float a.AdjClose) (float b.AdjClose))\n\nlet avgReturnEachMonth = \n    returns\n    |\u003E Seq.groupBy(fun (date, ret) -\u003E DateTime(date.Year, date.Month,1))\n    |\u003E Seq.map(fun (month, xs) -\u003E month, Seq.length xs, xs |\u003E Seq.averageBy snd)\n\n(** We can look at a few of these*)\navgReturnEachMonth |\u003E Seq.take 3 |\u003E Seq.toList\n(***include-fsi-output***)\n\n(** The default DateTime printing is too verbose if we don\u0027t care about time. We can simplify the printing:\n\n    fsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n *)\n\navgReturnEachMonth |\u003E Seq.take 3 |\u003E Seq.toList\n(***include-fsi-output***)\n\nlet monthlyReturnChart =\n    avgReturnEachMonth\n    |\u003E Seq.map(fun (month, cnt, ret) -\u003E month, ret)\n    |\u003E Chart.Bar\n\n(***do-not-eval***)\nmonthlyReturnChart |\u003E Chart.show\n(***hide***)\nmonthlyReturnChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) \n\n(**\n## Volatility\nWe represent volatility by the standard deviation of returns. We can define a standard deviation function ourself.\n*)\n\nlet stddev xs =\n    let mu = xs |\u003E Seq.average\n    let sse = xs |\u003E Seq.sumBy(fun x -\u003E (x - mu)**2.0)\n    let n = xs |\u003E Seq.length |\u003E float\n    sqrt (sse / (n - 1.0))\n\n[1.0 .. 10.0 ] |\u003E stddev    \n(***include-fsi-output***)\n\n(**\nBut it is also convenient to use the [FSharp.Stats](https://fslab.org/FSharp.Stats/)\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\n\nopen FSharp.Stats\n[1.0 .. 10.0 ] |\u003E Seq.stDev\n(***include-fsi-output***)\n\n(** Now let\u0027s look at 5-day rolling volatilities.*)\n\nlet rollingVols =\n    returns\n    // Sort by date again because you never can be too careful\n    // about making sure that you have the right sort order.\n    |\u003E Seq.sortBy fst \n    |\u003E Seq.windowed 5\n    |\u003E Seq.map(fun xs -\u003E\n        let maxWindowDate = xs |\u003E Seq.map fst |\u003E Seq.max\n        let dailyVol = xs |\u003E Seq.stDevBy snd\n        let annualizedVolInPct = dailyVol * sqrt(252.0) * 100.0\n        maxWindowDate, annualizedVolInPct)\n\nlet volChart = \n    rollingVols\n    |\u003E Chart.Line\n\n(***do-not-eval***)\nvolChart |\u003E Chart.show    \n(***hide***)\nvolChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) "},{"uri":"/Teaching/index.html","title":"index","content":"This site contains content used in courses taught by [Nicholas Hirschey](http://www.nhirschey.com). Most material is for the *Data Analytics for Finance* course in the masters degree program at [Nova SBE](http://www.novasbe.pt).\r\n\r\nSee the [Install Software](install.html) page for information on how to run the code."},{"uri":"/Teaching/install.html","title":"Install Software","content":"---\r\ntitle: Install Software\r\ncategory: Getting Started\r\ncategoryindex: 0\r\nindex: 1\r\n---\r\n\r\n## Quick start\r\n\r\nInstall the software below to run the code on this site. Once this software is installed, click the links at the top of the webpages to download the page as a script or jupyter notebook. The code should run on your computer inside visual studio code as long as the below software is installed:\r\n\r\n1. [.NET 6 SDK](https://dotnet.microsoft.com/en-us/download) for your operating system. \r\n    - This includes the F# language.\r\n    - If it is installed correctly, then if you open a terminal (powershell on windows, terminal app on Mac) and type \r\n        \u0060\u0060\u0060code\r\n        dotnet --version\r\n        \u0060\u0060\u0060\r\n      you should see a version number showing which SDK version you installed.\r\n        \r\n        \u0060\u0060\u0060code\r\n        PS C:\\Users\\nicho\u003E dotnet --version\r\n        6.0.101\r\n        PS C:\\Users\\nicho\u003E\r\n        \u0060\u0060\u0060\r\n2. [Visual Studio Code](https://code.visualstudio.com/) for your operating system.\r\n3. [Ionide](https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp) extension for visual studio code (make sure that visual studio code is installed first).\r\n4. [.NET Interactive Notebooks](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.dotnet-interactive-vscode)  extension for visual studio code (make sure that visual studio code is installed first).\r\n\r\n## More detailed guides\r\n\r\n1. See Microsoft\u0027s [get started with F#](https://dotnet.microsoft.com/en-us/languages/fsharp) website.\r\n2. Watch this [Youtube video](https://youtu.be/1ROKvmcOloo) showing how to download F# tools for use in Visual Studio Code."},{"uri":"/Teaching/learn-fsharp.html","title":"Learn F#","content":"---\r\ntitle: Learn F#\r\ncategory: Getting Started\r\ncategoryindex: 0\r\nindex: 2\r\n---\r\n\r\nThe code on this site is mostly written in [F#](https://dotnet.microsoft.com/languages/fsharp). \r\nF# code tends to be as simple as equivalent Python or R code, \r\nbut it is usually faster and more robust.\r\nThis makes it a good language for finance, where simplicity, speed, and correctness are important. \r\n\r\n## Resources for learning F#\r\n\r\n1. Microsoft\u0027s [Learn F# site](https://dotnet.microsoft.com/en-us/learn/fsharp). In particular:\r\n    - [Luis Quintanilla\u0027s F# for Beginners YouTube series](https://youtube.com/playlist?list=PLdo4fOcmZ0oUFghYOp89baYFBTGxUkC7Z), with code samples in [this github repo.](https://github.com/luisquintanilla/fsharp-101-samples)\r\n    - [Self-guided F# tutorials](https://docs.microsoft.com/en-us/learn/paths/fsharp-first-steps/)\r\n    - The [What is F#?](https://docs.microsoft.com/en-us/dotnet/fsharp/what-is-fsharp?) page.\r\n2. Exorcism.org is a great site for learning languages. This [link](https://exercism.org/tracks/fsharp) takes you to the F# learning track.\r\n3. [F# Syntax Cheatsheet.](https://github.com/adelarsq/fsharp-cheatsheet)\r\n4. [Official F# Language Guide.](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/)\r\n5. [F# for Fun and Profit](https://fsharpforfunandprofit.com/) has many great articles on F# and domain modelling with types. "},{"uri":"/Teaching/Momentum-Class.html","title":"Price momentum\r\n","content":"// Last updated 2021-04-29 09:00\n#time \u0022on\u0022\n\n#r \u0022nuget: FSharp.Data\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: NodaTime\u0022\n\n#load \u0022Portfolio.fsx\u0022\n\nopen System\nopen FSharp.Data\nopen NodaTime\nopen FSharp.Stats\n\nopen Portfolio\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\n\nlet samplePeriod x = \n    x \u003E= YearMonth(2010, 1) \u0026\u0026\n    x \u003C= YearMonth(2020, 2)\n\n(**\n# Price momentum\nPrice momentum is one of the most common quant signals. It is (fairly)\nstraight forward to calculate, and you only need returns to do it,\nso it is a good starting point and reference \u0027strategy\u0027.\n*)\n\n// Now create a type that represents the file.\n// This figures out what the columns of the file are.\n//  - Sample is the path to our file. The \u0022../\u0022 means we\u0027re\n//    doing relative paths, so we need to specify the \n//  - ResolutionFolder to indicate what folder the relative paths\n//    are relative to.\nlet [\u003CLiteral\u003E] ResolutionFolder = __SOURCE_DIRECTORY__\ntype MsfCsv = CsvProvider\u003CSample=\u0022.data/msf-momentum.csv\u0022,\n                          ResolutionFolder = ResolutionFolder\u003E\n\n// assign the content of the file to a value\nlet msfCsv = MsfCsv.GetSample()\n\n// look at the file attributes\nmsfCsv\n// look at the headers\nmsfCsv.Headers\n// look at the first few rows\nmsfCsv.Rows |\u003E Seq.truncate 3\n\n(**\n## Signal construction\nWe want to create a momentum signal and see how it relates to future returns.\nThe signal is some measure of past returns. A common measure is the past year return,\nskipping the most recent month. We skip the most recent month because stocks tend\nto reverse following very recent returns (known as \u0022reversals\u0022). \nThe reversal is very likely a liquidity effect and it is less important this century.\nSo returns are positively correlated with returns from 12 months to 1 months ago, \nbut negatively correlated with returns last month. This is illustrated very nicely\nin Jegadeesh (1990).\n\nIf we\u0027re forming a portfolio at the end of month $t-1$ to hold in month $t$, \nthen we\u0027re saying returns in month $t$ are positively correlated\nwith returns in months $t-12$ through month $t-2$.\nFor example, if we want to hold a momenum portfolio in January 2021, \nthen we will form it on December 31, 2020.\nWe will want to go long stocks that had high returns from the beginning \nof January 2020 to the end of November 2020.\n\nLet\u0027s create a record to hold some info about past returns for a stock.\nWe will use this as a trading signal.\n*)\n\ntype PriorReturnOb = \n    { SecurityId : SecurityId\n      FormationMonth : YearMonth \n      Retm12m2 : float\n      N : int }\n\n(**\nNote the \u0060YearMonth\u0060 type for portfolio formation month.\nThis type is from the library [NodaTime](https://nodatime.org/). \n\nWhy are we using it? Date math is hard and easy to mess up.\n\nWe\u0027re dealing with monthly data.\nIf we use \u0060DateTime\u0060, then we have to give the month a \nday value. We could always use the first day of the month,\nbut then month return goes all the way to the end of the month.\nAnd we might forget that information. \n\nIf we use the last day of the month,\nthen what happens when we add months. For example,\nwe have to start doing things like.\n*)\n\nlet endOfFebruary = DateTime(2020,2,28)\nlet endOfFebruaryPlus1Month = endOfFebruary.AddMonths(1)\nlet endOfMarch = DateTime(endOfFebruary.Year,endOfFebruary.Month,1).AddMonths(2).AddDays(-1.0)\nendOfFebruaryPlus1Month = endOfMarch // evaluates to false\n\n(**\nThat\u0027s kind of ugly. \n\nWe also have to worry about things like what happens\nif we add a month but it overlapped with daylight savings time?\nWhat about timezones? If we\u0027re never dealing with times,\nit\u0027s nice to ignore all these things.\n\nThis is nicer way of doing it using nodatime\u0027s \u0060YearMonth\u0060:\n*)\n\nlet february = YearMonth(2020,2) \nlet februaryPlus1Month = february.PlusMonths(1)\nlet march = YearMonth(2020,3)\nfebruaryPlus1Month = march // true\n\n(**\nLet\u0027s focus on a single stock.\n*)\n\nlet amznReturns = \n    // we\u0027re filtering and then storing as a map.\n    // if we used a sequence instead of a map/arra/list, then\n    // every time we used amznReturns, the sequence\n    // would be recreated by filtering msfCsv.Rows.\n    // That\u0027s one difference between (lazy) seq and\n    // (eager) array/list/map.\n    msfCsv.Rows\n    |\u003E Seq.filter(fun x -\u003E x.Ticker = \u0022AMZN\u0022)\n    |\u003E Seq.map(fun x -\u003E\n        let ym = YearMonth(x.Month.Year,x.Month.Month) \n        let key = Permno x.Permno, ym\n        key, x)\n    |\u003E Map.ofSeq\n\nlet getPastYearObs \n    (returns:Map\u003C(SecurityId * YearMonth),MsfCsv.Row\u003E)\n    (security: SecurityId, formationMonth: YearMonth) =\n        [ -11 .. -1 ]\n        |\u003E List.choose(fun i -\u003E \n            let returnMonth = formationMonth.PlusMonths(i)\n            Map.tryFind (security, returnMonth) returns)    \n\n// check Permno 84788 is Amzn\nlet amznPermno = Permno 84788\ngetPastYearObs amznReturns (amznPermno, YearMonth(2019,1))  \ngetPastYearObs amznReturns (Permno -400, YearMonth(2019,1))  \n\n// making cumulative returns \nlet cumulativeReturn rets =\n    // using Seq so that it will work with any collection\n    let cumulativeLogReturn =\n        rets |\u003E Seq.sumBy (fun r -\u003E log (1.0 \u002B r))\n    exp(cumulativeLogReturn) - 1.0\n\n(** check *)\ncumulativeReturn []\ncumulativeReturn [1.0;-0.5]\n\n(** check *)\ncumulativeReturn [0.1; 0.1; 0.1; 0.1]\n\n1.1 ** 4.0 - 1.0\n\n(**\nWe\u0027re now ready to create our Momentum signal function.\n*)\n\n// If you don\u0027t want to write the typessecurity, month all the time.\n// \n\nlet getMomentumSignal returns (security, formationMonth) =\n    let priorObs = getPastYearObs  returns (security, formationMonth)\n    let priorRets = priorObs |\u003E List.choose(fun x -\u003E x.Ret)\n    // We should probably return None if there are no observations.\n    // If they are all missing, Array.choose will return an empty\n    // array. See:\n    // ([| None; None |]: int option []) |\u003E Array.choose id\n    //\n    // So we\u0027ll check for an empty array and return None in that case.\n    if List.isEmpty priorRets then\n        None \n    else\n        Some { SecurityId = security \n               FormationMonth = formationMonth\n               Retm12m2 = cumulativeReturn priorRets\n               N = priorRets.Length }\n\n// Check\ngetMomentumSignal amznReturns (amznPermno, YearMonth(2019,1)) \ngetMomentumSignal amznReturns (Permno -400, YearMonth(2019,1))  \n\n(**\nOne thing you may notice is that our momentum signal function gets everything from\nit\u0027s inputs. That means that if we give it different intputs then\nwe could get momentum signals for other stocks. \n\nFor example we can create a map collection like we had for amzn, but for all stocks.\n*)\n\nlet msfByPermnoMonth =\n    msfCsv.Rows\n    |\u003E Seq.map(fun x -\u003E\n        let ym = YearMonth(x.Month.Year,x.Month.Month) \n        let key = Permno x.Permno, ym\n        key, x)\n    |\u003E Map.ofSeq\n\n// finding some permnos for notable tickers\n\n// don\u0027t use tickers. companies change tickers, so you might look up the wrong company\n// That\u0027s why I\u0027m picking some tickers that I know haven\u0027t changed, but my function\n// is using PERMNO.\n\nlet notableTicks =\n    [\u0022MSFT\u0022;\u0022AAPL\u0022;\u0022HOG\u0022]\n    |\u003E Seq.map(fun tick -\u003E \n        msfCsv.Rows\n        // hover over \u0027find\u0027 in \u0027Seq.find\u0027 if you don\u0027t remember what it does. \n        |\u003E Seq.find(fun row -\u003E row.Ticker = tick)\n        |\u003E fun row -\u003E row.Ticker, row.Permno)\n    |\u003E Map.ofSeq\n\nlet msftPermno = Permno notableTicks[\u0022MSFT\u0022]\nlet aaplPermno = Permno notableTicks[\u0022AAPL\u0022]\nlet hogPermno = Permno notableTicks[\u0022HOG\u0022]\n\nlet msftTestIndex = (msftPermno, YearMonth(2019,1))\nlet aaplTestIndex = (aaplPermno, YearMonth(2019,1))  \n\ngetMomentumSignal msfByPermnoMonth msftTestIndex \ngetMomentumSignal msfByPermnoMonth aaplTestIndex  \n\n(**\nand we can use [partial function application](https://fsharpforfunandprofit.com/posts/partial-application/)\nto \u0022bake in\u0022 the msfByPermnoMonth parameter so that we don\u0027t keep having to pass it around.\n*)\n\nlet getMomentumSignalAny = getMomentumSignal msfByPermnoMonth\n\ngetMomentumSignalAny msftTestIndex \ngetMomentumSignalAny aaplTestIndex  \n\n(**\n## Defining the investment universe\n\nLet\u0027s say we have a portfolio formation month. Can we look up securities available to invest in?\n\n*)\n\nlet securitiesByFormationMonth =\n    msfCsv.Rows\n    |\u003E Seq.groupBy(fun x -\u003E YearMonth(x.Month.Year, x.Month.Month))\n    |\u003E Seq.map(fun (ym, xs) -\u003E \n        ym, \n        xs \n        |\u003E Seq.map(fun x -\u003E Permno x.Permno) \n        |\u003E Seq.toList)\n    |\u003E Map.ofSeq\n\nlet getInvestmentUniverse formationMonth =\n    match Map.tryFind formationMonth securitiesByFormationMonth with\n    | Some securities -\u003E \n        { FormationMonth = formationMonth \n          Securities = securities }\n    | None -\u003E failwith $\u0022{formationMonth} is not in the date range\u0022      \n\ngetInvestmentUniverse (YearMonth(2011,10))\n// getInvestmentUniverse (YearMonth(1990,10))\n\n(**\nYou might also want to filter the investment universe by some criteria.\n*)\n\n\nlet isCommonStock securityFormationMonth =\n    match Map.tryFind securityFormationMonth msfByPermnoMonth with\n    | None -\u003E false\n    | Some x -\u003E List.contains x.Shrcd [10; 11]\n\nlet onNyseNasdaqAmex securityFormationMonth =\n    match Map.tryFind securityFormationMonth msfByPermnoMonth with\n    | None -\u003E false\n    | Some x -\u003E List.contains x.Exchcd [ 1; 2; 3]\n\nlet hasPrice13mAgo (security, formationMonth:YearMonth) =\n    //13m before the holding month, 12m before the formation month\n    match Map.tryFind (security, formationMonth.PlusMonths(-12)) msfByPermnoMonth with\n    | None -\u003E false\n    | Some m13 -\u003E m13.Prc.IsSome\n\nlet hasReturn2mAgo (security, formationMonth:YearMonth) =\n    //2m before the holding month, 1m before the formation month\n    match Map.tryFind (security, formationMonth.PlusMonths(-1)) msfByPermnoMonth with\n    | None -\u003E false\n    | Some m2 -\u003E m2.Ret.IsSome\n\nlet hasMe1mAgo (security, formationMonth) =\n    //1m before the holding month, so the formation month\n    match Map.tryFind (security, formationMonth) msfByPermnoMonth with\n    | None -\u003E false\n    | Some m1 -\u003E m1.Prc.IsSome \u0026\u0026 m1.Shrout.IsSome\n\nlet has8ReturnsPastYear securityFormationMonth =\n    match getMomentumSignalAny securityFormationMonth with \n    | None -\u003E false \n    | Some x -\u003E x.N \u003E= 8\n\nlet danielMoskowitzRestrictions securityFormationMonth =\n    isCommonStock securityFormationMonth \u0026\u0026\n    onNyseNasdaqAmex securityFormationMonth \u0026\u0026\n    hasPrice13mAgo securityFormationMonth \u0026\u0026\n    hasReturn2mAgo securityFormationMonth \u0026\u0026\n    hasMe1mAgo securityFormationMonth \u0026\u0026\n    has8ReturnsPastYear securityFormationMonth \n\nlet restrictUniverse (investmentUniverse: InvestmentUniverse) =\n    let filtered =\n        investmentUniverse.Securities\n        |\u003E List.filter(fun security -\u003E \n            danielMoskowitzRestrictions (security, investmentUniverse.FormationMonth))\n    { FormationMonth = investmentUniverse.FormationMonth\n      Securities = filtered }        \n\n(**\nNow we can see where we are.\n*)\n\nYearMonth(2011,10)\n|\u003E getInvestmentUniverse\n|\u003E restrictUniverse\n\nlet investmentUniverse =\n    YearMonth(2011,10)\n    |\u003E getInvestmentUniverse\nlet restrictedInvestmentUniverse =\n    investmentUniverse |\u003E restrictUniverse\n\n// See if we\u0027re excluding some securities.\ninvestmentUniverse.Securities.Length\nrestrictedInvestmentUniverse.Securities.Length\n\n(**\n## Momentum signals for our investment universe\nLet\u0027s look at how to transform our array of securities in our investment\nuniverse into an array with the signals.\n\nRecall that our momentum function returns a type of observation specific to momentum.\n*)\n\ngetMomentumSignalAny (Permno 84788, YearMonth(2019,1)) \n(*** include-fsi-output ***)\n\n(**\nThis is fine, but if we want our code to work with any type of signal,\nthen we need to transform it into something more generic.\n\nThis is the purpose of the \u0060SecuritySignal\u0060 record in the \u0060Portfolio\u0060 module.\nIt\u0027s the same thing that we had in the simpler portfolio formation example.\nIt can represent any signal that is a float.\nAnd to hold an array of security signals for a particular month,\nwe now have the type \u0060SecuritiesWithSignals\u0060 also from the \u0060Portfolio\u0060 module.\n\nLet\u0027s write a function that transforms our momentum signal into a more generic\nsecurity signal.\n*)\n\nlet getMomentumSecuritySignal (security, formationMonth ) =\n    match getMomentumSignalAny (security, formationMonth) with\n    | None -\u003E None\n    | Some signalOb -\u003E\n        let signal = { SecurityId = security; Signal = signalOb.Retm12m2 }\n        Some signal\n\n(** Now compare *)\ngetMomentumSignalAny (Permno 84788, YearMonth(2019,1)) \n(*** include-fsi-output ***)\n\ngetMomentumSecuritySignal (Permno 84788, YearMonth(2019,1)) \n(*** include-fsi-output ***)\n\n(**\nNow a function that takes our investment universe and returns\nour securities with their (now more generic) signal.\n*)\n\nlet getMomentumSignals (investmentUniverse: InvestmentUniverse) =\n    let arrayOfSecuritySignals =\n        investmentUniverse.Securities\n        |\u003E List.choose(fun security -\u003E \n            getMomentumSecuritySignal (security, investmentUniverse.FormationMonth))    \n    \n    { FormationMonth = investmentUniverse.FormationMonth \n      Signals = arrayOfSecuritySignals }\n\nrestrictedInvestmentUniverse\n|\u003E getMomentumSignals\n\n\n// or, if we want to look at the full pipeline\nYearMonth(2015,7)\n|\u003E getInvestmentUniverse\n|\u003E restrictUniverse\n|\u003E getMomentumSignals\n\n\n(**\n## Assigning portfolios\nNow that we have the signals for our portfolio,\nwe can assign portfolios. For many strategies it\nis common to use decile sorts. This means that\nyou sort securities into 10 portfolios based on the signal.\nBut other numbers of portfolios (tercile = 3, quintile = 5, etc)\nare also common.\n\nThere\u0027s a tradeoff between signal strength and diversification.\nMore portfolios means that top/bottom portfolios are stronger bets\non the signal. But there are fewer securities,\nso they are also less diversified. Often, the trade-off between\na stronger signal vs. less diversificaton balances out.\nSpecifically, long-short tercile sorts may have a lower return spread\nthan decile sorts. But since terciles are better diversified,\nthe tercile and decile shorts are not as different when looking \nat sharpe ratios.\n\nThe \u0060Portfolio\u0060 module has a function named \u0060assignSignalSorts\u0060\nto form portfolios by sorting securities into \u0060n\u0060 groups.\n*)\n\nYearMonth(2015,7)\n|\u003E getInvestmentUniverse\n|\u003E restrictUniverse\n|\u003E getMomentumSignals\n|\u003E assignSignalSort \u0022Momentum\u0022 10\n\n(**\n## Calculating Portfolio weights\n\nWe\u0027ll use a value-weight scheme. So we need a function that gets market capitalizations.\n\n*)\n\nlet getMarketCap (security, formationMonth) =\n    match Map.tryFind (security, formationMonth) msfByPermnoMonth with\n    | None -\u003E None\n    | Some x -\u003E \n        match x.Prc, x.Shrout with \n        // we need valid price and valid shrout to get market caps\n        | Some prc, Some shrout -\u003E Some (security, prc*shrout)\n        // anything else and we can\u0027t calculate it\n        | _ -\u003E None\n\n(**\nSome examples.\n*)\n\ngetMarketCap (amznPermno, YearMonth(2019,1)) // Some marketCap\ngetMarketCap (amznPermno, YearMonth(2030,1)) // In the future, so None\n\nlet exampleCapitalizations =\n    [| getMarketCap (amznPermno, YearMonth(2019,1))\n       getMarketCap (hogPermno, YearMonth(2019,1)) |]\n    |\u003E Array.choose id // to unwrap the options\n\nlet exampleValueWeights =\n    let tot = exampleCapitalizations |\u003E Array.sumBy snd\n    exampleCapitalizations\n    |\u003E Array.map(fun (_id, cap) -\u003E cap / tot )\n    |\u003E Array.sortDescending\n(*** include-fsi-output ***)\n\n(**\nNow imagining we have the same example in terms of an assigned portfolio\nwith made up signals.\n*)\n\nlet mktCapExPort: AssignedPortfolio =\n    { PortfolioId = Named(\u0022Mkt Cap Example\u0022)\n      FormationMonth = YearMonth(2019,1)\n      Signals = [ { SecurityId = amznPermno; Signal = 1.0 }\n                  { SecurityId = hogPermno; Signal = 1.0 } ] }\n\n(**\nThe portfolio module has a function that can help us.\nIt has two inputs.\n\n- A function that gets market capitalizations\n- An assigned portfolio\n\nWe should see that it gives the same value weights.\n*)                  \n\nlet exampleValueWeights2 =\n    giveValueWeights getMarketCap mktCapExPort\n\n(*** include-fsi-output ***)\n\n(**\nSo now we can construct our portfolios with value weights.\n*)\n\nlet portfoliosWithWeights =\n    YearMonth(2015,7)\n    |\u003E getInvestmentUniverse\n    |\u003E restrictUniverse\n    |\u003E getMomentumSignals\n    |\u003E assignSignalSort \u0022Momentum\u0022 10\n    |\u003E List.map (giveValueWeights getMarketCap)\n\n(**\nNote that because of the size distribution,\nsome of these portfolios are not very diversified.\nThis is illustrated by inspecting maximum portfolio\nweights.\n*)\nportfoliosWithWeights\n|\u003E List.map(fun port -\u003E \n    port.PortfolioId,\n    port.Positions |\u003E List.map(fun pos -\u003E pos.Weight) |\u003E List.max,\n    port.Positions |\u003E List.sumBy(fun pos -\u003E pos.Weight))\n\n\n(**\n## Calculating Portfolio returns\n\nWe need our function to get returns given weights.\n\nWe can start with a function that gets returns.\nIt looks a lot like our function to get market capitalizations.\n\n*)\n\nlet getSecurityReturn (security, formationMonth) =\n    // If the security has a missing return, assume that we got 0.0.\n    // Note: If we were doing excess returns, we\u0027d need 0.0 - rf\n    let missingReturn = 0.0\n    match Map.tryFind (security, formationMonth) msfByPermnoMonth with\n    | None -\u003E security, missingReturn\n    | Some x -\u003E  \n        match x.Ret with \n        | None -\u003E security, missingReturn\n        | Some r -\u003E security, r\n\ngetSecurityReturn (amznPermno, YearMonth(2019,1))        \n\nlet portReturn =\n    getPortfolioReturn getSecurityReturn exampleValueWeights2\n\nportfoliosWithWeights\n|\u003E List.map (getPortfolioReturn getSecurityReturn)    \n\n\n// Put it all together.\nlet sampleMonths = getSampleMonths (YearMonth(2010,5), YearMonth(2020,2)) \n\nsampleMonths |\u003E List.rev |\u003E List.take 3\n\nlet formMomtenumPort ym =\n    ym\n    |\u003E getInvestmentUniverse\n    |\u003E restrictUniverse\n    |\u003E getMomentumSignals\n    |\u003E assignSignalSort \u0022Momentum\u0022 10\n    |\u003E List.map (giveValueWeights getMarketCap)\n    |\u003E List.map (getPortfolioReturn getSecurityReturn)  \n\n\n(**\nWe can process months sequentially.\n*)\n(*** do-not-eval ***)\nlet momentumPortsSequential =\n    sampleMonths\n    |\u003E List.collect formMomtenumPort \n\n(**\nOr we can speed things up and process months in Parallel using\nall available CPU cores. Note that the only changes are to \n\n1. Use \u0060Array.Parallel.collect\u0060 intead of \n\u0060List.collect\u0060. The array collection is the only parallel \ncollection in base F# and the module functions are somewhat limited, \nbut if you google F# parallel processing\nyou can find other options and also asynchronous coding and PSeq \n(I mostly use PSeq for my parallel code).\n2. \u0060Array.Parallel.collect\u0060 expects to operate on arrays, so \nwe need to mhave our portfolio returned as arrays instead of lists.\nThis is what we are doing with \u0060formMomentumPortArray\u0060.\n*)\n\nlet formMomentumPortArray ym =\n    ym \n    |\u003E formMomtenumPort \n    |\u003E List.toArray\n\nlet momentumPortsParallel =\n    sampleMonths\n    |\u003E List.toArray\n    |\u003E Array.Parallel.collect formMomentumPortArray \n\n"},{"uri":"/Teaching/portfolio-returns.html","title":"Portfolio Returns","content":"(**\n\n---\ntitle: Portfolio Returns\ncategory: Lectures\ncategoryindex: 1\nindex: 3\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n## A portfolio\u0027s return.\n\nA portfolio\u0027s return is the weighted average return of the portfolio\u0027s positions.\n\n$$ r_p = \\Sigma^N_{i=1} w_i r_i,$$\nwhere $r$ is return, $i$ indexes stocks, and $w$ is portfolio weights.\n*)\n\ntype PositionsWithReturn =\n    { Id: string \n      Weight: float \n      Return: float }\n\nlet exPortfolio =\n    [ { Id = \u0022A\u0022; Weight = 0.25; Return = 0.1 }\n      { Id = \u0022B\u0022; Weight = 0.75; Return = 0.2 } ]\n\nlet weightsXreturn = [ for pos in exPortfolio -\u003E pos.Weight * pos.Return ]\nweightsXreturn\n(***include-value:weightsXreturn***)\n\nlet exPortfolioReturn = weightsXreturn |\u003E List.sum \nexPortfolioReturn\n(***include-value: exPortfolioReturn***)\n\n\n(**\nWe are now going to look at returns of actual stock and bond portfolios.\nThe two portfolios are [VTI](https://investor.vanguard.com/etf/profile/VTI) and\n[BND](https://investor.vanguard.com/etf/profile/BND). \nThese are value-weighted exchange traded funds (ETFs).\nVTI tracks a stock market index and BND tracks a bond market index.\nThey are good proxies for the return of the overall US stock and bond markets.\n\nWe are going to load some helper code that allows us to download and plot this data.\nThis will introduce using \u0060#load\u0060 to load scripts with external code,\nthe \u0060nuget\u0060 package manager for loading external libraries,\nand how to open namespaces.\n\nWhen you type \u0060#load \u0022Script.fsx\u0022\u0060 in the REPL,\nF# interactive compiles the code in \u0060Script.fsx\u0060 and puts it into\na code module with the same name as the script.\n\nWe are going to use a helper script called \u0060YahooFinance.fsx\u0060 that includes\ncode for requesting price histories from yahoo. To download it,\ngo to the [YahooFinance](YahooFinance.html) page and click the \u0022download script\u0022\nbutton at the top. Make sure that you have saved it in \nthe same directory as this file.\n\nIf you have downloaded it correctly then the following code will evaluate to \u0060true\u0060.\n*)\n\nSystem.IO.File.Exists(\u0022YahooFinance.fsx\u0022)\n(***include-it***)\n\n(**\nAssuming that the above code evaluated to \u0060true\u0060 we can now load it into our session.\n*)\n\n#load \u0022YahooFinance.fsx\u0022\n\n(**\nNamespaces are a hierarchical way of organizing code.\nIn the above checking for the existence of a file we have a hierarchy of\n\u0060System.IO\u0060 where the period \u0060.\u0060 separates the \u0060System\u0060 and \u0060IO\u0060 namespaces.\nIf we \u0060open\u0060 a namespace, then we have access to the code inside the namespace directly.\n\nIt is common to open the \u0060System\u0060 namespace.\n*)\n\nopen System\n\n(**\nNow we can leave \u0060System\u0060 off when accessing code in the \u0060System\u0060 namespace.\n*)\n\nIO.File.Exists(\u0022YahooFinance.fsx\u0022)\n(***include-it***)\n\n(**\nWe also want to open the \u0060YahooFinance\u0060 module from \u0060YahooFinance.fsx\u0060,\nwhich is similar to a namespace.\n*)\n\nopen YahooFinance\n\n(**\nWe are ready to request some data. Let\u0027s define our start and end dates.\n\u0060DateTime\u0060 is a type in the \u0060System\u0060 namespace.\nWe have opened that namespace so we can access the type directly.\n*)\n\nlet myStart = DateTime(2010,1,1)\nlet myEnd = DateTime.UtcNow\nmyEnd\n(***include-it***)\n\n(**\nOur \u0060YahooFinance\u0060 module has code for requesting price histories of stocks.\n*)\n\nlet bnd = YahooFinance.PriceHistory(\u0022BND\u0022,startDate=myStart,endDate=myEnd,interval = Interval.Daily)\nlet vti = YahooFinance.PriceHistory(\u0022VTI\u0022,startDate=myStart,endDate=myEnd,interval = Interval.Daily)\n\n(**\nThis returns several data items for each point in time.\n*)\n\n(***do-not-eval***)\nvti[0..3]\n(***hide***)\nvti.[0..3]\n(***include-it***)\n\n(**\nThe adjusted close is adjusted for stock splits and dividends.\nThis adjustment is done so that you can calculate returns from the price changes.\n\nLet\u0027s see what it looks like to plot it. \nWe\u0027re going to use the [plotly.NET](https://plotly.net) library for this.\nWe download the code from the [nuget.org](http://www.nuget.org) package manager.\n\nThis is equivalent to loading libraries with \u0060pip\u0060 or \u0060conda\u0060 in python\nor \u0060install.packages\u0060 in R.\n\n*)\n\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.17\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.17\u0022\n\n\nopen Plotly.NET\n\n(**\nAbove we are loading an exact version by using a \u0022,\u0022 and version number.\n\nPlot prices as a line chart.\n*)\n\nlet vtiAdjPrices = [ for period in vti -\u003E period.Date, period.AdjustedClose ]\n\n(***do-not-eval***)\nChart.Line(vtiAdjPrices)\n(***hide***)\nChart.Line(vtiAdjPrices)\n|\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nOk, back to the main objective. We need to calculate returns.\nWe calculate returns from sequential days,\nso we need to make sure that our data is sorted correctly\nfrom the oldest to the newest data. We can do this with \u0060List.Sort\u0060.\n\n*)\n\n[1; 7; 10; 2; -1] |\u003E List.sort\n(***include-it***)\n\n(** Sort it by the date field. *)\nlet sortedBnd = bnd |\u003E List.sortBy (fun x -\u003E x.Date)\n\n(** The first three observations. *)\n(***do-not-eval***)\nsortedBnd[0..2]\n(***hide***)\nsortedBnd.[0..2]\n(***include-it***)\n\n(** The last 3 observations. *)\n(***do-not-eval***)\nsortedBnd[(sortedBnd.Length-3)..]\n(***hide***)\nsortedBnd.[(sortedBnd.Length-3)..]\n(***include-it***)\n\n(** \nGreat, they are properly sorted. Now I want sequential pairs of data.\n\u0060List.pairwise\u0060 is good for this.\n*)\n\n[1 .. 5] |\u003E List.pairwise\n(***include-it***)\n\nlet sequentialBnd = bnd |\u003E List.pairwise\n(***do-not-eval***)\nsequentialBnd[0]\n(***hide***)\nsequentialBnd.[0]\n(***include-it***)\n(***do-not-eval***)\nsequentialBnd[1]\n(***hide***)\nsequentialBnd.[1]\n(***include-it***)\n\n(**\nTake the first pair to see how to calculate returns.\n\nExtract the first and second elements of the tuple using pattern matching. *)\n\n(***do-not-eval***)\nlet (bndA, bndB) = sequentialBnd[0]\nbndA\n(***hide***)\nlet (bndA\u0027, bndB\u0027) = sequentialBnd.[0]\nbndA\u0027\n(***include-it***)\n(***do-not-eval***)\nbndB\n(***hide***)\nbndB\u0027\n(***include-it***)\n\n(**\nRemember that with continuous compounding, $FV_T = PV_t \\times e^{r}$\nwhere $FV$ is the future value, $PV$ is the present value, $r$ is return\nbetween period $t$ and $T$.\n\nIf we take the log of both sides of the equation, we get\n\n$$ log(FV) = log(PV) \u002B r \\rightarrow log(FV) - log (PV) = r$$\n\nThis $r$ is known as the log return. \nSo to find the log return between two periods we can take the \ndifference of the log prices (where the prices are adjusted for dividends).\n\n*)\n(log bndB.AdjustedClose) - (log bndA.AdjustedClose)\n(***include-it***)\n\n\n(**\nPutting it all together.\n*)\nlet bndReturn = \n    bnd\n    |\u003E List.sortBy (fun x -\u003E x.Date)\n    |\u003E List.pairwise\n    |\u003E List.map (fun (a, b) -\u003E (log b.AdjustedClose) - (log a.AdjustedClose))\n\nlet vtiReturn =\n    vti\n    |\u003E List.sortBy (fun x -\u003E x.Date)\n    |\u003E List.pairwise\n    |\u003E List.map (fun (a, b) -\u003E (log b.AdjustedClose) - (log a.AdjustedClose))\n\n\nlet bndAvgReturn = bndReturn |\u003E List.average\nbndAvgReturn\n(***include-it***)\n\nlet vtiAvgReturn = vtiReturn |\u003E List.average\nvtiAvgReturn\n(***include-it***)\n\n(*** Portfolio returns for different weights. *)\n\nlet differentReturns =\n  [ for w in [0.0 .. 0.2 .. 1.0] -\u003E w, w*bndAvgReturn \u002B (1.0-w)*vtiAvgReturn ]\n\ndifferentReturns\n(***include-it***)\n\nChart.Line(differentReturns)"},{"uri":"/Teaching/portfolio-statistics.html","title":"Basic Portfolio Statistics","content":"(**\n\n---\ntitle: Basic Portfolio Statistics\ncategory: Lectures\ncategoryindex: 1\nindex: 2\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\nThis page covers important fundamentals for building portfolios.\n\n- [Portfolio Weights](#Portfolio-Weights)\n- [Mean and Variance of Portfolio Returns](#Mean-and-Variance-of-Portfolio-Returns) \n- [Leverage](#Leverage)\n\n*)\n\n(**\n## Portfolio Weights\n\nAn investment portfolio consists of positions in assets. \nIt is common to refer to a position\u0027s size as its share of\nthe portfolio\u0027s total value. \nThis is known as the asset\u0027s portfolio weight.\n\nThe portfolio weight of asset $i$ in portfolio $p$ is\n\n$$w_i=(\\text{positionValue}_i)/(\\text{portfolioValue}_p)$$\n\n### Long positions\n\nWhen an investor buys a long position, \nthey pay for the position now and hope to sell it later at a higher price.\n\nLet\u0027s look at cash flows for long positions.\n\n- At time 0: investor has \\$100 cash and no shares.\n- At time 1: investor takes their \\$100 of cash and buys 4 shares \n  of stock at a price of \\$25 per share. They have no cash and are long 4 shares.\n- At time 2: the stock has risen to \\$27, the investor sells their 4 shares.\n  They have \\$108 of cash and no shares.\n\nWe can define some functions to update an account given these trades.\n*)\n\n// A record type that defines an account\ntype AccountBalances =\n    { Time: int\n      Cash: float \n      Shares: float }\n\n// A record type that defines a trade\ntype Trade = \n    { Shares: float \n      Price : float }\n\nlet accountAt0 = { Time = 0; Cash = 100.0; Shares = 0.0 }\nlet tradeAt1 = { Shares = 4.0; Price = 25.0 }\n\n// \u0060updateAccount\u0060 is a function that updates an account after a trade is made.\n// \n// (trade: Trade) restricts the \u0060trade\u0060 parameter to data of type \u0060Trade\u0060.\n//\n// (inAccount: AccountBalances) restricts the \u0060inAccount\u0060 parameter \n// to data of type \u0060AccountBalances\u0060\n//\nlet updateAccount (trade: Trade) (inAccount: AccountBalances) =\n    let tradeValue = trade.Price * trade.Shares\n    let newCash = inAccount.Cash - tradeValue\n    let newShares = inAccount.Shares \u002B trade.Shares\n    let newTime = inAccount.Time \u002B 1\n    { Time = newTime \n      Cash = newCash \n      Shares = newShares }\n\n(** \nYou can make names with spaces using \u0022\u0060\u0060\u0022 before and after.\n*)\nlet \u0060\u0060expected account at t1\u0060\u0060 = { Time = 1; Cash = 0.0; Shares = 4.0}\nlet \u0060\u0060actual account at t1\u0060\u0060 = updateAccount tradeAt1 accountAt0 \n\n\u0060\u0060actual account at t1\u0060\u0060\n(***include-it***)\n\n\nif \u0060\u0060actual account at t1\u0060\u0060 \u003C\u003E \u0060\u0060expected account at t1\u0060\u0060 then\n    failwith \u0022You are not updating account correctly after a trade\u0022\n\n(**\nNow we can calculate how the account value changes over time.\n*)\n\nlet accountAt1 = updateAccount tradeAt1 accountAt0\n\naccountAt1\n(***include-it***)\n\nlet tradeAt2 = { Shares = -4.0; Price = 27.0 }\nlet accountAt2 = updateAccount tradeAt2 accountAt1\n\naccountAt2\n(***include-it***)\n\n(**\nWe could have also written this code using the pipe operator.\n*)\n\nlet accountAt1\u0027 = accountAt0 |\u003E updateAccount tradeAt1 // same as \u0022updateAccount tradeAt1 accountAt0\u0022\nlet accountAt2\u0027 = accountAt1 |\u003E updateAccount tradeAt2 // same as \u0022updateAccount tradeAt2 accountAt1\u0022\n\naccountAt1\u0027\n(***include-it***)\naccountAt2\u0027\n(***include-it***)\n\n(**\nThe pipe operator does not look very useful above because \nwe are only doing one operation.\nIt is more useful when you\u0027re doing a series of multiple operations.\nThis example recomputes the account value at time 2 by\nchaining together updates for the trades at times 1 and 2.\n\n*)\n\nlet accountAt2\u0027\u0027 =\n    accountAt0\n    |\u003E updateAccount tradeAt1\n    |\u003E updateAccount tradeAt2\n\naccountAt2\u0027\u0027\n(***include-it***)\n\n(**\nThis code is closer to how you would describe it in English:\n\u0022Start with the account at time 0, \nupdate it for the trade at time 1,\nthen update it for the trade at time 2.\u0022\n*)\n\n(**\n\u003E Practice: complete the code for the \u0060accountValue\u0060 function below.\nIt should calculate total account value of\nthe stock and cash positiions. \nIf it is correct then the account value test below should evaluate to \u0060true\u0060\n*)\n\nlet accountValue (stockPrice: float) (account: AccountBalances) =\n    failwith \u0022unimplemented\u0022\n\n(***do-not-eval***)\n// simple account value test\n(accountValue 27.0 accountAt2) = 108.0\n\n(**\n### Portfolio weights of long positions\n\nNow that we understand long positions we can calculate portfolio weights for them.\nLet\u0027s calculate weights for an example *Portfolio A* consisting of\n\n- \\$100 invested in AAPL\n- \\$300 invested in GOOG\n- \\$500 invested in TSLA\n\nThese are all long positions, meaning that they have positive costs. \n*)\n\nlet aaplPositionValue = 100.0\nlet googPositionValue = 300.0\nlet tslaPositionValue = 500.0\n\n// This implies:\n\nlet portfolioValueA = aaplPositionValue \u002B googPositionValue \u002B tslaPositionValue\n\nportfolioValueA\n(***include-it***)\n\n(**\nThe portfolio weights are then\n*)\n\nlet aaplWeight = aaplPositionValue / portfolioValueA\n\naaplWeight\n(***include-it***)\n\nlet googWeight = googPositionValue / portfolioValueA\n\ngoogWeight\n(***include-it***)\n\nlet tslaWeight = tslaPositionValue / portfolioValueA\n\ntslaWeight\n(***include-it***)\n\n(**\nThese weights for AAPL, GOOG, and TSLA are all positive.\nLong positions always have positive weights.\n\nAnother thing to notice is that the portfolio weights add up to one (or 100%):\n*)\n\naaplWeight \u002B googWeight \u002B tslaWeight\n(***include-fsi-output***)\n\n(**\nThis portfolio is a net long portfolio, \nmeaning that it costs you money to purchase it. \nNet long portfolios such as this one must \nhave portfolio weights that add up to one.\nDue to margin requirements, real-world\nportfolios are generally net long--you must\nput up capital to acquire the portfolio.\n\nThe other type of portfolio is a zero-cost portfolio. \nAs the name implies, zero-cost portfolios do not require any investment to purchase.\nThere is no cost because long positions are funded by offsetting short positions.\nTo see how this works we need to examine how short positions work.\n\n### Short positions\n\nWhen an investor buys a long position, \nthey pay for the position now and hope to sell it later at a higher price.\nA short sale reverses this.\nThe investor sells the position now and hopes to buy it back later at a lower price.\n\nWe now go through an example to see how the cash flows work.\n\n- At time 0: investor has \\$100 cash and no shares.\n- At time 1: investor borrows 4 shares of stock and sells them\n  for a price of \\$25 per share. They have \\$200 cash and are short 4 shares.\n- At time 2: the stock has risen to \\$27, the investor buys back the\n  4 shares that they sold short and returns them to the person that\n  they borrowed them from. They have $92 of cash and 0 shares.\n\nThe investor\u0027s cash and stock balances at the end of each period will look something like \n\n*)\n\nlet shortAt1 = { Shares = -4.0; Price = 25.0 }\nlet shortCoverAt2 = { Shares = 4.0; Price = 27.0 }\n\n// positions at t1\naccountAt0 \n|\u003E updateAccount shortAt1\n(***include-it***)\n\n// positions at t2\naccountAt0 \n|\u003E updateAccount shortAt1 \n|\u003E updateAccount shortCoverAt2\n(***include-it***)\n\n(**\n\n### Portfolio weights for short positions\n\nLet\u0027s create a new portfolio, *Portfolio B*, that includes short sales and calculate weights. Assume that you start with *Portfolio A* and short \\$150 of AMZN stock. This generates \\$150 of cash that you have to put somewhere. For individual investors, often your broker puts it in bonds and gives you none of the interest. Institutional investors can get some of the interest or even reinvest the proceeds in something else. We will assume that we are an institution and can reinvest all of the short proceeds. We will take the \\$150 and add \\$50 to each of our AAPL, GOOG, and TLSA positions. \n\nShort positions have negative portfolio weights.\n*)\n\nlet amznPositionValueB = -150.0\nlet aaplPositionValueB = aaplPositionValue \u002B 50.0\nlet googPositionValueB = googPositionValue \u002B 50.0\nlet tslaPositionValueB = tslaPositionValue \u002B 50.0\n\nlet portfolioValueB = \n    amznPositionValueB \u002B\n    aaplPositionValueB \u002B\n    googPositionValueB \u002B\n    tslaPositionValueB\n\nportfolioValueB\n(***include-it***)\n\n(** Compare to *Portfolio A* *)\nportfolioValueA = portfolioValueB \n(***include-fsi-output***)\n\n(**\nThe weights in *Portfolio B*:\n*)\n\nlet amznWeightB = amznPositionValueB / portfolioValueB\n\namznWeightB\n(***include-it***)\n\nlet aaplWeightB = aaplPositionValueB / portfolioValueB\n\naaplWeightB\n(***include-it***)\n\nlet googWeightB = googPositionValueB / portfolioValueB\n\ngoogWeightB\n(***include-it***)\n\nlet tslaWeightB = tslaPositionValueB / portfolioValueB\n\ntslaWeightB\n(***include-it***)\n\n(**\nThe weights of *Portfolio B* also add up to one.\n*)\n\namznWeightB \u002B aaplWeightB \u002B googWeightB \u002B tslaWeightB\n(***include-fsi-output***)\n\n(**\n### Zero-cost portfolios\n\nAnother type of portfolio that you will see is zero-cost portfolios.\nThey are called self funding because the short sale proceeds\nfund the long investments. The portfolio weights add up to 0.\nYou can scale weights relative to what they would be per \\$ long or short.\n\nAn example:\n*)\n\n// Portfolio C\nlet koPositionValue = -50.0\nlet hogPositionValue = 40.0\nlet yumPositionValue = 10.0\n\nlet dollarsLong = 50.0\nlet koWeight = koPositionValue / dollarsLong\nlet hogWeight = hogPositionValue / dollarsLong\nlet yumWeight = yumPositionValue / dollarsLong\n\nprintfn $\u0022koWeight = {koWeight}\u0022\nprintfn $\u0022hogWeight= {hogWeight}\u0022\nprintfn $\u0022yumWeight= {yumWeight}\u0022\n(***include-output***)\n\nkoWeight \u002B hogWeight \u002B yumWeight\n(***include-it***)\n\n(**\n### Calculating weights using a list of positions\n\nThe calculations that we did thus far required code for each position.\nWe did the same thing to each position, so there was some repetition.\nWe can reduce the repetition by putting the positions into a list\nand then operating on the elements of the list via iteration.\n*)\n\n// defining a position record type\ntype Position = { Id: string; PositionValue: float }\n\n// assigning a list of positions to a value named portfolio\nlet portfolio =\n    [ { Id = \u0022AMZN\u0022; PositionValue = amznPositionValueB }\n      { Id = \u0022AAPL\u0022; PositionValue = aaplPositionValueB }\n      { Id = \u0022GOOG\u0022; PositionValue = googPositionValueB }\n      { Id = \u0022TSLA\u0022; PositionValue = tslaPositionValueB } ]\n\n// This is called a list comprehension\nlet positionValues = [ for p in portfolio -\u003E p.PositionValue ]\n(***include-value:positionValues***)\n\n(**\nThe list module has many different functions for operating on lists. \nIf you type \u0060List.\u0060 you should see many different functions pop up.\nThese functions are very useful. We will explore them in more detail later.\n\nFor now, let\u0027s see what \u0060List.map\u0060 does.\n*)\n\nportfolio |\u003E List.map (fun p -\u003E p.PositionValue)\n(***include-fsi-output***)\n\n(**\nThis is the same result as the \u0060positionValues\u0060 value that we calculated\nusing the list comprehension. \n\u0060List.map\u0060 \u0022maps\u0022 each element of the list to an output using a function.\nIn this case, our function \u0060(fun p -\u003E p.PositionValue)\u0060 was an anonymous function.\n\nAnother useful function from the list module is \u0060List.sum\u0060.\nWe can use it to calculate the total value of the portfolio by\nsumming position values.\n*)\n\nlet portfolioValue = positionValues |\u003E List.sum\n(***include-value: portfolioValue***)\n\n(**\nAnd with this we can calculate portfolio weights.\n*)\nlet portfolioWeights =\n    [ for p in portfolio -\u003E \n        let weight = p.PositionValue / portfolioValue \n        p.Id, weight ]\nportfolioWeights\n(***include-value: portfolioWeights***)\n\n(**\n## Mean and Variance of Portfolio Returns\n\n### A portfolio\u0027s return.\n\nA portfolio\u0027s return is the weighted average return of the portfolio\u0027s positions.\n\n$$ r_p = \\Sigma^N_{i=1} w_i r_i,$$\nwhere $r$ is return, $i$ indexes stocks, and $w$ is portfolio weights.\n*)\n\ntype PositionsWithReturn =\n    { Id: string \n      Weight: float \n      Return: float }\n\nlet exPortfolio =\n    [ { Id = \u0022A\u0022; Weight = 0.25; Return = 0.1 }\n      { Id = \u0022B\u0022; Weight = 0.75; Return = 0.2 } ]\n\nlet weightsXreturn = [ for pos in exPortfolio -\u003E pos.Weight * pos.Return ]\nweightsXreturn\n(***include-value:weightsXreturn***)\n\nlet exPortfolioReturn = weightsXreturn |\u003E List.sum \nexPortfolioReturn\n(***include-value: exPortfolioReturn***)\n\n\n(**\nWe are now going to look at returns of actual stock and bond portfolios.\nThe two portfolios are [VTI](https://investor.vanguard.com/etf/profile/VTI) and\n[BND](https://investor.vanguard.com/etf/profile/BND). \nThese are value-weighted exchange traded funds (ETFs).\nVTI tracks a stock market index and BND tracks a bond market index.\nThey are good proxies for the return of the overall US stock and bond markets.\n\nWe are going to load some helper code that allows us to download and plot this data.\nThis will introduce using \u0060#load\u0060 to load scripts with external code,\nthe \u0060nuget\u0060 package manager for loading external libraries,\nand how to open namespaces.\n\nWhen you type \u0060#load \u0022Script.fsx\u0022\u0060 in the REPL,\nF# interactive compiles the code in \u0060Script.fsx\u0060 and puts it into\na code module with the same name as the script.\n\nWe are going to use a helper script called \u0060YahooFinance.fsx\u0060 that includes\ncode for requesting price histories from yahoo. To download it,\ngo to the [YahooFinance](YahooFinance.html) page and click the \u0022download script\u0022\nbutton at the top. Make sure that you have saved it in \nthe same directory as this file.\n\nIf you have downloaded it correctly then the following code will evaluate to \u0060true\u0060.\n*)\n\nSystem.IO.File.Exists(\u0022YahooFinance.fsx\u0022)\n(***include-it***)\n\n(**\nAssuming that the above code evaluated to \u0060true\u0060 we can now load it into our session.\n*)\n\n#load \u0022YahooFinance.fsx\u0022\n\n(**\nNamespaces are a hierarchical way of organizing code.\nIn the above checking for the existence of a file we have a hierarchy of\n\u0060System.IO\u0060 where the period \u0060.\u0060 separates the \u0060System\u0060 and \u0060IO\u0060 namespaces.\nIf we \u0060open\u0060 a namespace, then we have access to the code inside the namespace directly.\n\nIt is common to open the \u0060System\u0060 namespace.\n*)\n\nopen System\n\n(**\nNow we can leave \u0060System\u0060 off when accessing code in the \u0060System\u0060 namespace.\n*)\n\nIO.File.Exists(\u0022YahooFinance.fsx\u0022)\n(***include-it***)\n\n(**\nWe also want to open the \u0060YahooFinance\u0060 module from \u0060YahooFinance.fsx\u0060,\nwhich is similar to a namespace.\n*)\n\nopen YahooFinance\n\n(**\nWe are ready to request some data. Let\u0027s define our start and end dates.\n\u0060DateTime\u0060 is a type in the \u0060System\u0060 namespace.\nWe have opened that namespace so we can access the type directly.\n*)\n\nlet myStart = DateTime(2010,1,1)\nlet myEnd = DateTime.UtcNow\nmyEnd\n(***include-it***)\n\n(**\nOur \u0060YahooFinance\u0060 module has code for requesting price histories of stocks.\n*)\n\nlet bnd = YahooFinance.PriceHistory(\u0022BND\u0022,startDate=myStart,endDate=myEnd,interval = Interval.Daily)\nlet vti = YahooFinance.PriceHistory(\u0022VTI\u0022,startDate=myStart,endDate=myEnd,interval = Interval.Daily)\n\n(**\nThis returns several data items for each point in time.\n*)\n\n(***do-not-eval***)\nvti[0..3]\n(***hide***)\nvti.[0..3]\n(***include-it***)\n\n(**\nThe adjusted close is adjusted for stock splits and dividends.\nThis adjustment is done so that you can calculate returns from the price changes.\n\nLet\u0027s see what it looks like to plot it. \nWe\u0027re going to use the [plotly.NET](https://plotly.net) library for this.\nWe download the code from the [nuget.org](http://www.nuget.org) package manager.\n\nThis is equivalent to loading libraries with \u0060pip\u0060 or \u0060conda\u0060 in python\nor \u0060install.packages\u0060 in R.\n\n*)\n\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.17\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.17\u0022\n\n\nopen Plotly.NET\n\n(**\nAbove we are loading an exact version by using a \u0022,\u0022 and version number.\n\nPlot prices as a line chart.\n*)\n\nlet vtiAdjPrices = [ for period in vti -\u003E period.Date, period.AdjustedClose ]\n\n(***do-not-eval***)\nChart.Line(vtiAdjPrices)\n(***hide***)\nChart.Line(vtiAdjPrices)\n|\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nOk, back to the main objective. We need to calculate returns.\nWe calculate returns from sequential days,\nso we need to make sure that our data is sorted correctly\nfrom the oldest to the newest data. We can do this with \u0060List.Sort\u0060.\n\n*)\n\n[1; 7; 10; 2; -1] |\u003E List.sort\n(***include-it***)\n\n(** Sort it by the date field. *)\nlet sortedBnd = bnd |\u003E List.sortBy (fun x -\u003E x.Date)\n\n(** The first three observations. *)\n(***do-not-eval***)\nsortedBnd[0..2]\n(***hide***)\nsortedBnd.[0..2]\n(***include-it***)\n\n(** The last 3 observations. *)\n(***do-not-eval***)\nsortedBnd[(sortedBnd.Length-3)..]\n(***hide***)\nsortedBnd.[(sortedBnd.Length-3)..]\n(***include-it***)\n\n(** \nGreat, they are properly sorted. Now I want sequential pairs of data.\n\u0060List.pairwise\u0060 is good for this.\n*)\n\n[1 .. 5] |\u003E List.pairwise\n(***include-it***)\n\nlet sequentialBnd = bnd |\u003E List.pairwise\n(***do-not-eval***)\nsequentialBnd[0]\n(***hide***)\nsequentialBnd.[0]\n(***include-it***)\n(***do-not-eval***)\nsequentialBnd[1]\n(***hide***)\nsequentialBnd.[1]\n(***include-it***)\n\n(**\nTake the first pair to see how to calculate returns.\n\nExtract the first and second elements of the tuple using pattern matching. *)\n\n(***do-not-eval***)\nlet (bndA, bndB) = sequentialBnd[0]\nbndA\n(***hide***)\nlet (bndA\u0027, bndB\u0027) = sequentialBnd.[0]\nbndA\u0027\n(***include-it***)\n(***do-not-eval***)\nbndB\n(***hide***)\nbndB\u0027\n(***include-it***)\n\n(**\nRemember that with continuous compounding, $FV_T = PV_t \\times e^{r}$\nwhere $FV$ is the future value, $PV$ is the present value, $r$ is return\nbetween period $t$ and $T$.\n\nIf we take the log of both sides of the equation, we get\n\n$$ log(FV) = log(PV) \u002B r \\rightarrow log(FV) - log (PV) = r$$\n\nThis $r$ is known as the log return. \nSo to find the log return between two periods we can take the \ndifference of the log prices (where the prices are adjusted for dividends).\n\n*)\n(log bndB.AdjustedClose) - (log bndA.AdjustedClose)\n(***include-it***)\n\n\n(**\nPutting it all together.\n*)\nlet bndReturn = \n    bnd\n    |\u003E List.sortBy (fun x -\u003E x.Date)\n    |\u003E List.pairwise\n    |\u003E List.map (fun (a, b) -\u003E (log b.AdjustedClose) - (log a.AdjustedClose))\n\nlet vtiReturn =\n    vti\n    |\u003E List.sortBy (fun x -\u003E x.Date)\n    |\u003E List.pairwise\n    |\u003E List.map (fun (a, b) -\u003E (log b.AdjustedClose) - (log a.AdjustedClose))\n\n\nlet bndAvgReturn = bndReturn |\u003E List.average\nbndAvgReturn\n(***include-it***)\n\nlet vtiAvgReturn = vtiReturn |\u003E List.average\nvtiAvgReturn\n(***include-it***)\n\n(*** Portfolio returns for different weights. *)\n\nlet differentReturns =\n  [ for w in [0.0 .. 0.2 .. 1.0] -\u003E w, w*bndAvgReturn \u002B (1.0-w)*vtiAvgReturn ]\n\ndifferentReturns\n(***include-it***)\n\nChart.Line(differentReturns)\n(**\n\n## Portfolio Variance\n\nFor a portfolio of $N$ assets, the portfolio variance $\\sigma_p^2$ is \n\n$$ \\sigma_p^2 = \\sum^N_{i=1} \\sum^N_{j=1} w_i w_j cov(r_i,r_j) = \\sum^N_{i=1} w^2_i\\sigma^2_i \u002B 2\\sum_{j\u003Ci} w_i w_j cov(r_i,r_j)$$\n\nwhere $i$ and $j$ index assets, $r_i$ is the return of asset $i$, $\\sigma^2_i$ is the variance of $r_i$, \nand $cov(r_i,r_j)$ is the covariance between $r_i$ and $r_j$.\n\nFor a portfolio of two assets $x$ and $y$ this simplifies to:\n\n$$ \\sigma^2_p = w_x^2 \\sigma^2_x \u002B w_y^2 \\sigma^2_y \u002B 2 w_x w_y cov(r_x,r_y).$$\n\nthis.\nFor next time: Portfolio Variance and Leverage\n## Leverage\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\n\nopen FSharp.Stats\nopen FSharp.Stats.Correlation\n\n\n\n\nSeq.pearson bndReturn vtiReturn"},{"uri":"/Teaching/Portfolio.html","title":"Portfolio","content":"// Last updated 2021-04-29 09:00\nmodule Portfolio\n\n#r \u0022nuget: NodaTime\u0022\n\nopen System\nopen NodaTime\n\n/// Misc\n/// \n\n// Type extension until NodaTime puts YearMonth.PlusMonths() in the nuget version.\n// taken from here in the NodaTime repo until it is accessible\n// https://github.com/carlosschults/nodatime/blob/43e9f24c2ba5a7ed0fd145c082d9e63cd50b1149/src/NodaTime/YearMonth.cs#L156\n// See https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-extensions\n// to understand type extensions.\ntype YearMonth with\n    member this.PlusMonths(months:int) =\n                this.OnDayOfMonth(1).PlusMonths(months).ToYearMonth()\n///\n\ntype SecurityId =\n    | Ticker of string\n    | Cusip of string\n    | Bloomberg of string\n    | Permno of int\n    | Other of string\n\ntype InvestmentUniverse = \n    { FormationMonth : YearMonth \n      Securities : SecurityId list }\n\ntype SecuritySignal = \n    { SecurityId : SecurityId\n      Signal : float }\n\ntype SecuritiesWithSignals =\n    { FormationMonth : YearMonth \n      Signals : SecuritySignal list }\n\ntype PortfolioId = \n    | Named of string\n    | Indexed of name:string * index:int\n\ntype AssignedPortfolio =\n    { PortfolioId : PortfolioId\n      FormationMonth : YearMonth \n      Signals : SecuritySignal list }\n\n\nlet assignSignalSort name n (xs: SecuritiesWithSignals) =\n    xs.Signals\n    |\u003E List.sortBy(fun x -\u003E x.Signal)\n    |\u003E List.splitInto n\n    |\u003E List.mapi(fun i ys -\u003E \n        // because lists are 0-indexed and I want the minimum\n        // portfolio index to be 1, I\u0027m doing index = i\u002B1.\n        { PortfolioId = Indexed(name=name,index=i\u002B1)\n          FormationMonth = xs.FormationMonth\n          Signals = ys })\n\ntype Position =\n    { SecurityId : SecurityId \n      Weight : float }\n\ntype Portfolio = \n    { PortfolioId: PortfolioId\n      FormationMonth : YearMonth\n      Positions : Position list }\n\ntype PortfolioReturn =\n    { PortfolioId: PortfolioId\n      YearMonth : YearMonth\n      Return : float }\n\n// This type alias defines the type of a function that has\n// a tuple input of SecurityId * YearMonth and outputs\n// a (SecurityId * float) Option. Think of it like\n// using types to write documentation of the functions.\ntype GetsMarketCaps = SecurityId * YearMonth -\u003E (SecurityId * float) Option\n\n// Defining this type alias makes it easier to read the type of the function that I want for\n// marketCapGetter in the function that I have below. Otherwise it might look something like\n// let giveValueWeights (marketCapGetter: (SecurityId * YearMonth -\u003E (SecurityId * float) Option) ...\n// which is the same thing but not as clear what we\u0027re trying to do.\nlet giveValueWeights (marketCapGetter: GetsMarketCaps) (x: AssignedPortfolio) =\n    let mktCaps =\n        x.Signals\n        // List.choose throws away None results, so this means \n        // that if the market cap getter returns None\n        // then we will not have that security in our portfolio.\n        |\u003E List.choose(fun signal -\u003E marketCapGetter (signal.SecurityId, x.FormationMonth))\n\n    let totMktCap = mktCaps |\u003E List.sumBy snd\n\n    let pos =\n        mktCaps\n        |\u003E List.map(fun (id, mktCap) -\u003E\n            { SecurityId = id \n              Weight = mktCap / totMktCap })\n    { PortfolioId = x.PortfolioId\n      FormationMonth = x.FormationMonth \n      Positions = pos }\n\n// This type alias defines the type of a function that has\n// a tuple input of SecurityId * YearMonth and outputs\n// a (SecurityId * float). Think of it like\n// using types to write documentation of the functions.\ntype GetsReturn = SecurityId * YearMonth -\u003E (SecurityId * float)\n\n// Defining this type alias makes it easier to read the type of the function that I want for\n// marketCapGetter in the function that I have below. Otherwise it might look something like\n// let giveValueWeights (marketCapGetter: (SecurityId * YearMonth -\u003E (SecurityId * float) Option) ...\n// which is the same thing but not as clear what we\u0027re trying to do.\nlet getPortfolioReturn (returnGetter: GetsReturn) (x: Portfolio) =\n    let returnMonth = x.FormationMonth.PlusMonths(1)\n    let portRet =\n        x.Positions\n        |\u003E List.sumBy(fun pos -\u003E \n            let (_id, ret) = returnGetter (pos.SecurityId, returnMonth)\n            pos.Weight * ret)\n    { PortfolioId = x.PortfolioId\n      YearMonth = returnMonth\n      Return = portRet }\n\n\n/// This function takes a sample start and sample end\n/// and returns a list with all months from start to end.\n/// Don\u0027t worry about understanding what this function does.\n/// The details are beyond the scope of the class, but if you\u0027re\n/// curious it\u0027s a recursive function:\n/// https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/recursive-functions-the-rec-keyword\nlet getSampleMonths (sampleStart:YearMonth, sampleEnd:YearMonth) =\n    if sampleEnd \u003C= sampleStart then failwith \u0022sampleEnd should be after sampleStart\u0022\n    let rec loop (sampleEnd:YearMonth) window = \n        match window with\n        | [] -\u003E failwith \u0022Need a starting point\u0022\n        | lastMonth::_monthsBeforeThat -\u003E\n            if lastMonth \u003C sampleEnd then \n                loop sampleEnd (lastMonth.PlusMonths(1)::window)\n            else window\n    loop sampleEnd [sampleStart]\n    |\u003E List.rev"},{"uri":"/Teaching/PortfolioFormation-SimpleExample.html","title":"Building a strategy","content":"(**\n\n---\ntitle: Building a strategy\ncategory: Lectures\ncategoryindex: 1\nindex: 4\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n# Building a strategy\n\nOur objective is to write code that will allow us to do something like\n\n\u0060\u0060\u0060fsharp\nsamplePeriod\n|\u003E filterInvestmentUniverse\n|\u003E constructSignals\n|\u003E assignPortfolioWeights\n|\u003E getPortfolioReturns\n\u0060\u0060\u0060\n\nNow let\u0027s dig in. This is a *relatively* basic version of a strategy to build intuition with what we\u0027re doing. It is simpler than working with real data. But we will next move to real data.\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\nopen FSharp.Stats\n\n(**\n## Workflow for using quantitative signals\n\nHow do we decide on the position weights for the different securities? An example workflow:\n\n1. **Define your investment universe.** Your investment universe is the set of securities that you are considering for investment. An investment universe is typically a subset of securities grouped by some common characteristics: small-capitalization stocks, utility stocks, corporate bonds, firms listed on Euronext, etc.\n2. **Get your signal for each security.** The signal is some information that you believe can be used to predict returns or risk. It could be a stock tip from a friend, a stock analyst recommendation, something you read on reddit, revenue growth, ... \n3. **Define a mapping from signals to portfolio weights.** \n\nLet\u0027s go through this step by step.\n\n*)\n\n(**\n\n## 1. Investment universe: modelling a security\n\nWe\u0027re going to be forming portfolios consisting of weights on different securities. We need a way to identify those securities. Securities can have different identifiers. Stock exchanges use ticker symbols, but CUSIPs are commonly used by other entities (e.g., ratings agencies, regulators, etc.). Some data providers might also use their own custom identifier. For example, Bloomberg has their own \u0022Bloomberg ticker\u0022 and CRSP uses PERMNOs. Thus, if we\u0027re trying to identify a security we can use tickers OR CUSIPs OR Bloomberg Tickers OR PERMNOs. How do we model this?\n\nA good type for modelling \u0022OR\u0022 relationships is a Discriminated Union. The pipe (\u0060|\u0060) symbol indicates an \u0022or\u0022 relationship. \n*)\ntype SecurityId =\n    | Ticker of string\n    | Cusip of string\n    | Bloomberg of string\n    | Permno of int\n\n\n// Defining examples of these ids.\nlet tickerExample = Ticker \u0022KO\u0022\nlet permnoExample = Permno 1001\n\n\n// Deconstructing using pattern matching.\n// Think \u0022match what\u0027s on the left side of = to what\u0027s on the right side\u0022\nlet (Ticker deconTickerExample) = tickerExample\nprintfn \u0022%s\u0022 deconTickerExample\n\nlet (Permno deconPermnoExample) = permnoExample\nprintfn \u0022%i\u0022 deconPermnoExample\n\n// Now we can define our investment universe.\nlet investmentUniverse =\n    [for tick in [ \u0022AAPL\u0022; \u0022KO\u0022; \u0022GOOG\u0022;\u0022DIS\u0022;\u0022GME\u0022] do \n        Ticker tick ]\n\n(**\n## 2. Signals\n*)\n\nlet signals =\n    [ Ticker \u0022AAPL\u0022, 2.0\n      Ticker \u0022KO\u0022, -1.4\n      Ticker \u0022GOOG\u0022, 0.4 \n      Ticker \u0022DIS\u0022, 1.1 ]\n    |\u003E Map\n\n(***do-not-eval***)\nsignals[Ticker \u0022AAPL\u0022]\n(** *)\n\nMap.find (Ticker \u0022AAPL\u0022) signals\n(***include-it***)\nMap.tryFind (Ticker \u0022AAPL\u0022) signals\n(***include-it***)\nMap.tryFind (Ticker \u0022GME\u0022) signals\n(***include-fsi-output***)\n\n(** Now a function that gets the signal given a security id.*)\nlet getSignal id = Map.tryFind id signals\n\ngetSignal (Ticker \u0022AAPL\u0022)\ngetSignal (Ticker \u0022GOOG\u0022)\n\n(**\nWe can call this function on all signals in our investment universe.\n*)\n// using a loop.\n[ for security in investmentUniverse do\n    security, getSignal security ]\n\n// same thing with List.map\ninvestmentUniverse\n|\u003E List.map(fun security -\u003E security, getSignal security)\n\n(** Let\u0027s create a type to hold a security identifier and its signal.*)\ntype SecuritySignal = \n    { SecurityId : SecurityId\n      Signal : float }\n\n(** \nNow a function that gets the signal and puts it in the \n\u0060SecuritySignal\u0060 record type. It\u0027s possible that the security signal does not exist, so we\u0027ll use an option type to handle the fact that we might\nfind the signal and we might not.\n*)\nlet getSecuritySignal security =\n    match Map.tryFind security signals with\n    | None -\u003E None\n    | Some signal -\u003E\n        let result = { SecurityId = security; Signal = signal }\n        Some result\n\n\n(** \nHere we can see that we retured something when there\nwas a signal and nothing if there was none.\n*)\ngetSecuritySignal (Ticker \u0022GME\u0022)\n(*** include-fsi-output ***)\ngetSecuritySignal (Ticker \u0022GOOG\u0022)\n(*** include-fsi-output ***)\n\nfor security in investmentUniverse do\n    let securitySignal = getSecuritySignal security\n    printfn $\u0022{securitySignal}\u0022\n(***include-output***)\n\n(** This is equivalent but using a pipeline. *)\ninvestmentUniverse\n|\u003E List.map getSecuritySignal\n|\u003E List.iter (printfn \u0022%A\u0022)\n(*** include-output ***)\n\n(**\nIf we do choose instead of map, then we will\nend up with only the results when there was something.\n*)\ninvestmentUniverse\n|\u003E List.choose getSecuritySignal\n|\u003E List.iter (printfn \u0022%A\u0022) \n(*** include-output***)\n\nlet securitySignals = \n    investmentUniverse\n    |\u003E List.choose getSecuritySignal\n\nsecuritySignals\n|\u003E List.iter (printfn \u0022%A\u0022)\n(*** include-output***)\n\n(**\n## 3. Defining a mapping between signals and portfolio weights.\n\nNow let\u0027s look at turning signals into weights.\n\nOften, you only want stocks with signals above or below a given threshold in a portfolio. For instance, if you have a \u0022value\u0022 portfolio you might only want stocks with low price to earnings (P/E) ratios in your portfolio. Or maybe you want to go long value stocks and short growth stocks.\n\nA typical procedure is to assign securities to portfolios based on signals, and then weight securities within those sub portfolios.\n\n*)\n\n(**\n\nFirst, let\u0027s represent portfolios Ids.\nA first step is to define portfolio IDs. A simple ID is a string name, but often we will do things like create 10 size portfolios infexed from 1 to 10, like (\u0022Size\u0022, 1), (\u0022Size\u0022, 2), ... We can model this as a discriminated union. \n\nHere, \u0060Indexed\u0060 is a tuple where the first element is a string and the second is an integer. I could just say \u0060Indexed of string * int\u0060, but I am going to name them to give them meaning. Though the names are optional when constructing and deconstructing\n*)\n\ntype PortfolioId = \n    | Named of string\n    | Indexed of {| Name: string; Index: int |}// name:string * index:int\n\n// Example portfolio IDs\nlet portfolioId1 = Named \u0022Market\u0022\nlet portfolioId2 = Indexed {| Name = \u0022Size\u0022; Index = 1 |} \nlet portfolioId3 = Indexed {| Name = \u0022Size\u0022 ; Index = 2 |}    \n\nlet getPortfolioIdString port =\n    match port with\n    | Named name -\u003E name\n    | Indexed p -\u003E $\u0022{p.Name}: {p.Index}\u0022\n\n\ngetPortfolioIdString portfolioId1\n(***include-it***)\ngetPortfolioIdString portfolioId3\n(***include-it***)\n\n(**\nLet\u0027s assign securities to portolios based on whether their signal is above or below the median.\n*)\n\n// Model for an assigned portfolio\ntype AssignedPortfolio =\n    { PortfolioId : PortfolioId \n      Signals : list\u003CSecuritySignal\u003E }\n\nlet medianSignal = \n    securitySignals \n    |\u003E List.map(fun x -\u003E x.Signal)\n    |\u003E Seq.median\n(** The median signal is *)\n(***include-value:medianSignal***)\n\n\nlet aboveMedian =\n    securitySignals\n    |\u003E List.filter(fun x -\u003E x.Signal \u003E= medianSignal)\n(** the above-median securities: *)\n(***include-value:aboveMedian***)\n\nlet belowMedian =\n    securitySignals\n    |\u003E List.filter(fun x -\u003E x.Signal \u003C medianSignal)\n(** the below-median securities: *)\n(***include-value:belowMedian***)\n\n\nlet assigned =\n    [ { PortfolioId = Named(\u0022Above Median\u0022)\n        Signals = aboveMedian }\n      { PortfolioId = Named(\u0022Below Median\u0022)\n        Signals = belowMedian} ]\n(** assigned to portfolios: *)\n(***include-value:assigned***)\n\n(**\nOr create a reusable function to do the same thing\n*)\n\nlet assignAboveBelowMedian securitySignals =\n    let medianSignal = \n        securitySignals \n        |\u003E List.map(fun x -\u003E x.Signal)\n        |\u003E Seq.median\n\n    let aboveMedian =\n        securitySignals\n        |\u003E List.filter(fun x -\u003E x.Signal \u003E= medianSignal)\n\n    let belowMedian =\n        securitySignals\n        |\u003E List.filter(fun x -\u003E x.Signal \u003C medianSignal)\n\n    [ { PortfolioId = Named(\u0022Above Median\u0022)\n        Signals = aboveMedian }\n      { PortfolioId = Named(\u0022Below Median\u0022)\n        Signals = belowMedian} ]\n\n\n(**\n## Modelling a position\nNow we have assigned securities to portfolios based on the trading signal. Now we can form weights. We can think of a portfolio as consisting of positions where positions are symbols and weights.\n*)\n\ntype Position =\n    { SecurityId : SecurityId \n      Weight : float }\n\n// Defining example positions\n\nlet koPosition = { SecurityId = Ticker \u0022KO\u0022; Weight = 0.25 }\nlet permnoPosition = { SecurityId = Permno 1001; Weight = 0.75 }\n\n(**\n## Modelling a portfolio\nAnd once we have multiple positions, then we can group them into a portfolio.\n*)\n\n(** And a portfolio can consist of a Portfolio Id and an List of positions*)\n\ntype Portfolio = \n    { PortfolioId: PortfolioId\n      Positions : list\u003CPosition\u003E }\n\n(**\nAn example constructing a portfolio\n*)\n\nlet portfolioExample1 =\n    { PortfolioId = Named \u0022Example 1\u0022\n      Positions = [ koPosition; permnoPosition ] }\n\n(**\n## Defining portfolio position weights\n\nOnce you have a portfolio of securities that have met some signal criteria, it is common to weight those securities using either of two simple weighting schemes: equal weight or value weight.\n\nEqual weight means that every security has the same weight.\n\nValue-weight means that you weight securities proportional to their market value. This means that your portfolio put more weight on more valuable securities. Or it \u0022tilts\u0022 toward more valuable securities. This weighting scheme is utilized when you want to make sure that you are not putting too much weight on small illiquid securities that are hard to purchase.\n\n\nEqual-weight is easy:\n*)\nlet weightTestPort = \n    assigned |\u003E List.find (fun x -\u003E x.PortfolioId = Named(\u0022Above Median\u0022))\n\nlet nSecurities = weightTestPort.Signals.Length\n\nlet ewTestWeights =\n    [ for signal in weightTestPort.Signals do \n        { SecurityId = signal.SecurityId\n          Weight = 1.0 / (float nSecurities) } ]\n\nlet giveEqualWeights x =\n    let n = x.Signals.Length\n    let pos =\n        [ for signal in x.Signals do \n            { Position.SecurityId = signal.SecurityId\n              Weight = 1.0 / (float n) } ]\n    { PortfolioId = x.PortfolioId \n      Positions = pos }\n\n(** For one portfolio: *)\ngiveEqualWeights weightTestPort\n(***include-fsi-output***)\n\n(** For all portfolios:*)\n[ for portfolio in assigned do giveEqualWeights portfolio ]\n(***include-fsi-output***)\n\n(** or equivalently:*)\nassigned |\u003E List.map giveEqualWeights\n(***include-fsi-output***)\n\n(** \nFor value weights, we need the securities\u0027 market values\nsplit into above/below median and for portfolios with those.\n*)\nlet marketCapitalizations =\n    [ Ticker \u0022AAPL\u0022, 10.0\n      Ticker \u0022KO\u0022, 4.0\n      Ticker \u0022GOOG\u0022, 7.0 \n      Ticker \u0022DIS\u0022, 5.0 ]\n    |\u003E Map\n\nlet mktCaps =\n    [ for signal in weightTestPort.Signals do \n        let mktcap = Map.find signal.SecurityId marketCapitalizations\n        signal.SecurityId, mktcap ]\n\n(***include-fsi-output***)\n\nlet vwTestWeights =\n    let totMktCap = mktCaps |\u003E List.sumBy snd\n    [ for (id, mktCap) in mktCaps do \n        { SecurityId = id \n          Weight = mktCap / totMktCap } ]\n(***include-fsi-output***)\n\n(**\nNow a function to do the same as above.\n*)\nlet giveValueWeights x =\n    let mktCaps =\n        [ for signal in x.Signals do \n            let mktcap = Map.find signal.SecurityId marketCapitalizations\n            signal.SecurityId, mktcap ]\n    let totMktCap = mktCaps |\u003E List.sumBy snd\n    let pos =\n        [ for (id, mktCap) in mktCaps do \n            { SecurityId = id \n              Weight = mktCap / totMktCap } ]\n    { PortfolioId = x.PortfolioId; Positions = pos }\n\n(**\nWe can map our function to both of our assigned portfolios.\n*)\n\n[ for x in assigned do giveValueWeights x ]\n(***include-it***)\n\n(** or equivalently *)\nassigned |\u003E List.map giveValueWeights  \n(***include-it***)\n\n(**\nAll together now. This is our workflow.\n*)\nlet strategyWeights =\n    investmentUniverse\n    |\u003E List.choose getSecuritySignal\n    |\u003E assignAboveBelowMedian\n    |\u003E List.map giveValueWeights\n\n(*** include-fsi-output***)\n\n(**\n# How do we calculate returns?\n\n\nTake these returns:\n*)\nlet returnMap =\n    [ Ticker \u0022AAPL\u0022, -0.4\n      Ticker \u0022KO\u0022, -0.1\n      Ticker \u0022GOOG\u0022, 0.15 \n      Ticker \u0022DIS\u0022, 0.1 ]\n    |\u003E Map\n\n(**\nWhat is the return of the two portfolios?\n\nHint: the value-weight assignment code is a good reference for figuring out how to look up the stock returns.\n*)"},{"uri":"/Teaching/select-project-signal.html","title":"Select Project Signals","content":"(**\n---\ntitle: Select Project Signals\ncategory: Assignments\ncategoryindex: 2\nindex: 4\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n\n# Submitting your trading signal preferences.\nYou need to select your main trading signal. \nEverybody will examine a different signal, \nso you need to give me an ordered list of your preferred signals. \n\nI will randomly iterate through students and \nassign them their top choice from among the signals remaining.\n\nThe signals are listed in the \u0022Project signals list.xlsx\u0022 file\nthat you can find on moodle. \n    - Use the **VARIABLE** column to identify \n      the variable that you want. \n    - Do not use any other columns to identify your variable. \n    - Only variables from that excel file are valid.\n\nYou will submit your choices as a .csv file. Here\u0027s how to do that.\n\nUse the [FSharp.Data CsvProvider](https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html) \nto construct your csv file. \nAll the csv related stuff below comes from things discussed somewhere on that webpage.\n\nFirst construct a sample, then use the type provider \nto define the type from the sample.\n\nBelow you will find a variable named \u0022signals\u0022.\nDo not modify it. This is to check that you\ndo not have a typo in your preferred signals.\nThe code that you use starts after the\n\u0022Code starts now\u0022 section.\n*)\n\n//****************************************\n//*****Code starts below this section*****\n//****************************************\n// Do not modify the signals variable\nlet signals =\n    [\u0022niq_su\u0022\n     \u0022ret_6_1\u0022\n     \u0022ret_12_1\u0022\n     \u0022saleq_su\u0022\n     \u0022tax_gr1a\u0022\n     \u0022ni_inc8q\u0022\n     \u0022prc_highprc_252d\u0022\n     \u0022resff3_6_1\u0022\n     \u0022resff3_12_1\u0022\n     \u0022be_me\u0022\n     \u0022debt_me\u0022\n     \u0022at_me\u0022\n     \u0022ret_60_12\u0022\n     \u0022ni_me\u0022\n     \u0022fcf_me\u0022\n     \u0022div12m_me\u0022\n     \u0022eqpo_me\u0022\n     \u0022eqnpo_me\u0022\n     \u0022sale_gr3\u0022\n     \u0022sale_gr1\u0022\n     \u0022ebitda_mev\u0022\n     \u0022sale_me\u0022\n     \u0022ocf_me\u0022\n     \u0022intrinsic_value\u0022\n     \u0022bev_mev\u0022\n     \u0022netdebt_me\u0022\n     \u0022eq_dur\u0022\n     \u0022capex_abn\u0022\n     \u0022at_gr1\u0022\n     \u0022ppeinv_gr1a\u0022\n     \u0022noa_at\u0022\n     \u0022noa_gr1a\u0022\n     \u0022lnoa_gr1a\u0022\n     \u0022capx_gr1\u0022\n     \u0022capx_gr2\u0022\n     \u0022capx_gr3\u0022\n     \u0022chcsho_12m\u0022\n     \u0022eqnpo_12m\u0022\n     \u0022debt_gr3\u0022\n     \u0022inv_gr1\u0022\n     \u0022inv_gr1a\u0022\n     \u0022oaccruals_at\u0022\n     \u0022taccruals_at\u0022\n     \u0022cowc_gr1a\u0022\n     \u0022coa_gr1a\u0022\n     \u0022col_gr1a\u0022\n     \u0022nncoa_gr1a\u0022\n     \u0022ncoa_gr1a\u0022\n     \u0022ncol_gr1a\u0022\n     \u0022nfna_gr1a\u0022\n     \u0022sti_gr1a\u0022\n     \u0022lti_gr1a\u0022\n     \u0022fnl_gr1a\u0022\n     \u0022be_gr1a\u0022\n     \u0022oaccruals_ni\u0022\n     \u0022taccruals_ni\u0022\n     \u0022netis_at\u0022\n     \u0022eqnetis_at\u0022\n     \u0022dbnetis_at\u0022\n     \u0022niq_be\u0022\n     \u0022niq_be_chg1\u0022\n     \u0022niq_at\u0022\n     \u0022niq_at_chg1\u0022\n     \u0022ebit_bev\u0022\n     \u0022ebit_sale\u0022\n     \u0022sale_bev\u0022\n     \u0022at_turnover\u0022\n     \u0022gp_at\u0022\n     \u0022gp_atl1\u0022\n     \u0022ope_be\u0022\n     \u0022ope_bel1\u0022\n     \u0022op_at\u0022\n     \u0022op_atl1\u0022\n     \u0022cop_at\u0022\n     \u0022cop_atl1\u0022\n     \u0022f_score\u0022\n     \u0022o_score\u0022\n     \u0022z_score\u0022\n     \u0022pi_nix\u0022\n     \u0022at_be\u0022\n     \u0022saleq_gr1\u0022\n     \u0022rd_me\u0022\n     \u0022rd_sale\u0022\n     \u0022opex_at\u0022\n     \u0022emp_gr1\u0022\n     \u0022rd5_at\u0022\n     \u0022age\u0022\n     \u0022dsale_dinv\u0022\n     \u0022dsale_drec\u0022\n     \u0022dgp_dsale\u0022\n     \u0022dsale_dsga\u0022\n     \u0022sale_emp_gr1\u0022\n     \u0022tangibility\u0022\n     \u0022kz_index\u0022\n     \u0022ocfq_saleq_std\u0022\n     \u0022cash_at\u0022\n     \u0022ni_ar1\u0022\n     \u0022ni_ivol\u0022\n     \u0022earnings_variability\u0022\n     \u0022aliq_at\u0022\n     \u0022aliq_mat\u0022\n     \u0022seas_1_1an\u0022\n     \u0022seas_1_1na\u0022\n     \u0022seas_2_5an\u0022\n     \u0022seas_2_5na\u0022\n     \u0022seas_6_10an\u0022\n     \u0022seas_6_10na\u0022\n     \u0022seas_11_15an\u0022\n     \u0022seas_11_15na\u0022\n     \u0022seas_16_20an\u0022\n     \u0022seas_16_20na\u0022\n     \u0022market_equity\u0022\n     \u0022ivol_ff3_21d\u0022\n     \u0022ivol_capm_252d\u0022\n     \u0022ivol_capm_21d\u0022\n     \u0022ivol_hxz4_21d\u0022\n     \u0022rvol_21d\u0022\n     \u0022beta_60m\u0022\n     \u0022betabab_1260d\u0022\n     \u0022beta_dimson_21d\u0022\n     \u0022turnover_126d\u0022\n     \u0022turnover_var_126d\u0022\n     \u0022dolvol_126d\u0022\n     \u0022dolvol_var_126d\u0022\n     \u0022prc\u0022\n     \u0022ami_126d\u0022\n     \u0022zero_trades_21d\u0022\n     \u0022zero_trades_126d\u0022\n     \u0022zero_trades_252d\u0022\n     \u0022rmax1_21d\u0022\n     \u0022rskew_21d\u0022\n     \u0022iskew_capm_21d\u0022\n     \u0022iskew_ff3_21d\u0022\n     \u0022iskew_hxz4_21d\u0022\n     \u0022coskew_21d\u0022\n     \u0022ret_1_0\u0022\n     \u0022betadown_252d\u0022\n     \u0022bidaskhl_21d\u0022\n     \u0022ret_3_1\u0022\n     \u0022ret_9_1\u0022\n     \u0022ret_12_7\u0022\n     \u0022corr_1260d\u0022\n     \u0022rmax5_21d\u0022\n     \u0022rmax5_rvol_21d\u0022\n     \u0022ni_be\u0022\n     \u0022ocf_at\u0022\n     \u0022ocf_at_chg1\u0022\n     \u0022mispricing_perf\u0022\n     \u0022mispricing_mgmt\u0022\n     \u0022qmj\u0022\n     \u0022qmj_prof\u0022\n     \u0022qmj_growth\u0022\n     \u0022qmj_safety\u0022]\n    |\u003E set \n\n//****************************************\n//****Code starts now*********************\n//****************************************\n\n(**\n*)\n#r \u0022nuget:FSharp.Data\u0022\n\nopen FSharp.Data\n[\u003CLiteral\u003E]\nlet submissionCsvSample = \u0022StudentId (int), Preference (int), Signal (string)\u0022\n\ntype SubmissionCsv = CsvProvider\u003CsubmissionCsvSample\u003E\n\n(** What are your (ordered) preferences?\n\n1. Fill in with your student id so that I know who you are.\n*)\nlet myStudentId = 007\n\n// check that you are paying attention:\nif myStudentId = 007 then failwith \u0022Are you sure that 007 is your student id number?\u0022\n\n(** 2. Fill in with your preferences *)\nlet myPreferences =\n    // **Make sure you use the exact string from the VARIABLE column**\n    // do as many choices as you want.\n    // If you give me 3 and you run out of choices because\n    // everybody else already took your top 3 choices,\n    // then I will just randomly assign you something.\n    //\n    // So if you care it\u0027s probably best to give more choices.\n    [\n        \u0022eqpo_me\u0022 // first choice **Use VARIABLE, not the name \u0022Payout Yield\u0022**\n        \u0022eqnpo_me\u0022// second choice\n        \u0022sale_gr3\u0022// third choice\n        \u0022sale_gr1\u0022// fourth choice\n    ]\n\n(** \nThis code checks if you have a typo in myPreferences\nRun it. If there\u0027s typo you will see an exception.\n*)\nlet typos =\n    //[|\u0022eqpo_me1\u0022;\u0022eqpo_me2\u0022|]\n    myPreferences \n    |\u003E List.filter (fun signal -\u003E not (signals.Contains signal))\nif not (List.isEmpty typos) then \n    let typos = typos |\u003E String.concat \u0022 and \u0022\n    failwith ($\u0022{typos} is not a signal. Check spelling.\u0022)\nelse printfn \u0022%s\u0022 \u0022Congrats, no typos\u0022\n\nlet rowCreator i signal =\n    // Csv types have a member .Row that constructs a row.\n    // Technically, the Csv is a class and .Row is a member of that\n    // class. But none of this matters. Just think of .Row as a\n    // function that goes with the csv type that allows you to use\n    // named parameters.\n    //\n    // if you hover over \u0022.Row\u0022 below, you can see what the columns of the row\n    // are (studentId,preference,signal). Intellisense should also\n    // pop them up for you if you were typing it from scratch. Such\n    // as delete the comma from \u0022myStudentId,\u0022 and then retype the comma.\n    // you should see a popup with the column info saying what is in\n    // a row.\n    SubmissionCsv.Row\n        (studentId=myStudentId,\n         preference=i,\n         signal=signal)\n\n// test\nlet test1 = rowCreator 0 \u0022sale_gr1\u0022\ntest1.StudentId\ntest1.Signal\ntest1.Preference\n\n(**\nWe\u0027ll use List.mapi to create our rows.\nList.mapi is like List.map, but it adds\nthe index of the list (i)\nas a parameter to the function. \nThis is useful when you want to use the index \nof the element in the list\nas part of your function.\n\nHere, we\u0027ve ordered our list myPreferences\nbased on our first, second, 3rd choice etc.\nSo we\u0027re using the index of the element in the list as our\npreference column.\n\n0 is first choice, 1 is second choice, 2 is 3rd choice ... \n*)\nlet mySubmission =\n    myPreferences\n    // What we have below is the same as\n    // |\u003E List.mapi(fun i x -\u003E rowCreator i x)\n    //\n    // but because we wrote rowCreator to accept i and x\n    // as the first two function inputs, we can \n    // take the shortcut and do below.\n    |\u003E List.mapi rowCreator\n\n(**\nThis is an array of rows.\n\nCheck your first preference\n*)\nlet myFirstPreference = mySubmission |\u003E List.head\n\nmyFirstPreference.StudentId // make sure it\u0027s not 7\nmyFirstPreference.Preference // should be 0\nmyFirstPreference.Signal // choose wisely\n\n(*\nRather than an \u0022list of csv rows\u0022, we want a \u0022csv file\u0022.\n\nHere\u0027s how we do that. We pass the SubmissionCsv.Rows contained\nin the mySubmission array  to the\nSubmissionCsv type constructor like so.\n*)\nlet mySubmissionFile = new SubmissionCsv(mySubmission)\n\n(**\nOk, let\u0027s write the file. Remember that \u0060__SOURCE_DIRECTORY__\u0060\nis a magic variable that points to whatever folder this script file\n(aka the source code file) is contained in.\n\nSo this will write a csv file in the current directory.\n*)\n\nlet fileName = $\u0022{myStudentId}.csv\u0022\nlet fullFilePath = $\u0022{__SOURCE_DIRECTORY__}/{fileName}\u0022\n\nmySubmissionFile.Save(fullFilePath)\n\n(**\nNow find that file and submit it. Also click on it in visual studio code;\nyou should be able to see what the file looks like. It\u0027s just a text file with a .csv extension.\n*)\n\n(**\nand if you want to read the data back in from the file to see that it works:\n*)\nlet backIn = SubmissionCsv.Load(fullFilePath)\n\nbackIn.Rows\n|\u003E Seq.toList\n|\u003E List.map(fun row -\u003E row.Preference, row.Signal)"},{"uri":"/Teaching/VolatilityTiming.html","title":"Volatility Timing","content":"(**\n\n---\ntitle: Volatility Timing\ncategory: Lectures\ncategoryindex: 1\nindex: 2\n---\n\n[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n\n# Volatility timing\nWe\u0027re going to look at how to manage portfolio volatility. Managing volatility is a fundamental risk-management task. You probably have some notion of the amount of volatility that you want in your portfolio, or that you feel comfortable bearing. Maybe you\u0027re ok with an annualized volatility of 15%, but 30% is too much and makes it hard for you to sleep at night. If that\u0027s the case, then when markets get volatile you might want to take action to reduce your portfolio\u0027s volatility. We\u0027ll discuss some strategies for predicting and managing volatility below.\n\nWe will focus on allocating between a risky asset and a risk-free asset as a way to manage volatility (i.e., two-fund seperation). We\u0027re taking the risky asset, such as the market portfolio of equities, as given. The essential idea is to put more weight on the risky asset when expected volatility is low and less weight on the risky asset when expected volatility is high. This is related to a portfolio construction strategy known as risk-parity. The managed volatility strategy that we consider below is based off work by [Barroso and Santa-Clara (2015)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=barroso\u002Bsanta-clara\u002B2015\u002Bjfe\u0026btnG=), [Daniel and Moskowitz (2016)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=daniel\u002Band\u002Bmoskowitz\u002Bmomentum\u002Bcrash\u002B2016\u002Bjfe\u0026btnG=), and [Moreira and Muir (2017)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=moreira\u002Band\u002Bmuir\u002B2017\u002Bjf\u002Bvolatility\u002Bmanaged\u002Bportfolios\u0026btnG=). The Moreira and Muir (2017) paper is probably the best place to start. Though the observation that a) predictable volatility and b) unpredictable returns implies predictable Sharpe ratios predates the aoove work.\n*)\n\n(**\n## Acquiring Fama-French data\nAs a start, let\u0027s acquire a long daily time series on aggregate US market returns. We\u0027ll use the 3 factors [dataset](http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/Data_Library/f-f_factors.html).\n\n*)\n\n#r \u0022nuget: FSharp.Data\u0022\n#load \u0022Common.fsx\u0022\nopen System\nopen FSharp.Data\nopen Common\n\nlet ff3 = French.getFF3 Frequency.Daily\n        \n(** \n    fsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n\n*)\n\nff3 |\u003E Seq.take 5\n\n(**\n## Observing time-varying volatility\nOne thing that can help us manage volatility is the fact that volatility tends to be somewhat persistent. By this we mean that if our risky asset is volatile today, then it is likely to be volatile tomorrow. We can observe this by plotting monthly volatility as we do below. It also means that we can use past volatility to form estimates of future volatility.\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.17\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.17\u0022\n\nopen FSharp.Stats\nopen Plotly.NET\n\nlet annualizeDaily x = x * sqrt(252.0) * 100. \n\nlet monthlyVol =\n    ff3\n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_ym, xs) -\u003E \n        let dt = xs |\u003E Seq.last |\u003E fun x -\u003E x.Date\n        let annualizedVolPct = xs |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        dt, annualizedVolPct)\n    |\u003E Seq.toArray\n\nlet volChart vols =\n    let getYear f = vols |\u003E Seq.map(fun (dt:DateTime,_vol) -\u003E dt.Year ) |\u003E f \n    let minYear = getYear Seq.min\n    let maxYear = getYear Seq.max\n    vols\n    |\u003E Chart.Column\n    |\u003E Chart.withMarkerStyle  (Outline = Line.init(Color = Color.fromKeyword ColorKeyword.Blue))  \n    |\u003E Chart.withXAxisStyle(TitleText = $\u0022Time-varying Volatility ({minYear}-{maxYear})\u0022)\n    |\u003E Chart.withYAxisStyle(TitleText = \u0022Annualized Volatility (%)\u0022)\n\nlet allVolsChart = volChart monthlyVol\nlet since2019VolChart = \n    monthlyVol \n    |\u003E Seq.filter(fun (dt,_) -\u003E dt \u003E= DateTime(2019,1,1))\n    |\u003E volChart\n\n(***do-not-eval***)\nallVolsChart |\u003E Chart.show\nsince2019VolChart |\u003E Chart.show\n\n\n(***hide***)\nallVolsChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(***hide***)\nsince2019VolChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n\n(**\n## Effect of leverage on volatility\nRecall the formula for variance of a portfolio consisting of stocks $x$ and $y$:\n\n$$ \\sigma^2 = w_x^2 \\sigma^2_x \u002B w_y^2 \\sigma^2_y \u002B 2 w_x w_y cov(r_x,r_y), $$\n\nwhere $w_x$ and $w_y$ are the weights in stocks $x$ and $y$, $r_x$ and $r_y$ are the stock returns, $\\sigma^2$ is variance, and $cov(.,.)$ is covariance. \n\nIf one asset is the risk free asset (borrowing a risk-free bond), then this asset has no variance and the covariance term is 0.0. Thus we are left with the result that if we leverage asset $x$ by borrowing or lending the risk-free asset, then our leveraged portfolio\u0027s standard deviation ($\\sigma$) is\n\n$$ \\sigma^2 = w_x^2 \\sigma^2_x \\rightarrow \\sigma = w_x \\sigma_x$$ \n*)\n\nlet leveragedVol (weight, vol) = weight * vol\n\n/// We\u0027re doing leverage in terms of weigh on the risky asset.\n/// 1 = 100%, 1.25 = 125%, etc.\nlet exampleLeverages =\n    [ 1.0; 1.5; 2.0 ]\n\nlet rollingVolSubset =\n    monthlyVol\n    |\u003E Seq.filter(fun (dt, vol) -\u003E dt \u003E DateTime(2020,1,1))\n\n// Let\u0027s take each of the leverages and map a function to them.\n// The function takes a leverage as input, and the output is\n// a tuple of (leverage, leveraged volatilities)\nlet exampleLeveragedVols =\n    exampleLeverages\n    |\u003E Seq.map(fun leverage -\u003E\n        let leveragedVols =\n            rollingVolSubset\n            |\u003E Seq.map(fun (dt, vol) -\u003E \n                dt, leveragedVol(leverage, vol))\n        leverage, leveragedVols)\n\nlet exampleLeveragesChart =\n    exampleLeveragedVols\n    |\u003E Seq.map(fun (leverage, leveragedVols) -\u003E\n        Chart.Line(leveragedVols,Name= $\u0022Levarage of {leverage}\u0022))\n    |\u003E Chart.combine\n\n(***do-not-eval***)\nexampleLeveragesChart |\u003E Chart.show\n\n(***hide***)\nexampleLeveragesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Effect of leverage on returns\nThe effect of leverage on returns can be seen from the portfolio return equation,\n$$ r_p = \\Sigma^N_{i=1} w_i r_i,$$\nwhere $r$ is return, $i$ indexes stocks, and $w$ is portfolio weights.\n\nSo if we borrow 50% of our starting equity by getting a risk-free loan, then we have\n$$ r_{\\text{levered}} = 150\\% \\times r_{\\text{unlevevered}} - 50\\% \\times r_f$$\n\nIf we put in terms of excess returns,\n$$ r_{\\text{levered}} - r_f = 150\\% \\times (r_{\\text{unlevevered}}-r_f) - 50\\% \\times (r_f-r_f)=150\\% \\times (r_{\\text{unlevevered}}-r_f)$$\n\nSo, if we work in excess returns we can just multiply unlevered excess returns by the weight. \n\nDoes this check out? Imagine that you have \\$1 and you borrow \\$1 for a net stake of \\$2. Then you invest at an exess return of 15%. What are you left with?\n*)\n\nlet invest = 1.0m\nlet borrow = 1.0m \nlet ret = 0.15m\nlet result = (invest \u002B borrow)*(1.0m\u002Bret)-borrow\nresult = 1.0m \u002B ret * (invest \u002B borrow)/invest\n\nlet leveredReturn leverage (x : French.FF3Obs ) = leverage * x.MktRf\n\n\n(**\n## Calculating cumulative returns\nWe can illustrate this with cumulative return plots. Let\u0027s first show a simple example for how we can calculate cumulative returns.\n\nImagine that you invest \\$1 at a 10% return. What do you have after n years?\n*)\n\n[| 1.0 .. 5.0 |]\n|\u003E Array.map(fun years -\u003E 1.0*(1.1**years))\n\n(** But what if we have the data like this?*)\n[| for i = 1 to 5 do 0.1 |]\n\n(** For this, we could use functions that operate by threading an accumulator through a collection: [fold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-arraymodule.html#fold) and [scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-arraymodule.html#scan). The website [www.fsharpforfunandprofit.com](https://fsharpforfunandprofit.com/posts/list-module-functions/#14) has a good discussion of the various module functions. We could use \u0060fold\u0060 to return a final cumulative return or \u0060scan\u0060 to return intermediate and final cumulative returns.\n\nLet\u0027s start with \u0060scan\u0060 to see how it works. First, let\u0027s define a function to calculate returns:\n*)\n\n/// \u003Csummary\u003EFunction to calculate cumulative returns.\n/// We are using the FV = PV*(1\u002Br) formula.\u003C/summary\u003E\n/// \u003Cparam name=\u0022pv\u0022\u003Ecumulative return thus far, like the PV in our FV formula\u003C/param\u003E\n/// \u003Cparam name=\u0022ret\u0022\u003Ethis period\u0027s return\u003C/param\u003E \nlet fv pv ret = pv*(1.0\u002Bret)\n\n// Now let\u0027s imagine we have a series of returns like\n[0.1; -0.05; 0.3; -0.15]\n\n// Our starting place is 1.0\n1.0\n(*** include-it ***)\n// After the first period we\u0027re at\n(fv 1.0 0.1)\n(*** include-it ***)\n// After two periods we\u0027re at\n(fv (fv 1.0 0.1) -0.05)\n(*** include-it ***)\n// And so on\n(fv (fv (fv 1.0 0.1) -0.05) 0.3)\n(*** include-it ***)\n(fv (fv (fv (fv 1.0 0.1) -0.05) 0.3) -0.15)\n(*** include-it ***)\n\n// now put these all in a list\n[(fv 1.0 0.1)\n (fv (fv 1.0 0.1) -0.05)\n (fv (fv (fv 1.0 0.1) -0.05) 0.3)\n (fv (fv (fv (fv 1.0 0.1) -0.05) 0.3) -0.15)]\n(*** include-it ***)\n\n(*\nWe can do this all in one step using scan. Scan expects: to be given:\n\n- An initial state (\u00601.0\u0060).\n- A collection to accumulate (\u0027[...]\u0060).\n- A function to apply to do the accumulation (\u0060fv\u0060). The function nee\n*)\n(1.0, [0.1; -0.05; 0.3; -0.15])\n||\u003E List.scan fv\n(*** include-it ***)\n\n// Or if all we cared about was the final cumulative sum,\n// we could just use fold\n(1.0, [0.1; -0.05; 0.3; -0.15])\n||\u003E List.fold fv\n(*** include-it ***)\n\n(** One thing about \u0060scan\u0060 and \u0060fold\u0060 is that they expect the output of our function \u0060fv\u0060 to have the same F# type as\nthe accumulator (in this case our pv term, but often called acc in functions). This is fine if we\u0027re\njust working with floats. But sometimes we want to thread a float accumulator through our function but return a different \u0060type\u0060 from our function. This is where \u0060mapFold\u0060 is useful. It combines a \u0060map\u0060 function and a \u0060fold\u0060 function.\n\nIf we look at the definition of \u0060mapFold\u0060 for arrays, we can see that we call it with \u0060Array.mapFold mapping state array\u0060, where \n\n\n\u0060\u0060\u0060output\nmapping : \u0027State -\u003E \u0027T -\u003E \u0027Result * \u0027State\nThe function to transform elements from the input array and accumulate the final value.\n\nstate : \u0027State\nThe initial state.\n\narray : \u0027T[]\nThe input array.\n\nReturns: \u0027Result[] * \u0027State\nThe array of transformed elements, and the final accumulated value.\n\u0060\u0060\u0060\n\nBut maybe it\u0027s easier to just think of it as a combination of a \u0060map\u0060 transformation and a \u0060fold\u0060 transformation.\n\nIn this example, we want to thread a float accumulator through a collection, but we\u0027re interested in returning a record with a stock ticker symbol and the cumulative return of the stock at that point.\n*)\n\n\ntype MapFoldInputRecord = { Symbol: string; Return : float }\ntype MapFoldOutputRecord = { Symbol : string; CumulativeReturn : float }\n\n// \u0060map\u0060 transformation\nlet mapfun pv (input:MapFoldInputRecord) =\n  let cumulativeReturn = pv*(1.0 \u002B input.Return)\n  { Symbol = input.Symbol; CumulativeReturn = cumulativeReturn }\n\nmapfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n// \u0060fold\u0060 transformation\nlet foldfun pv (input:MapFoldInputRecord) =\n  pv*(1.0 \u002B input.Return)\n\nfoldfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n(** \nNow we\u0027ll combine the \u0060map\u0060 and \u0060fold\u0060 transformations.\n\nmapFold expects us to give it a function that operates on an accumulator\nand the collection element. It expect us to return a tuple of the \u0060map\u0060 result\nand the \u0060fold\u0060 result.\n\nSo let\u0027s create \u0060mapfoldfun\u0060 that is a tuple of the \u0060mapfun\u0060 and \u0060foldfun\u0060 transformations.\n*)\nlet mapfoldfun acc input = mapfun acc input, foldfun acc input\n\nmapfoldfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n// Now create a list of records that we want to get cumulative returns for\nlet mapFoldExampleRecords =\n    [{ Symbol = \u0022AAPL\u0022; Return = 0.1}\n     { Symbol = \u0022AAPL\u0022; Return = -0.05}\n     { Symbol = \u0022AAPL\u0022; Return = 0.3}\n     { Symbol = \u0022AAPL\u0022; Return = -0.15}]\n\n// Now accumulate them with mapFold and our mapfoldfun.\n// This will give us a tuple of cumulative returns as records of type \u0060MapFoldOutputRecord\u0060 and the final cumulative return.\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold mapfoldfun\n(*** include-it ***)\n\n// We can discard the final cumulative return part by calling fst at the end.\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold mapfoldfun\n|\u003E fst\n(*** include-it ***)\nList.scan (fun acc (x: MapFoldInputRecord) -\u003E {x with Return = (1.0\u002Bacc.Return) * (1.0\u002Bx.Return)-1.0}) mapFoldExampleRecords.Head mapFoldExampleRecords.Tail\n// Same thing, but using an anonymous function instead of mapfoldfun\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold(fun acc input -\u003E \n    let cumret = acc*(1.0\u002Binput.Return)\n    { Symbol = input.Symbol; CumulativeReturn = cumret}, cumret)\n|\u003E fst\n\n(** Now we know how to calculate cumulative returns on our real data.*)\n\nlet since2020 = \n    ff3 |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2020,1,1))\n    \nlet cumulativeReturnEx =\n    let mapping inCumRet (x: French.FF3Obs) = \n        let outCumRet = inCumRet * (1.0 \u002B x.MktRf)\n        { x with MktRf = outCumRet - 1.0}, outCumRet\n    \n    (1.0, since2020)\n    ||\u003E Seq.mapFold mapping \n    |\u003E fst\n\nlet cumulativeReturnExPlot =\n    cumulativeReturnEx\n    |\u003E Seq.map(fun x -\u003E x.Date.Date, x.MktRf)\n    |\u003E Chart.Line\n\n(***do-not-eval***)\ncumulativeReturnExPlot |\u003E Chart.show\n\n(***hide***)\ncumulativeReturnExPlot |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(** Let\u0027s try leverage with daily rebalancing (each day we take leverage of X).*)\n\nlet getLeveragedReturn leverage =\n    let mapping inCumRet x = \n        let lr = leveredReturn leverage x\n        let outCumRet = inCumRet * (1.0 \u002B lr)\n        { x with MktRf = outCumRet - 1.0}, outCumRet\n    \n    (1.0, since2020)\n    ||\u003E Seq.mapFold mapping \n    |\u003E fst\n    |\u003E Seq.map(fun x -\u003E x.Date.Date, x.MktRf)\n\nlet exampleLeveragedReturnChart = \n    exampleLeverages\n    |\u003E Seq.map(fun lev -\u003E\n        let levReturn = getLeveragedReturn lev\n        Chart.Line(levReturn, Name= $\u0022Leverage of {lev}\u0022)) \n    |\u003E Chart.combine\n\n(***do-not-eval***)\nexampleLeveragedReturnChart |\u003E Chart.show\n\n(***hide***)\nexampleLeveragedReturnChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Predicting volatility\nTo manage or target volatility, we need to be able to predict volatility. A simple model would be to use past volatility to predict future volatility. How well does this work?\n\nLet\u0027s start by creating a dataset that has the past 22 days as a training period and the 23rd day as a test period. We\u0027ll look at how volatility the past 22 days predicts volatility on the 23rd day.\n*)\n\nlet dayWithTrailing =\n    ff3 \n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.windowed 23\n    |\u003E Seq.map(fun xs -\u003E\n        let train = xs |\u003E Array.take (xs.Length-1)\n        let test = xs |\u003E Array.last\n        train, test)\n\n(*\nOne way to do this is to look at the correlation between volatilities. What is the correlation between volatility the past 22 days (training observations) and volatility on the 23rd day (test observation)? \n\nHow do we measure volatility that last (23rd) day? You can\u0027t calculate a standard deviation of returns when there is one day. You need multiple days. But we can create a pseudo 1-day standard deviation by using the absolute value of the return that last day. \n*)\n\nopen Correlation\n\nlet trainVsTest =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train, test) -\u003E\n        let trainSd = train |\u003E Seq.stDevBy(fun x -\u003E x.MktRf)\n        let testSd = abs(test.MktRf)\n        annualizeDaily trainSd, annualizeDaily testSd)\n\n\n// Plot a sample of 1_000 points\nlet trainVsTestChart =\n    trainVsTest\n    |\u003E Seq.splitInto 1_000 // 1000 groups of train, test\n    |\u003E Seq.map Seq.head // get the observation at the start of each group\n    |\u003E Chart.Point\n   \n\n(***do-not-eval***)\ntrainVsTestChart |\u003E Chart.show\n\n(***hide***)\ntrainVsTestChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\nlet trainPdSd, testPdSd = \n    trainVsTest \n    |\u003E Seq.toList\n    |\u003E List.unzip\nSeq.pearson trainPdSd testPdSd\n\n(*** include-it ***)\n\n(*\nAnother way is to try sorting days into 5 groups based on trailing 22-day volatility. \nThen we\u0027ll see if this sorts actual realized volatility. Think of this as splitting the points in the above chart into 5 groups along the x-axis and comparing the typical x-axis value to the typical y-axis value.\n*)\n\ndayWithTrailing\n|\u003E Seq.sortBy(fun (train, _test) -\u003E train |\u003E stDevBy(fun x -\u003E x.MktRf))\n|\u003E Seq.splitInto 5\n|\u003E Seq.iter(fun xs -\u003E\n    \n    let predicted = \n        xs \n        |\u003E Array.collect fst\n        |\u003E stDevBy (fun x -\u003E x.MktRf)\n        |\u003E annualizeDaily\n    let actual = \n        xs \n        |\u003E Array.map(fun (_train, test) -\u003E test.MktRf)\n        |\u003E stDev \n        |\u003E annualizeDaily\n    printfn $\u0022N: {xs.Length}, Predicted: %.1f{predicted}, Actual: %.1f{actual}\u0022)\n\n(***include-output***)\n\n(** Even with this very simple volatility model, we seem to do a reasonable job predicting volatility. We get a decent spread.*)\n\n(**\n## Targetting volatility\nHow can we target volatility? Recall our formula for a portfolio\u0027s standard deviation if we\u0027re allocating between the risk-free asset and a risky asset:\n$$\\sigma = w_x \\sigma_x$$ \nIf we choose \n$$w_x=\\frac{\\text{target volatility}}{\\text{predicted volatility}}=\\frac{\\text{target}}{\\hat{\\sigma}_x}$$ \nthen we get\n$$\\sigma = \\frac{\\text{target}\\times \\sigma_x}{\\hat{\\sigma}_x}$$ \n\nWe\u0027re not going to predict volatility perfectly, but *if* we did then we\u0027d have a portfolio that had a constant volatility equal to our target.\n\nLet\u0027s see what happens if we try to target 15% annualized volatility.\n*)\n\ntype VolPosition =\n    { Date : DateTime \n      Return : float \n      Weight : float }\n\nlet targetted =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train,test) -\u003E \n        let predicted = train |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        let w = (15.0/predicted)\n        { Date = test.Date\n          Return = test.MktRf * w \n          Weight = w })\n\nlet targettedSince2019 = \n    targetted\n    |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2019,1,1) )\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_, xs) -\u003E \n        xs |\u003E Seq.map(fun x -\u003E x.Date) |\u003E Seq.max,\n        xs |\u003E stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily) \n    |\u003E volChart \n    |\u003E Chart.withTraceInfo(Name=\u0022Managed\u0022)\nlet rawSince2019 =\n    monthlyVol\n    |\u003E Seq.filter(fun (dt,_) -\u003E dt \u003E= DateTime(2019,1,1))\n    |\u003E volChart\n    |\u003E Chart.withTraceInfo(Name=\u0022Unmangaged\u0022)\n\nlet weightsSince2019 = \n    targetted\n    |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2019,1,1) )\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_, xs) -\u003E \n        xs |\u003E Seq.map(fun x -\u003E x.Date) |\u003E Seq.max,\n        xs |\u003E Seq.averageBy(fun x -\u003E x.Weight))\n    |\u003E Chart.Line \n    |\u003E Chart.withTraceInfo(Name=\u0022weight on the Market\u0022)\n\nlet volComparison = \n    [ targettedSince2019; rawSince2019]\n    |\u003E Chart.combine\n\nlet volComparisonWithWeights =\n    [volComparison; weightsSince2019 ]\n    |\u003E Chart.SingleStack()\n\n\n(***do-not-eval***)\nvolComparisonWithWeights |\u003E Chart.show\n\n(***hide***)\nvolComparisonWithWeights |\u003E GenericChart.toChartHTML\n(***include-it-raw***) \n\n(** We can see that in this example, \n\n- Volatility still moves around with our managed portfolio. We haven\u0027t targetted a 15\\% volatility perfectly. \n- We do avoid some of the extreme volatilities from 2020, particularly in March and April.\n- The weight we put on the market varies quite (implies lots of trading) and goes as high as 2 (lots of leverage). *)\n\n(**\n## Evaluating performance.\n\nLet\u0027s now compare buy and hold to our managed volatility strategy. \n\nFor the managed portfolio, we\u0027ll also impose the constraint that the investor cannot borrow more than 30% of their equity (i.e, max weight = 1.3).\n\nWe start by defining functions to calculate the weights. In the managed weights, we set the numerator so that we\u0027re targetting the full-sample standard deviation of the market.\n*)\n\nlet leverageLimit = 1.3\n\nlet sampleStdDev = \n    dayWithTrailing \n    |\u003E Seq.stDevBy(fun (train, test) -\u003E test.MktRf)\n    |\u003E annualizeDaily\n\nlet buyHoldWeight predictedStdDev = 1.0\n\nlet inverseStdDevWeight predictedStdDev = \n    min (sampleStdDev / predictedStdDev) leverageLimit\n\nlet inverseStdDevNoLeverageLimit predictedStdDev = \n    sampleStdDev / predictedStdDev\n\n\nlet getManaged weightFun =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train,test) -\u003E \n        let predicted = train |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        let w = weightFun predicted\n        { Date = test.Date\n          Return = test.MktRf * w \n          Weight = w })\n    |\u003E fun xs -\u003E // Rescale to have same realized SD for\n                 // more interpretable graphs. \n                 // Does not affect sharpe ratio\n        let sd = xs |\u003E stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily\n        xs |\u003E Seq.map(fun x -\u003E { x with Return = x.Return * (sampleStdDev/sd)})\n\nlet accVolPortReturn (port: seq\u003CVolPosition\u003E) =\n    let mapper acc (x : VolPosition) =\n        let outAcc = acc * (1.0\u002Bx.Return)\n        { x with Return = outAcc }, outAcc\n    (1.0, port)\n    ||\u003E Seq.mapFold mapper \n    |\u003E fst\n\nlet portChart name port  = \n    port \n    |\u003E Seq.map(fun x -\u003E x.Date, x.Return)\n    |\u003E Chart.Line\n    |\u003E Chart.withTraceInfo(Name=name)\n    |\u003E Chart.withYAxis (LayoutObjects.LinearAxis.init(AxisType = StyleParam.AxisType.Log))\n\n    \nlet buyHoldMktPort = getManaged buyHoldWeight \nlet managedMktPort = getManaged inverseStdDevWeight\nlet managedMktPortNoLimit = getManaged inverseStdDevNoLeverageLimit \n\nlet bhVsManagedChart =\n    Chart.combine(\n        [ buyHoldMktPort |\u003E accVolPortReturn |\u003E (portChart \u0022Buy-Hold\u0022)\n          managedMktPort |\u003E accVolPortReturn |\u003E (portChart \u0022Managed Vol\u0022)\n          managedMktPortNoLimit |\u003E accVolPortReturn |\u003E (portChart \u0022Managed Vol No Limit\u0022)\n          ])\n\n(***do-not-eval***)\nbhVsManagedChart |\u003E Chart.show\n\n(***hide***)\nbhVsManagedChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n[ buyHoldMktPort, \u0022Buy-Hold Mkt\u0022\n  managedMktPort, \u0022Managed Vol Mkt\u0022\n  managedMktPortNoLimit, \u0022Manage Vol No Limit\u0022]\n|\u003E Seq.iter(fun (x, name) -\u003E \n    let mu = \n        x \n        |\u003E Seq.averageBy(fun x -\u003E x.Return) \n        |\u003E fun x -\u003E round 2 (100.0*252.0*x)\n    let sd = x |\u003E Seq.stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily\n    printfn $\u0022Name: %25s{name} Mean: %.2f{mu} SD: %.2f{sd} Sharpe: %.3f{round 3 (mu/sd)}\u0022)\n(***include-output***)\n\n(**\n## Things to consider\n\n- What\u0027s a reasonable level of volatility to target?\n- What\u0027s a reasonable level of leverage, and what should we think about when leveraging a portfolio that has low recent volatility?\n- What happens if expected returns go up when volatility is high?\n- How do we decide on what risky portfolio to invest in?\n*)\n\n              "},{"uri":"/Teaching/YahooFinance.html","title":"YahooFinance","content":"(**\n[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\n\nBased on code from https://github.com/aexsalomao/YahooFinance/\n*)\n\n#r \u0022nuget: FSharp.Data\u0022\n\nopen System\nopen FSharp.Data\n\ntype Interval = \n    | Daily\n    | Weekly\n    | Monthly\n    override this.ToString() = \n        match this with\n        | Daily -\u003E \u00221d\u0022\n        | Weekly -\u003E \u00221wk\u0022\n        | Monthly -\u003E \u00221mo\u0022\n\ntype PriceObs = \n    { Symbol : string\n      Date : DateTime\n      Open : float\n      High : float\n      Low : float\n      Close : float\n      AdjustedClose : float\n      Volume : float }\n\ntype private PriceObsCsv = CsvProvider\u003CSample=\u0022Date (date),Open (float),High (float),Low (float), Close (float),AdjClose (float),Volume (float)\u0022\u003E\nlet private parseYahooPriceHistory symbol result = \n    PriceObsCsv.Parse(result).Rows\n    |\u003E Seq.map (fun x -\u003E \n        { Symbol = symbol \n          Date = x.Date\n          Open = x.Open\n          High = x.High\n          Low = x.Low\n          Close = x.Close \n          AdjustedClose = x.AdjClose\n          Volume = x.Volume })\n    |\u003E Seq.toArray\n\n\nlet private cc = System.Net.CookieContainer()\nlet private retryCount = 5\nlet private parallelSymbols = 5\n\ntype YahooFinance =\n    static member PriceHistory(symbols: seq\u003Cstring\u003E,?startDate: DateTime,?endDate: DateTime,?interval: Interval) =\n        let symbols = Seq.toList symbols\n        let startDate = defaultArg startDate (DateTime.Now.AddYears(-1))\n        let endDate = defaultArg endDate (DateTime.Now)\n        let interval = defaultArg interval Interval.Monthly\n\n        let generateYahooUrl (symbol: string) (startDate: DateTime) (endDate: DateTime) (interval: Interval) =\n            let time dt = DateTimeOffset(dt).ToUnixTimeSeconds()\n            $\u0022https://query1.finance.yahoo.com/v7/finance/download/{symbol}?\u0022 \u002B\n            $\u0022period1={time startDate}\u0026period2={time endDate}\u0026interval={interval}\u0022 \u002B\n            $\u0022\u0026events=history\u0026includeAdjustedClose=true\u0022\n        \n        let rec yahooRequest attempt symbol =\n            async {\n                let url = generateYahooUrl symbol startDate endDate interval\n                try\n                    let! result = \n                        Http.AsyncRequestString(\n                            url = url, \n                            httpMethod = \u0022GET\u0022,\n                            query = [\u0022format\u0022,\u0022csv\u0022],\n                            headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv],\n                            cookieContainer = cc)\n                    return parseYahooPriceHistory symbol result\n                with e -\u003E\n                    if attempt \u003E 0 then\n                        return! yahooRequest (attempt - 1) symbol\n                    else return! failwith $\u0022Failed to request {symbol}, Error: {e}\u0022\n            }\n        let rec getSymbols (symbols: list\u003Cstring\u003E) output parallelSymbols =\n            let download thisDownload =\n                [| for symbol in thisDownload do \n                    yahooRequest retryCount symbol |]\n                |\u003E Async.Parallel\n                |\u003E Async.RunSynchronously\n                |\u003E Array.collect id\n                |\u003E Array.toList\n\n            if symbols.Length \u003E parallelSymbols then\n                let thisDownload, remaining = symbols |\u003E List.splitAt parallelSymbols\n                let result = download thisDownload\n                System.Threading.Thread.Sleep(1000) // Throttle 1 sec per batch of symbols\n                getSymbols remaining (result @ output) parallelSymbols\n            else\n                let result = download symbols\n                result @ output\n        getSymbols symbols [] parallelSymbols                \n    static member PriceHistory(symbol: string,?startDate: DateTime,?endDate: DateTime,?interval: Interval) =\n        YahooFinance.PriceHistory(symbols=[symbol],?startDate=startDate,?endDate=endDate,?interval=interval)\n"},{"uri":"/Teaching/quizzes/discriminatedUnion-practiceQuiz.html","title":"Dicriminated Union","content":"(**\n---\ntitle: Dicriminated Union\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 5\n---\n*)\n\n(*** hide ***)\n/// example fast binder url: https://mybinder.org/v2/gh/fsprojects/fsharp.formatting/master?urlpath=git-pull?repo=https:/nhirschey.github.com/teaching/gh-pages/fundamentals.ipynb\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(** \n\nThis practice quiz emphasizes \u0060Discriminated Unions\u0060. They are useful for times when the data that you\u0027re representing has multiple mutually exclusive cases. \n\nHere is some good background reading for before you do these quesitions, particularly the F# for fun and profit link.\n\n- Discriminated Union types\n\n    - The F# language reference for [discriminated unions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions)\n    - If you want more a more in depth discussion, see F# for fun and profit\u0027s section on [discriminated unions](https://fsharpforfunandprofit.com/posts/discriminated-unions/)\n    - The tour of F# section on [discriminated unions](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#record-and-discriminated-union-types)\n\n*)\n\n(**\n## Question 1\nCreate a discriminated union named \u0060Action\u0060 with two cases: Buy and Sell.\n\n1. Create a value named \u0027bAction\u0027 and assign \u0060Buy\u0060 to it.\n2. Create a value named \u0027sAction\u0027 and assign \u0060Sell\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: createBuySell, define-output: createBuySell ***)\n\ntype Action = \n    | Buy \n    | Sell\nlet bAction = Buy\nlet sAction = Sell\n\n(*** condition:html, include:createBuySell ***)\n(*** condition:html, include-fsi-output:createBuySell ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a single case discriminated union to represent a particular kind of string:\n\n1. Create a discriminated union named Ticker with a single case Ticker of string. \n2. Then wrap the string \u0022ABC\u0022 in your Ticker type and assign it to a value named \u0027aTicker\u0027.\n3. Then use pattern matching to unwrap the string in \u0060aTicker\u0060 and assign it to a value named \u0060aTickerString\u0060.\n\nDiscriminated unions like this are usful if you want to make \nsure that you don\u0027t accidentally mix up two strings that represent\ndifferent things.\nA function that takes an input with type \u0060Ticker\u0060 will not accept any string,\nit will only accept inputs that have time Ticker.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: singleString, define-output: singleString ***)\n\ntype Ticker = Ticker of string\nlet aTicker = Ticker \u0022ABC\u0022\nlet (Ticker aTickerString) = aTicker\n\n(*** condition:html, include:singleString ***)\n(*** condition:html, include-fsi-output:singleString ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a single case discriminated union to represent a particular kind of float:\n\n1. Create a discriminated union named Signal with a single case Signal of float. \n2. Then wrap the string float \u00601.0\u0060 in your Signal type and assign it to a value named \u0027aSignal\u0027.\n3. Then use pattern matching to unwrap the float in \u0060aSignal\u0060 and assign it to a value named \u0060aSignalFloat\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: singleFloat, define-output: singleFloat ***)\n\ntype Signal = Signal of float\nlet aSignal = Signal 1.2\nlet (Signal aSignalFloat) = aSignal\n\n(*** condition:html, include:singleFloat ***)\n(*** condition:html, include-fsi-output:singleFloat ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nCreate a discriminated union called called \u0060Funds\u0060 with two cases: MutualFund of string and HedgeFund of string.\n\n1. Create a MutualFund case of the Fund union with the string \u0022Fidelity Magellan\u0022. Assign it to a value named \u0022magellan\u0022.\n2. Create a HedgeFund case of the Fund union with the string \u0022Renaissance Medallion\u0022. Assign it to a value named \u0022renaissance\u0022.\n\n*)  \n\n(*** include-it-raw:preDetails ***)\n(*** define: twoCaseString, define-output: twoCaseString ***)\n\ntype Funds =\n    | MutualFund of string\n    | HedgeFund of string\n\nlet magellan = MutualFund \u0022Fidelity Magellan\u0022\nlet renaissance = HedgeFund \u0022Renaissance Medallion\u0022\n\n(*** condition:html, include:twoCaseString ***)\n(*** condition:html, include-fsi-output:twoCaseString ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nDefine two types with the same cases.\n\n\u0060\u0060\u0060fsharp\ntype Ambiguous1 = Up | Down\ntype Ambiguous2 = Up | Down\n\u0060\u0060\u0060\nIf you try to assign Ambiguous1 to values, \nit can be hard for the compiler (and yourself)\nto figure out which of these types you mean. If you write \u0060Up\u0060\nthe compiler will think that you meant to use whatever was defined\nlast (Ambigous2).\n\nUse fully qualified names to show how to assign the \u0060Up\u0060 case from Ambiguous1 to\na value named \u0060ambiguous1\u0060 and the \u0060Up\u0060 case from Ambiguous2 to a value named\n\u0060ambiguous2\u0060. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: clarifyAmbiguity, define-output: clarifyAmbiguity ***)\n\ntype Ambiguous1 = Up | Down\ntype Ambiguous2 = Up | Down\nlet ambiguous1 = Ambiguous1.Up\nlet ambiguous2 = Ambiguous2.Up\n\n(*** condition:html, include:clarifyAmbiguity ***)\n(*** condition:html, include-fsi-output:clarifyAmbiguity ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nImagine that analyst recommendations have the form\n\u0060\u0060\u0060fsharp\ntype AnalystRec = Buy | Sell | Hold\n\u0060\u0060\u0060\nYou have recommendations from two analysts\n\u0060\u0060\u0060fsharp\nlet goldmanRec = Buy\nlet barclaysRec = Sell\n\u0060\u0060\u0060\nYou want to act on goldman recommendations as follows:\n\u0060\u0060\u0060fsharp\nlet actionOnGoldman (x: AnalystRec) =\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\n\u0060\u0060\u0060\n\nThe problem is that this \u0060actionOnGoldman\u0060 function will\nwork for both \u0060goldmanRec\u0060 and \u0060barclaysRec\u0060.\n\u0060\u0060\u0060fsharp\nactionOnGoldman goldmanRec // evaluates to \u0022I am buying this!\u0022\nactionOnGoldman barclaysRec // evaluates to \u0022I am selling this!\u0022\n\u0060\u0060\u0060\n\n1. Create a single case union called \u0060GoldmanRec\u0060 where the single case\nis GoldmanRec of AnalystRec. \n2. Create a modified \u0060actionOnGoldman\u0060 function called \u0060actionOnGoldmanOnly\u0060 so that it will only work on recommendations with the type \u0060GoldmanRec\u0060.\n\nIf \u0060wrappedGoldmanRec\u0060 is buy \u0060GoldmanRec\u0060, the result should be\n\u0060\u0060\u0060\nactionOnGoldmanOnly wrappedGoldmanRec // evaluates to \u0022I am buying this!\u0022\nactionOnGoldmanOnly barclaysRec // compiler error.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: funForSingleCase, define-output: funForSingleCase ***)\n\ntype AnalystRec = Buy | Sell | Hold\ntype GoldmanRec = GoldmanRec of AnalystRec\nlet goldmanRec = Buy\nlet barclaysRec = Sell\nlet actionOnGoldman (x: AnalystRec) =\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\nactionOnGoldman goldmanRec // what we want.\nactionOnGoldman barclaysRec // oops.\n// constructing it from scratch.\nlet wrappedGoldmanRec = GoldmanRec Buy\n// or, wrapping our previously created value\nlet wrappedGoldmanRec2 = GoldmanRec goldmanRec\nwrappedGoldmanRec = wrappedGoldmanRec2 // true\n// constructing it from scratch\nlet actionOnGoldmanOnly (x: GoldmanRec) =\n    match x with\n    | GoldmanRec Buy | GoldmanRec Hold -\u003E \u0022I am buying this!\u0022\n    | GoldmanRec Sell -\u003E \u0022I am selling this!\u0022\n// or, unwrapping the GoldmanRec with pattern matching\n// in the input definition:\nlet actionOnGoldmanOnly2 (GoldmanRec x) =\n    // Since we unwrapped the goldman recommendation,\n    // now it is just the inner analyst recommendation.\n    // We can leave off the GoldmanRec that was wrapping the\n    // recomendation.\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\n// or, since you see above that once we unwrap the goldman rec,\n// it is the same as our orignal function.\nlet actionOnGoldmanOnly3 (GoldmanRec x) = actionOnGoldman x\n\n// check\nactionOnGoldmanOnly wrappedGoldmanRec\nactionOnGoldmanOnly2 wrappedGoldmanRec\nactionOnGoldmanOnly3 wrappedGoldmanRec\n// These would all give compiler errors. \n// Uncomment them (delete the // at the start) to test them yourself.\n//actionOnGoldmanOnly barclaysRec\n//actionOnGoldmanOnly2 barclaysRec\n//actionOnGoldmanOnly3 barclaysRec\n\n(*** condition:html, include:funForSingleCase ***)\n(*** condition:html, include-fsi-output:funForSingleCase ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nImagine that stock tips have the form\n\u0060\u0060\u0060fsharp\ntype StockTip = Buy | Sell | Hold\n\u0060\u0060\u0060\nYou have recommendations from two people\n\u0060\u0060\u0060fsharp\nlet friendRec = Buy\nlet professorRec = Sell\n\u0060\u0060\u0060\nYou want to actions as follows:\n\u0060\u0060\u0060fsharp\nlet actionOnFriend (x: StockTip) = x\nlet actionOnProfessor (x: StockTip) =\n    match x with\n    | Buy -\u003E StockTip.Sell\n    | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\n\u0060\u0060\u0060\n\n1. Create a two case union called \u0060FriendOrFoe\u0060 where the two cases are Friend of StockTip and Professor of StockTip.\n2. Create a function called \u0060actionFriendOrFoe\u0060 that will properly handle tips from friends and tips from professors.\n\nShow that \u0060friendRec\u0060 and \u0060professorRec\u0060 wrapped in the \u0060FriendOrFoe\u0060 type are handled properly by \u0060actionFriendOrFoe\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: funForTwoCases, define-output: funForTwoCases ***)\n\ntype StockTip = Buy | Sell | Hold\nlet friendRec = Buy\nlet professorRec = Sell\nlet actionOnFriend (x: StockTip) = x\nlet actionOnProfessor (x: StockTip) =\n    match x with\n    | Buy -\u003E StockTip.Sell\n    | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\n// or, since we\u0027re doing the same thing with a professor\u0027s\n// Buy or Hold recommendation, this could also be written\nlet actionOnProfessor2 (x: StockTip) =\n    match x with\n    | Buy | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\ntype FriendOrFoe = \n    | Friend of StockTip\n    | Professor of StockTip\nlet wrappedFriendRec = Friend friendRec\nlet wrappedProfessorRec = Professor professorRec\nlet actionOnFriendOrFoe (x: FriendOrFoe) =\n    match x with\n    | Friend tip -\u003E actionOnFriend tip\n    | Professor tip -\u003E actionOnProfessor tip \nactionOnFriendOrFoe wrappedFriendRec // evaluates to Buy\nactionOnFriendOrFoe wrappedProfessorRec // evaluates to Buy\nactionOnFriendOrFoe (Professor Hold) // evaluates to Sell\n\n(*** condition:html, include:funForTwoCases ***)\n(*** condition:html, include-fsi-output:funForTwoCases ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/quizzes/factors-practiceQuiz.html","title":"Factors","content":"(**\n---\ntitle: Factors\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 7\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nOn moodle, there is a set of investment lecture notes called \u0022Finance Review\u0022. \nPlease review the Lecture-08-APT.pdf document, including the appendix. \n\nIn particular,\n\n- What do we mean by a factor?\n- The example showing how to hedge Barrick with GLD and SPY.\n- Information ratios.\n\n*)\n\n(**\nImagine you have the below returns for IBM and SPY. \nIBM\u0027s factor beta on SPY and the (constant)\nrisk-free rate are given below too.\n*)\n\ntype ReturnOb = { Time: int; Return : float }\nlet ibm =\n    [| \n        { Time = 0; Return = 0.15 }\n        { Time = 1; Return = 0.05 }\n        { Time = 2; Return = 0.01 }\n    |]\n\nlet spy =\n    [| \n        { Time = 0; Return = 0.1 }\n        { Time = 1; Return = 0.05 }\n        { Time = 2; Return = -0.02 }\n    |]    \n\nlet riskFreeRate = 0.001\nlet ibmBetaOnSpy = 1.2    \n\n\n(**\n## Question 1\nWhat are the weights on the risk-free asset and\nSPY in the portfolio that hedges IBM\u0027s exposure to\nSPY? \n\n1. Report the weight on the risk-free asset as a value named \u0060wRf\u0060 of type \u0060float\u0060. \n2. Report the weight on the SPY portfolio as a value named \u0060wSpy\u0060 of type \u0060float\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: WeightsHedgePort, define-output: WeightsHedgePort ***)\n\nlet wSpy = ibmBetaOnSpy\nlet wRf = 1.0-wSpy\n\n(*** condition:html, include:WeightsHedgePort ***)\n(*** condition:html, include-fsi-output:WeightsHedgePort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nWhat are the returns for Times [0;1;2] on the portfolio \nthat hedges IBM\u0027s factor exposure to SPY? \n\n1. Report results as a value named \u0060hedgePortReturns\u0060 of type \u0060ReturnOb array\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ReturnsHedgePort, define-output: ReturnsHedgePort ***)\n\nlet hedgePortReturns =\n    spy\n    |\u003E Array.map(fun spy -\u003E\n        { Time = spy.Time \n          Return = wSpy*spy.Return \u002B wRf*riskFreeRate })\n\n(*** condition:html, include:ReturnsHedgePort ***)\n(*** condition:html, include-fsi-output:ReturnsHedgePort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCall the portfolio that hedges IBM\u0027s factor exposure to SPY\nthe hedge portfolio. What is the hedge portfolio\u0027s factor beta\non SPY? \n\n1. Report the answer as a value named \u0060hedgePortBetaOnSpy\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: BetaSPYHedgePort, define-output: BetaSPYHedgePort ***)\n\n// 3. Hedge portfolio\u0027s factor beta on SPY\n// See the lecture notes for a fuller explanation:\n//\n// From the portfolio return equation, the\n// hedge portfolio return is\n// r_hedgePort = wRf * rf \u002B wSpy * Spy\n// =\u003E\n// r_hedgePort - rf = (wSpy \u002B wRf - 1) * rf \u002B wSpy*(Spy -rf)\n// r_hedgePort - rf = wSpy*(Spy - rf)\n// So the beta is\nlet hedgePortBetaOnSpy = ibmBetaOnSpy \n\n(*** condition:html, include:BetaSPYHedgePort ***)\n(*** condition:html, include-fsi-output:BetaSPYHedgePort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nWhat are the returns for Times [0;1;2] on the portfolio\nthat is long IBM and short the portfolio that hedges\nIBM\u0027s factor exposre to SPY?\n\n1. Report results as a value named \u0060longShortPortReturns\u0060 of type \u0060ReturnOb array\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: LongShortIBMRet, define-output: LongShortIBMRet ***)\n\nlet hedgePortMap =\n    // using map because it\u0027s efficient for lookups.\n    // you could use filter with such a small collection,\n    // but we\u0027ll use a Map collection so that we\n    // practice like it\u0027s the real thing.\n    hedgePortReturns\n    |\u003E Array.map(fun x -\u003E x.Time, x)\n    |\u003E Map.ofArray\n\nlet longShortPortReturns =\n    ibm\n    |\u003E Array.choose(fun ibmOb -\u003E\n        // We\u0027re using Array.choose instead of Array.map\n        // because we plan to return Some hedgeOb or None, and we\n        // want to throw away all the None cases and return just\n        // an array of the valid hedgeObs. \n        let matchingHedgeReturn = Map.tryFind ibmOb.Time hedgePortMap\n        // in this example matchingHedgeReturn will always be Some hedgeOb.\n        // But, we\u0027re using Map.tryFind and dealing with the possibility\n        // that None could happen because it\u0027s good to practice\n        // as if this were real code where bad things could happen.\n        match matchingHedgeReturn with\n        | None -\u003E None // if there\u0027s no hedge return for ibmOb.Time return None\n        | Some hedgeOb -\u003E \n            // if there is a matching hedge return for ibmOb.Time return Some ReturnOb\n            let longShort =  ibmOb.Return - hedgeOb.Return\n            Some { Time = ibmOb.Time; Return = longShort })\n\n(*** condition:html, include:LongShortIBMRet ***)\n(*** condition:html, include-fsi-output:LongShortIBMRet ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nWhat is the alpha of IBM from the perspective of \na factor model that uses SPY as the only risk factor? \n\n1. Report the result as a value named \u0060alpha\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: Alpha, define-output: Alpha ***)\n\nlet alpha = \n    longShortPortReturns \n    |\u003E Array.averageBy(fun x -\u003E x.Return)\n\n(*** condition:html, include:Alpha ***)\n(*** condition:html, include-fsi-output:Alpha ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nWhat is the information ratio of IBM from the perspective\nof a factor model that uses SPY as the only risk factor?\n\n1. Report the result as a value named \u0060io\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: IO, define-output: IO ***)\n\n#r \u0022nuget: FSharp.Stats\u0022\nopen FSharp.Stats\n\nlet sdHedgeReturns =\n    longShortPortReturns\n    |\u003E Array.map(fun x -\u003E x.Return )\n    |\u003E Seq.stDev\n\n// Intuitively, you can think of it similar\n// to the sharpe ratio of the portfolio after\n// hedging out the factor risk.\n\nlet io = alpha / sdHedgeReturns\n\n(*** condition:html, include:IO ***)\n(*** condition:html, include-fsi-output:IO ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/quizzes/fundamentals-PracticeQuiz.html","title":"Fundamentals","content":"(**\n---\ntitle: Fundamentals\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n## Question 1\nCalculate \u00603.0\u0060 to the power of \u00604.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: threePowerFour, define-output: threePowerFour ***)\n\n3.0 ** 4.0\n\n(*** condition:html, include:threePowerFour ***)\n(*** condition:html, include-fsi-output:threePowerFour ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nAssign the integer \u00601\u0060 to a value called \u0060a\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: Assign1toA, define-output: Assign1toA ***)\n\nlet a = 1\n\n(*** condition:html, include:Assign1toA ***)\n(*** condition:html, include-fsi-output:Assign1toA ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nWrite a function named \u0060add3\u0060 that adds \u00603.0\u0060 to any \u0060float\u0060 input.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: add3Function, define-output: add3Function ***)\n\nlet add3 x = x \u002B 3.0\n\n(*** condition:html, include:add3Function ***)\n(*** condition:html, include-fsi-output:add3Function ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven a tuple \u0060(1.0,2.0)\u0060, assign the second element to a value named \u0060b\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: assignSndTob, define-output: assignSndTob ***)\nlet b = snd (1.0, 2.0)\n(*** condition:html, include: assignSndTob ***)\n(*** condition:html, include-fsi-output: assignSndTob ***)\n\n(**\nor\n*)\n\n(*** define: assignSndTob1, define-output: assignSndTob1 ***)\nlet (_, b1) = (1.0, 2.0)\n(*** condition:html, include: assignSndTob1 ***)\n(*** condition:html, include-fsi-output: assignSndTob1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nCreate a tuple where the first, second, and third elements are \u0060\u0022a\u0022\u0060, \u00601\u0060, and \u00602.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: createTuple, define-output: createTuple ***)\n\n(\u0022a\u0022, 1, 2.0)\n\n(*** condition:html, include:createTuple ***)\n(*** condition:html, include-fsi-output:createTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nDefine a record type named \u0060Record1\u0060 that has a \u0060string\u0060 \u0060Id\u0060 field and a \u0060float Y\u0060 field.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: RecordType1, define-output: RecordType1 ***)\n\ntype Record1 = { Id : string; Y : float }\n\n(*** condition:html, include:RecordType1 ***)\n(*** condition:html, include-fsi-output:RecordType1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven the type signature \u0060val a : float = 2.0\u0060, what is the type of value a? \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(** \nfloat\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your answer here, see website for solution.\n\n\n(**\n## Question 8\nCreate a record type named \u0060Record2\u0060. It should have two integer fields \u0060X\u0060 and \u0060Y\u0060. Create an instance of the record where \u0060X = 4\u0060 and \u0060Y = 2\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: RecordType2, define-output: RecordType2 ***)\n\ntype Record2 = { X : int; Y : int }\n{ X = 4; Y = 2}\n\n(*** condition:html, include:RecordType2 ***)\n(*** condition:html, include-fsi-output:RecordType2 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 9\nExplain why this expression gives an error when you try to run it: \u00604 \u002B 7.0\u0060 \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\n\nBecause 4 is an integer and 7.0 is a float. Addition is defined on values with the same type.\nThe two values need to either both be integers or both be floats.\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your answer here, see website for solution.\n\n\n(**\n## Question 10\nCreate an \u0060array\u0060 where the elements are \u00601\u0060, \u00602\u0060, and \u00603\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: array, define-output: array ***)\n[| 1; 2; 3 |]\n(*** condition:html, include: array ***)\n(*** condition:html, include-fsi-output: array ***)\n\n(**\nor\n*)\n\n(*** define: array1, define-output: array1 ***)\n[| 1 .. 3 |]\n(*** condition:html, include: array1 ***)\n(*** condition:html, include-fsi-output: array1 ***)\n\n(**\nor\n*)\n\n(*** define: array2, define-output: array2 ***)\n[| for i = 1 to 3 do i |]\n(*** condition:html, include: array2 ***)\n(*** condition:html, include-fsi-output: array2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 11\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Pass it to \u0060List.map\u0060 and use an anonymous function to divide each number by \u00603.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: List1, define-output: List1 ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.map (fun x -\u003E x / 3.0)\n\n(*** condition:html, include:List1 ***)\n(*** condition:html, include-fsi-output:List1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 12\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Group the elements based on whether the elements are greater than or equal to \u00604.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listGroupBy, define-output: listGroupBy ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.groupBy (fun x -\u003E x \u003E= 4.0)\n\n(*** condition:html, include:listGroupBy ***)\n(*** condition:html, include-fsi-output:listGroupBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 13\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Filter it so that you are left with the elements \u0060\u003E 5.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listFilter, define-output: listFilter ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.filter (fun x -\u003E x \u003E 5.0)\n\n(*** condition:html, include:listFilter ***)\n(*** condition:html, include-fsi-output:listFilter ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 14\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Use \u0060List.groupBy\u0060 to group the elements based on if they\u0027re \u0060\u003E= 5.0\u0060. Then use \u0060List.map\u0060 to get the maxiumum element that is \u0060\u003C 5.0\u0060 and the minimum value that is \u0060\u003E= 5.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listGroupMaxAndMin, define-output: listGroupMaxAndMin ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.groupBy(fun x -\u003E x \u003E= 5.0)\n|\u003E List.map(fun (gt5, xs) -\u003E \n    if gt5 then List.min xs else List.max xs)\n\n(*** condition:html, include:listGroupMaxAndMin ***)\n(*** condition:html, include-fsi-output:listGroupMaxAndMin ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 15\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Use functions from the List module to sort it in descending order. Then take the 3rd element of the reversed list and add \u00607.0\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listSort, define-output: listSort ***)\n\n[1.0 .. 10.0]\n|\u003E List.sortByDescending id\n|\u003E List.item 2\n|\u003E fun x -\u003E x \u002B 7.0\n\n\n(*** condition:html, include:listSort ***)\n(*** condition:html, include-fsi-output:listSort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n"},{"uri":"/Teaching/quizzes/Option-Match-Map-practiceQuiz.html","title":"Option Match Map","content":"(**\n---\ntitle: Option Match Map\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 4\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nThis practice quiz emphasizes \u0060Optional types\u0060, \u0060Match expressions\u0060, and \u0060Map Collections\u0060. These are some features that we will use in building a portfolio.\n\nHere are some references to these topics. Please read the F# language reference links before proceeding with the questions. The other links (F# tour and F# for fun and profit) provide additional background and examples but are not necessary:\n\n- Option types\n\n    - The F# language reference for [options](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options)\n    - The tour of F# section on [options](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#optional-types)\n    - If you want more a more in depth discussion, see F# for fun and profit\u0027s section on [options](https://fsharpforfunandprofit.com/posts/the-option-type/)\n\n- Pattern matching using match expressions.\n\n    - [F# Language reference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/match-expressions)\n    - [Tour of F#](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#pattern-matching)\n    - [F# for fun and profit](https://fsharpforfunandprofit.com/posts/match-expression/)\n\n- Map collections.\n\n    - [F# Wikibook](https://en.wikibooks.org/wiki/F_Sharp_Programming/Sets_and_Maps#Maps)\n\n*)\n\n(**\n# Options\n*)\n\n(**\n## Question 1\nCreate a value named \u0060a\u0060 and assign \u0060Some 4\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: aSome4, define-output: aSome4 ***)\n\nlet a = Some 4\n\n(*** condition:html, include:aSome4 ***)\n(*** condition:html, include-fsi-output:aSome4 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a value name \u0060b\u0060 and assign \u0060None\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: bNone, define-output: bNone ***)\n\nlet b = None\n\n(*** condition:html, include:bNone ***)\n(*** condition:html, include-fsi-output:bNone ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a tuple named \u0060c\u0060 and assign \u0060(Some 4, None)\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: cSome4None, define-output: cSome4None ***)\n\nlet c = Some 4, None\n\n(*** condition:html, include:cSome4None ***)\n(*** condition:html, include-fsi-output:cSome4None ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nWrite a function named d that takes \u0060x: float\u0060 as an input and outputs\n\u0060Some x\u0060 if x \u003C 0 and \u0060None\u0060 if x \u003E= 0. Test it by mapping each element of\n\u0060[0.0; 1.4; -7.0]\u0060 by function d.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: dFunction, define-output: dFunction ***)\nlet d (x: float) = if x \u003C 0.0 then Some x else None\n[0.0; 1.4;-7.0] |\u003E List.map d\n(*** condition:html, include:dFunction ***)\n(*** condition:html, include-fsi-output:dFunction ***)\n\n(**\nor, we don\u0027t actually have to tell it that \u0060x\u0060 is a \u0060float\u0060\nbecause type inference can tell that \u0060x\u0060 must be a \u0060float\u0060\nbecause the function does \u0060x \u003C 0.0\u0060 and \u00600.0\u0060 is a \u0060float\u0060.\n*)\n\n(*** define: dFunction1, define-output: dFunction1 ***)\nlet d2 x = if x \u003C 0.0 then Some x else None\n[0.0; 1.4;-7.0] |\u003E List.map d2\n(*** condition:html, include:dFunction1 ***)\n(*** condition:html, include-fsi-output:dFunction1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nConsider this array of trading days for a stock and it\u0027s price and dividends:\n*)\n\ntype StockDays = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]   \n\n(**\n1. create a new array called \u0060stockDaysWithDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days with dividends. \n2. Then create an array called \u0060stockDaysWithoutDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days that do not have dividends.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: stockDayswithDividends, define-output: stockDayswithDividends ***)\nlet stockDaysWithDivideds =\n    stockDays\n    |\u003E Array.filter(fun day -\u003E \n        // variable names are arbitrary, but it\u0027s helpful to use\n        // meaningful names like \u0022day\u0022 if the record that our\n        // function is operating on represents a day.\n        // using a variable named day to represent the day record\n        day.Dividend.IsSome)\n(*** condition:html, include:stockDayswithDividends ***)\n(*** condition:html, include-fsi-output:stockDayswithDividends ***)\n\n(*** define: stockDayswithDividends1, define-output: stockDayswithDividends1 ***)\nlet stockDaysWithoutDividends =\n    stockDays\n    |\u003E Array.filter(fun x -\u003E \n        // using a variable named x to represent the day record.\n        // less clear by looking at this code that x is a day.\n        x.Dividend.IsNone)\n(*** condition:html, include:stockDayswithDividends1 ***)\n(*** condition:html, include-fsi-output:stockDayswithDividends1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nConsider the value \u0060let nestedOption = (Some (Some 4))\u0060. Pipe\nit to \u0060Option.flatten\u0060 so that you are left with \u0060Some 4\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: nestedOption, define-output: nestedOption ***)\n\nlet nestedOption = (Some (Some 4))\nnestedOption |\u003E Option.flatten\n// this would also work, but doesn\u0027t use a pipe\nOption.flatten nestedOption\n\n(*** condition:html, include:nestedOption ***)\n(*** condition:html, include-fsi-output:nestedOption ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nConsider this list \u0060let listOfNestedOptions = [(Some (Some 4)); Some (None); None]\u0060.\nShow how to transform it into \u0060[Some 4; None; None]\u0060 by mapping a function to each\nelement of the list. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listOfNestedOptions, define-output: listOfNestedOptions ***)\n\nlet listOfNestedOptions = [(Some (Some 4)); Some (None); None]\n// map the function Option.flatten to each element of the list\nlistOfNestedOptions |\u003E List.map Option.flatten\n\n\n(*** condition:html, include:listOfNestedOptions ***)\n(*** condition:html, include-fsi-output:listOfNestedOptions ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Match Expressions\n*)\n\n(**\n## Question 1\nWrite a function named \u0060ma\u0060 that takes \u0060x: float Option\u0060 as an input.\nUse a match expression to output the \u0060float\u0060 if \u0060x\u0060 is something and\n\u00600.0\u0060 if the \u0060float\u0060 is nothing. Provide a test case for both cases to show\nthat the function works.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: maFunction, define-output: maFunction ***)\nlet ma x = \n    match x with\n    | None -\u003E 0.0\n    | Some y -\u003E y\n\nlet ma2Some7 = ma (Some 7.0) // returns 7.0\nlet ma2None = ma None // returns 0.0\n(*** condition:html, include:maFunction ***)\n(*** condition:html, include-fsi-output:maFunction ***)\n\n(**\nor, see the \u0060x\u0060 in the (\u0060Some x\u0060) part of the match expression\nis the \u0060float\u0060, not the original (\u0060x: float Option\u0060)\nTo see this, hover your cursor over the first two xs. it says \u0060x is float Option\u0060.\nThen hover over the second two xs. It says \u0060x is float\u0060. Two different xs!\n*)\n\n(*** define: maFunction1, define-output: maFunction1 ***)\nlet ma2 x = \n    match x with\n    | None -\u003E 0.0\n    | Some x -\u003E x\n\nlet ma2Some7Other = ma2 (Some 7.0) // returns 7.0\nlet ma2NoneOther = ma2 None // returns 0.0\n(*** condition:html, include:maFunction1 ***)\n(*** condition:html, include-fsi-output:maFunction1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nWrite a function named \u0060mb\u0060 that takes \u0060x: float\u0060 as an input.\nUse a match expression to output \u00601.0\u0060 if \u0060x\u0060 is \u00601.0\u0060, \u00604.0\u0060 if \u0060x\u0060 is \u00602.0\u0060,\nand \u0060x^3.0\u0060 if \u0060x\u0060 is anything else. Provide 3 tests for the 3 test cases \nto show that the function works.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mbFunction, define-output: mbFunction ***)\n\nlet mb x = \n    match x with \n    | 1.0 -\u003E 1.0\n    | 2.0 -\u003E 4.0\n    | x -\u003E x**3.0\n\nlet mb1 = mb 1.0 // evaluates to 1.0\nlet mb2 = mb 2.0 // evaluates to 4.0\nlet mb7 = mb 7.0 // evaluates to 343.00\n\n(*** condition:html, include:mbFunction ***)\n(*** condition:html, include-fsi-output:mbFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nWrite a function named \u0060mc\u0060 that takes a tuple pair of ints  \u0060x: int * int\u0060\nas an input. Handle these cases in the following order:\n\n1. if the first \u0060int\u0060 is \u00607\u0060, return \u0060\u0022a\u0022\u0060.\n2. if the second int is \u00607\u0060, return \u0060\u0022b\u0022\u0060.\n3. For everything else, return \u0060\u0022c\u0022\u0060.\n\nFinally, test the function on \u0060(7,6)\u0060, \u0060(6,7)\u0060, \u0060(7, 7)\u0060, and \u0060(6,6)\u0060.\nMake sure that you understand how those 4 examples are handled.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mcFunction, define-output: mcFunction ***)\n\nlet mc x =\n    match x with\n    | (7, _) -\u003E \u0022a\u0022 // the _ in (7, _) indicates wildcard; it matches anything.\n    | (_, 7) -\u003E \u0022b\u0022 \n    | _ -\u003E \u0022c\u0022 // wild card at the end catches anything remaining.\n\nlet mc76 = mc (7,6) // evaluates to \u0022a\u0022 because it matches the first case and stops checking.\nlet mc67 = mc (6,7) // evaluates to \u0022b\u0022 because it matches the second case and stops checking.\nlet mc77 = mc (7,7) // evaluates to \u0022a\u0022 because it matches the first case and stops checking.\nlet mc66 = mc (6,6) // evaluates to \u0022c\u0022 because it matches the last wildcard.\n\n(*** condition:html, include:mcFunction ***)\n(*** condition:html, include-fsi-output:mcFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nConsider this array of trading days for a stock and it\u0027s price and dividends:\n*)\n\ntype StockDays2 = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays2 = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]   \n\n(**\n\n1. create a new array called \u0060daysWithDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days with dividends. For\n  each day with a dividend, you should return a \u0060(int * decimal)\u0060 tuple\n  where the int is the day  and the decimal is the dividend. \n  Thus the result is an \u0060(int * decimal) array\u0060.\n2. Then create an array called \u0060daysWithoutDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days that do not have dividends.\n  For each day without a dividend, you should return the day as an \u0060int\u0060.\n  Thus the result is an \u0060int array\u0060.\n\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nDays With Dividends: \n*)\n\n(*** define: daysWithAndWithoutDividends, define-output: daysWithAndWithoutDividends ***)           \nlet daysWithDividends1 =\n    // using filter and then a map\n    stockDays2\n    |\u003E Array.filter (fun day -\u003E day.Dividend.IsSome)\n    |\u003E Array.map(fun day -\u003E\n        match day.Dividend with\n        | None -\u003E failwith \u0022shouldn\u0027t happen because I filtered on IsSome\u0022\n        | Some div -\u003E day.Day, div)\n(*** condition:html, include:daysWithAndWithoutDividends ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends ***)\n\n(**\nor\n*)\n\n(*** define: daysWithAndWithoutDividends1, define-output: daysWithAndWithoutDividends1 ***)           \nlet daysWithDividends2 =\n    // using choose, this is better. Think of choose\n    // as a filter on IsSome and a map combined. Choose applies\n    // a function that returns an option. If the\n    // option result is Some x then choose returns x.\n    // If the result is None then choose filters it out.\n    // Notice that we don\u0027t have to worry about \n    // the \u0022this shouldn\u0027t happen\u0022 exception\n    // because it literally cannot happen in this version.\n    // This is an example of making illegal states unrepresentable.\n    stockDays2\n    |\u003E Array.choose (fun day -\u003E \n        // our function takes a day as an input and outputs\n        // a \u0060(int * decimal) option\u0060. That is,\n        // an optional tuple.\n        match day.Dividend with \n        | None -\u003E None\n        | Some div -\u003E Some (day.Day, div))\n(*** condition:html, include:daysWithAndWithoutDividends1 ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends1 ***)\n\n(**\nDays Without Dividends: \n*)\n\n(*** define: daysWithAndWithoutDividends2, define-output: daysWithAndWithoutDividends2 ***)           \nlet daysWithoutDividends =\n    stockDays2\n    |\u003E Array.choose(fun day -\u003E \n        match day.Dividend with\n        | None -\u003E Some day.Day\n        | Some div -\u003E None)\n(*** condition:html, include:daysWithAndWithoutDividends2 ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Map Collections\n*)\n\n(**\n## Question 1\nCreate a Map collection named \u0060mapA\u0060 \nfrom the list \u0060[(\u0022a\u0022,1);(\u0022b\u0022,2)]\u0060 where the first thing \nin the tuple is the key and the second thing is the value.\n\n1. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022a\u0022\u0060\n2. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022c\u0022\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nCreate Map Collection:\n*)\n\n(*** define: mapA, define-output: mapA ***)\nlet mapA = Map [(\u0022a\u0022,1);(\u0022b\u0022,2)]\n(*** condition:html, include:mapA ***)\n(*** condition:html, include-fsi-output:mapA ***)\n\n(**\nor\n*)\n\n(*** define: mapA2, define-output: mapA2 ***)\nlet mapA2 = [(\u0022a\u0022,1);(\u0022b\u0022,2)] |\u003E Map\n(*** condition:html, include:mapA2 ***)\n(*** condition:html, include-fsi-output:mapA2 ***)\n\n(**\nor\n*)\n\n(*** define: mapA3, define-output: mapA3 ***)\nlet mapA3 = [(\u0022a\u0022,1);(\u0022b\u0022,2)] |\u003E Map.ofList\n(*** condition:html, include:mapA3 ***)\n(*** condition:html, include-fsi-output:mapA3 ***)\n\n(**\nUse \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022a\u0022\u0060:\n*)\n\n(*** define: tryFindA, define-output: tryFindA ***)\nMap.tryFind \u0022a\u0022 mapA    // evaluates to Some 1\n(*** condition:html, include:tryFindA ***)\n(*** condition:html, include-fsi-output:tryFindA ***)\n\n(**\nor\n*)\n\n(*** define: tryFindA1, define-output: tryFindA1 ***)\nmapA |\u003E Map.tryFind \u0022a\u0022 // evaluates to Some 1\n(*** condition:html, include:tryFindA1 ***)\n(*** condition:html, include-fsi-output:tryFindA1 ***)\n\n(**\nUse \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022c\u0022\u0060:\n*)\n\n(*** define: tryFindC, define-output: tryFindC ***)\nMap.tryFind \u0022c\u0022 mapA    // evaluates to None\n(*** condition:html, include:tryFindC ***)\n(*** condition:html, include-fsi-output:tryFindC ***)\n\n(**\nor\n*)\n\n(*** define: tryFindC1, define-output: tryFindC1 ***)\nmapA |\u003E Map.tryFind \u0022c\u0022 // evaluates to None\n(*** condition:html, include:tryFindC1 ***)\n(*** condition:html, include-fsi-output:tryFindC1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a Map collection named \u0060mapB\u0060\nfrom the list \u0060[(1,\u0022a\u0022);(2,\u0022b\u0022)]\u0060 where the first thing\nin the tuple is the key and the second thing is the value.\n\n1. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u00601\u0060\n2. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u00603\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapB, define-output: mapB ***)\n\nlet mapB = Map [(1,\u0022a\u0022);(2,\u0022b\u0022)]\nlet tryFindMapB1 = Map.tryFind 1 mapB\nlet tryFindMapB3 =Map.tryFind 3 mapB\n\n(*** condition:html, include:mapB ***)\n(*** condition:html, include-fsi-output:mapB ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nUse this array\n*)\n\ntype StockDays3 = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays3 = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]     \n\n(**\n1. Create a Map collection named \u0060mapC\u0060. The key should be the day field, \n  and the value should be the full \u0060StockDays3\u0060 record.\n2. Create a Map collection named \u0060mapD\u0060. The key should be the full\n  \u0060StockDay3\u0060 record. The value should be the day field.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: mapC, define-output: mapC ***)    \nlet mapC =\n    stockDays3\n    |\u003E Array.map(fun day -\u003E\n        // we just want to create a tuple of the (key,value).\n        // The key and value can be anything.\n        day.Day, day)\n    |\u003E Map.ofArray\n(*** condition:html, include:mapC ***)\n(*** condition:html, include-fsi-output:mapC ***)\n\n(*** define: mapD, define-output: mapD ***)    \nlet mapD =\n    stockDays3\n    |\u003E Array.map(fun day -\u003E\n        // we just want to create a tuple of the (key,value).\n        // The key and value can be anything.\n        day, day.Day)\n    |\u003E Map.ofArray\n\n(*** condition:html, include:mapD ***)\n(*** condition:html, include-fsi-output:mapD ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nConsider a the following Map collection:\n*)\nlet mapp = [(\u0022a\u0022, 1); (\u0022d\u0022,7)] |\u003E Map.ofList\n\n(**\nWrite a function named \u0060lookFor\u0060 that takes \u0060x: string\u0060 as an input and\nlooks up the value in \u0060mapp\u0060. If it finds \u0060Some y\u0060, print\n\u0060\u0022I found y\u0022\u0060 to standard output where \u0060y\u0060 is the actual integer found. \nIf it finds \u0060None\u0060, print \u0060\u0022I did not find x\u0022\u0060 to standard output\nwhere \u0060x\u0060 is the actual key that was looked up. Test it by looking\nup \u0060\u0022a\u0022\u0060,\u0060\u0022b\u0022\u0060,\u0022\u0060c\u0022\u0060,\u0060\u0022d\u0022\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: lookFor, define-output: lookFor ***)    \nlet lookFor x =\n    match Map.tryFind x mapp with\n    | Some y -\u003E printfn $\u0022I found {y}\u0022\n    | None -\u003E printfn $\u0022I did not find {x}\u0022 \n\nlookFor \u0022a\u0022 // I found 1\nlookFor \u0022b\u0022 // I did not find b\nlookFor \u0022c\u0022 // I did not find c\nlookFor \u0022d\u0022 // I found 7\n(*** condition:html, include:lookFor ***)\n(*** condition:html, include-fsi-merged-output:lookFor ***)\n\n(**\nor iterate it\nwe use iter instead of map\nbecause the result of iter has type \u0060unit\u0060,\nand iter is for when your function has type \u0060unit\u0060.\nBasically, unit type means the function did something\n(in this case, printed to standard output) but\nit doesn\u0027t actually return any output.  \nYou could use map, but then we get \u0060unit list\u0060 which\nisn\u0027t really what we want. We just want to iterate\nthrough the list and print to output.\n*)\n\n(*** define: lookFor1, define-output: lookFor1 ***)    \n[\u0022a\u0022; \u0022b\u0022; \u0022c\u0022; \u0022d\u0022] |\u003E List.iter lookFor\n(*** condition:html, include:lookFor1 ***)\n(*** condition:html, include-fsi-merged-output:lookFor1 ***)\n\n(**\nor loop it\n*)\n\n(*** define: lookFor2, define-output: lookFor2 ***)    \nfor letter in [\u0022a\u0022; \u0022b\u0022; \u0022c\u0022; \u0022d\u0022] do\n    printfn $\u0022{lookFor letter}\u0022    \n(*** condition:html, include:lookFor2 ***)\n(*** condition:html, include-fsi-merged-output:lookFor2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Joins\n\nFor the following questions use this data:\n*)\ntype StockPriceOb =\n    { Stock : string \n      Time : int\n      Price : int }\ntype TwoStocksPriceOb =\n    { Time : int \n      PriceA : int option \n      PriceB : int option }\nlet stockA = \n    [{ Stock = \u0022A\u0022; Time = 1; Price = 5}\n     { Stock = \u0022A\u0022; Time = 2; Price = 6}]\nlet stockB =     \n    [{ Stock = \u0022B\u0022; Time = 2; Price = 5}\n     { Stock = \u0022B\u0022; Time = 3; Price = 4}]\n\n(**\nHint: remember that Map collections are useful for lookups.\n*)\n\n\n(**\n## Question 1\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslA\u0060 that has prices for\nevery observation of \u0060stockA\u0060. If there is a price for \u0060stockB\u0060\nat the same time as \u0060stockA\u0060, then include the \u0060stockB\u0060 price. Otherwise,\nthe \u0060stockB\u0060 price should be \u0060None\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: TwoStockPriceOb, define-output: TwoStockPriceOb ***)    \n\nlet stockbByTime = \n    stockB \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\nlet tslA1 =\n    stockA\n    |\u003E List.map(fun dayA -\u003E\n        let dayB = Map.tryFind dayA.Time stockbByTime\n        match dayB with\n        | None -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price\n              PriceB = None}\n        | Some db -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price \n              PriceB = Some db.Price })\n// or, just a personal preference if you like the loop or List.map\nlet tslA2 =\n    [ for dayA in stockA do \n        let dayB = Map.tryFind dayA.Time stockbByTime\n        match dayB with\n        | None -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price\n              PriceB = None}\n        | Some db -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price \n              PriceB = Some db.Price }]\n// or, define a function\nlet tryFindBforA (dayA: StockPriceOb) =\n    let dayB = Map.tryFind dayA.Time stockbByTime\n    match dayB with\n    | None -\u003E \n        { Time = dayA.Time\n          PriceA = Some dayA.Price\n          PriceB = None}\n    | Some db -\u003E \n        { Time = dayA.Time\n          PriceA = Some dayA.Price \n          PriceB = Some db.Price }   \n// checkit\ntryFindBforA stockA.[0]\n// do it\nlet tslA3 = stockA |\u003E List.map tryFindBforA                         \n\n(*** condition:html, include:TwoStockPriceOb ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslB\u0060 that has prices for\nevery observation of stockB. If there is a price for \u0060stockA\u0060\nat the same time as \u0060stockB\u0060, then include the \u0060stockA\u0060 price. Otherwise,\nthe \u0060stockA\u0060 price should be \u0060None\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: tslB, define-output: tslB ***)    \n\nlet stockaByTime = \n    stockA \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\nlet tslB =\n    stockB\n    |\u003E List.map(fun dayB -\u003E\n        let dayA = Map.tryFind dayB.Time stockaByTime\n        match dayA with\n        | None -\u003E \n            { Time = dayB.Time\n              PriceA = None\n              PriceB = Some dayB.Price }\n        | Some da -\u003E \n            { Time = dayB.Time\n              PriceA = Some da.Price \n              PriceB = Some dayB.Price })                        \n\n(*** condition:html, include:tslB ***)\n(*** condition:html, include-fsi-output:tslB ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslC\u0060 that only includes times\nwhen there is a price for both \u0060stockA\u0060 and \u0060stockB\u0060. The prices for stocks\nA and B should always be something.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: tslC, define-output: tslC ***)    \n\nlet stockaByTime2 = \n    stockA \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\nlet tslC1 =\n    stockB\n    |\u003E List.choose(fun dayB -\u003E\n        let dayA = Map.tryFind dayB.Time stockaByTime2\n        match dayA with\n        | None -\u003E None\n        | Some da -\u003E \n            let output =\n                { Time = dayB.Time\n                  PriceA = Some da.Price \n                  PriceB = Some dayB.Price }\n            Some output)\n// or, using set which I know you do not know. But #yolo\nlet timesA = stockA |\u003E List.map(fun x -\u003E x.Time) |\u003E set\nlet timesB = stockB |\u003E List.map(fun x -\u003E x.Time) |\u003E set\nlet timesAandB = Set.intersect timesA timesB\nlet tslC2 =\n    timesAandB\n    |\u003E Set.toList\n    |\u003E List.map(fun time -\u003E \n        { Time = time \n          PriceA = Some stockaByTime.[time].Price\n          PriceB = Some stockbByTime.[time].Price})                      \n\n(*** condition:html, include:tslC ***)\n(*** condition:html, include-fsi-output:tslC ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslD\u0060 that includes available\nstock prices for \u0060stockA\u0060 and \u0060stockB\u0060 at all possible times. If a price for\none of the stocks is missing for a given time, it should be None.\n\n\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: tslD, define-output: tslD ***)    \n\nlet stockATimes = stockA |\u003E List.map(fun x -\u003E x.Time)\nlet stockBTimes = stockB |\u003E List.map(fun x -\u003E x.Time)\nlet allTimes = \n    List.append stockATimes stockBTimes\n    |\u003E List.distinct\nlet tslD =\n    allTimes\n    |\u003E List.map(fun time -\u003E\n        let a = \n            match Map.tryFind time stockaByTime with\n            | None -\u003E None\n            | Some a -\u003E Some a.Price\n            \n        let b = \n            // same thing as what\u0027s done above with match expression,\n            // but with Option.map. Personal preference depending\n            // on what seems clearest. If you\u0027re mapping an option\n            // and returning None for the None case,\n            // a Option.map can be nice.\n            Map.tryFind time stockbByTime\n            |\u003E Option.map(fun b -\u003E b.Price)\n        { Time = time; PriceA = a; PriceB = b })       \n// or, using a function. This is the same thing as in the above\n// anonymous lambda function, but I\u0027m going to use different \n// code to achieve the same goal just to show you different options.\n// again, it\u0027s just personal preference.\n// check how to write the function using time = 1 as a test\nlet testTime = 1\nlet time1A = Map.tryFind testTime stockaByTime\nlet time1B = Map.tryFind testTime stockbByTime\nlet time1Aprice = time1A |\u003E Option.map(fun x -\u003E x.Price )\nlet time1Bprice = time1B |\u003E Option.map(fun x -\u003E x.Price)\nlet testOutput = { Time = testTime; PriceA = time1Aprice; PriceB = time1Bprice }\n// now turn above code into a function to do the same thing\nlet getTheMatch time =\n    let a = Map.tryFind time stockaByTime\n    let b = Map.tryFind time stockbByTime\n    let aPrice = a |\u003E Option.map(fun x -\u003E x.Price)\n    let bPrice = b |\u003E Option.map(fun x -\u003E x.Price)\n    { Time = time; PriceA = aPrice; PriceB = bPrice }\n// test it to see that it works\ngetTheMatch 1\ngetTheMatch 2\n// now do it for the whole list\nlet tslD2 = allTimes |\u003E List.map getTheMatch                  \n\n(*** condition:html, include:tslD ***)\n(*** condition:html, include-fsi-output:tslD ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n"},{"uri":"/Teaching/quizzes/portfolios-PracticeQuiz.html","title":"Portfolios","content":"(**\n---\ntitle: Portfolios\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 6\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n# Some good things to reference\n\n[Anonymous Records](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/anonymous-records#syntax). You can read the above link for details, but the point of these is quite simple.\n\nRecords have been our main type for holding data for an observation. We\u0027ve typically defined these ahead of time with a name before using them. This is good for important types that you will use frequently.\n\nIf you\u0027re using a particular record in only a few lines of code, then it can feel cumbersome to define the type beforehand. Anonymous records are a good solution in these circumstances. They are records that you can essentially use like regular records that we\u0027ve been using, but you don\u0027t have to define the name of the record ahead of time.\n\nI rarely use anonymous records, but you might find them useful for exploratory data manipulation. They\u0027re also kind of nice for these short problems because I don\u0027t need to define a record for each problem.\n*)\n\n(**\n# Anonymous records\n*)\n\n(**\n## Question 1\n\n1. Create a *record* named \u0060ExampleRec\u0060 that has an \u0060X\u0060 field of type int and a \u0060Y\u0060 field of type int. Create an example \u0060ExampleRec\u0060 and assign it to a value named \u0060r\u0060.\n2. Create an *anonymous record* that has an \u0060X\u0060 field of type int and a \u0060Y\u0060 field of type int. Create an example of the anonymous record and assign it to a value named \u0060ar\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ExampleRec, define-output: ExampleRec ***)\n\n// a regular named record\ntype ExampleRec = { X : int; Y : int }\nlet r = { X = 1; Y = 2}\n// an anonymous record. The difference is\n// 1. We did not define the type ahead of time.\n// 2. We put the pipe symbole \u0022|\u0022 inside the curly braces.\nlet ar = {| X = 1; Y = 2|}\n// Note that they are not the same type, so if you\n// compare them they will be different even though\n// the X and Y fields have the same values.\n// For example, running \u0060r = ar\u0060 \n// will give a compiler error\n\n(*** condition:html, include:ExampleRec ***)\n(*** condition:html, include-fsi-output:ExampleRec ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine you have this array\n*)\n\nopen System\ntype ArExample = { Date : DateTime; Value: float}\nlet arr = [|{ Date = DateTime(1990,1,1); Value = 1.25}\n            { Date = DateTime(1990,1,2); Value = 2.25}\n            { Date = DateTime(1991,1,1); Value = 3.25} |]\n\n(**\n1. Group the observations by a tuple of \u0060(year,month)\u0060 and find the \nminimum value for each group. Report the result as a tuple of the group\nand the minimum value [so it will be \u0060((year, month), minValue)\u0060].\n2. Now, the same thing with anonymous records.\nGroup the observations by an Anonymous Record \u0060{| Year = year; Month= month|}\u0060 and find the \nminimum value for each group. Report the result as an Anonymous record with a Group\nfield for the group and a value field for the minimum value [so it will be\n\u0060{| Group = {| Year = year; Month= month|}; Value = minValue |}\u0060].\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: RecordsAndTransformations, define-output: RecordsAndTransformations ***)\n\n// here I will explicitly put year and month in the final result\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun (group, xs) -\u003E\n    let year, month = group // Explicitly access year, month; same as let a,b = (1,2)\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    (year, month), minValue) // explicitly put it in the result\n\n// here I will explicitly put year and month in the final result,\n// but I will deconstruct them using pattern matching in the\n// function input\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((year, month), xs) -\u003E // Explicitly pattern match year, month in function input\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    (year, month), minValue) // explicitly put it in the result\n\n// or\n// since I\u0027m just returning the grouping variable, there\u0027s really\n// no need to deconstruct it into year, month at any point.\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun (group, xs) -\u003E // match group to (year,month) together\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    group, minValue)\n\n// Now using anonymous records\n// This is where anonymous records can be useful.\n// For example, sometimes grouping by many things, \n// using anonymous records like this make it more clear what the different\n// grouping variables are because they have names.\n// It\u0027s like a middle ground between tuples with no clear naming structure\n// and regular named records that are very explicit.\narr \n|\u003E Array.groupBy(fun x -\u003E {| Year = x.Date.Year; Month = x.Date.Month |})\n|\u003E Array.map(fun (group, xs) -\u003E \n    let year, month = group.Year, group.Month // explicit deconstruct \n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    {| Group = {| Year = year; Month = month|}; Value = minValue |})\n\n// or, do the same thing by returning the whole group without deconstructing\narr \n|\u003E Array.groupBy(fun x -\u003E {| Year = x.Date.Year; Month = x.Date.Month |})\n|\u003E Array.map(fun (group, xs) -\u003E \n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    {| Group = group; Value = minValue |})\n\n(*** condition:html, include:RecordsAndTransformations ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Portfolio Returns\n*)\n\n(**\n## Question 1\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\ntype PortReturnPos = { Id: string;  Weight: float; Return: float}\nlet stockPos = { Id = \u0022stock\u0022; Weight = 0.25; Return = 0.1 }\nlet bondPos = { Id = \u0022bond\u0022; Weight = 0.75; Return = 0.05}\n\n(**\n1. Group the observations by a tuple of \u0060(year,month)\u0060 and find the \nminimum value for each group. Report the result as a tuple of the group\nand the minimum value [so it will be \u0060((year, month), minValue)\u0060].\n2. Now, the same thing with anonymous records.\nGroup the observations by an Anonymous Record \u0060{| Year = year; Month= month|}\u0060 and find the \nminimum value for each group. Report the result as an Anonymous record with a Group\nfield for the group and a value field for the minimum value [so it will be\n\u0060{| Group = {| Year = year; Month= month|}; Value = minValue |}\u0060].\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: PortfolioRet1, define-output: PortfolioRet1 ***)\n\n// Remember that portfolio returns are a weighted average\n// of the returns of the stocks in the portfolio. The weights\n// are the position weights.\n\nlet stockAndBondPort = \n    stockPos.Weight*stockPos.Return \u002B bondPos.Weight*bondPos.Return\n// or, doing the multiplication and summation with collections\nlet weightXreturn =\n    [|stockPos;bondPos|]\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n// look at it\nweightXreturn\n// now sum\nlet stockAndBondPort2 = weightXreturn |\u003E Array.sum\n// check\nstockAndBondPort = stockAndBondPort2 // evaluates to true\n\n(*** condition:html, include:PortfolioRet1 ***)\n(*** condition:html, include-fsi-output:PortfolioRet1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\nlet positions =\n    [|{ Id = \u0022stock\u0022; Weight = 0.25; Return = 0.12 }\n      { Id = \u0022bond\u0022; Weight = 0.25; Return = 0.22 }\n      { Id = \u0022real-estate\u0022; Weight = 0.5; Return = -0.15 } |]\n\n(*** include-it-raw:preDetails ***)\n(*** define: EntirePortRet, define-output: EntirePortRet ***)\n\nlet threeAssetPortfolioReturn =\n    positions\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n    |\u003E Array.sum\n\n(*** condition:html, include:EntirePortRet ***)\n(*** condition:html, include-fsi-output:EntirePortRet ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\nlet positionsWithShort =\n    [|{ Id = \u0022stock\u0022; Weight = 0.25; Return = 0.12 }\n      { Id = \u0022bond\u0022; Weight = -0.25; Return = 0.22 }\n      { Id = \u0022real-estate\u0022; Weight = 1.0; Return = -0.15 } |]\n\n(*** include-it-raw:preDetails ***)\n(*** define: EntirePortRetWithShort, define-output: EntirePortRetWithShort ***)\n\nlet positionsWithShortReturn =\n    positionsWithShort\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n    |\u003E Array.sum\n\n\n(*** condition:html, include:EntirePortRetWithShort ***)\n(*** condition:html, include-fsi-output:EntirePortRetWithShort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Sharpe Ratios\n*)\n\n(**\n## Question 1\nImagine that you have the following array of *annual* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n*)\n\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n//Note that the units are such that 0.1 is 10%.\n\n(*** include-it-raw:preDetails ***)\n(*** define: AnnualizedSR, define-output: AnnualizedSR ***)\n\n#r \u0022nuget: FSharp.Stats\u0022\nopen FSharp.Stats\n\nlet retsAvg = rets |\u003E Array.average\n// we get stDev from FSharp.Stats\n// there is only a Seq.stDev, not Array.stDev.\n// We can use Seq.stDev with array because you\n// can pipe any collection to a Seq.\nlet retsStdDev = rets |\u003E Seq.stDev \nlet retsSharpeRatio = retsAvg/retsStdDev\n\n(*** condition:html, include:AnnualizedSR ***)\n(*** condition:html, include-fsi-output:AnnualizedSR ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine that you have the following array of *monthly* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n\n\u0060\u0060\u0060fsharp\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n//Note that the units are such that 0.1 is 10%.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: MonthlyRetAnnualSR, define-output: MonthlyRetAnnualSR ***)\n\n// remember that to annualize an arithmetic return,\n// we do return * (# compounding periods per year)\n// to annualize a standard deviation, \n// we do sd * sqrt(# compounding periods per year)\n\nlet monthlyRetsAnnualizedAvg = 12.0*(rets |\u003E Array.average)\n// or\nlet monthlyRetsAnnualizedAvg2 = \n    rets \n    |\u003E Array.average \n    // now we\u0027re going to use a lambda expression.\n    // this is the same idea as when we do Array.map(fun x -\u003E ...)\n    // except now we\u0027re only piping a float, not an array so\n    // we\u0027re leaving off the \u0022Array.map\u0022 \n    |\u003E (fun avg -\u003E 12.0 * avg) \n// or, in two steps\nlet monthlyRetsAvg = rets |\u003E Array.average\nlet monthlyRetsAnnualizedAvg3 = 12.0*monthlyRetsAvg\n\n// now the standard deviation\nlet monthlyRetsAnnualizedSd = \n    rets \n    |\u003E Seq.stDev\n    |\u003E fun monthlySd -\u003E sqrt(12.0) * monthlySd\n//or, in two steps\nlet monthlyRetsSd = rets |\u003E Seq.stDev\nlet monthlyRetsAnnualizedSd2 = sqrt(12.0)*monthlyRetsSd\n\n// SharpeRatio\nlet annualizedSharpeFromMonthly =\n    monthlyRetsAnnualizedAvg / monthlyRetsAnnualizedSd\n\n// or, since 12.0/sqrt(12.0) = sqrt(12.0) then\n// (monthlyRetsAvg *12.0)/(monthlyRetsSd*sqrt(12.0)) = \n//      sqrt(12.0)*(monthlyRetsAvg/monthlyRetsSd)\nlet annualizedSharpeFromMonthly2 =\n    sqrt(12.0) * (monthlyRetsAvg/monthlyRetsSd)\n\n// check\n// we have to round because floating point math gives us slightly different #\u0027s\n// recall from the fundamentals lecture how floating point math is inexact.\nMath.Round(annualizedSharpeFromMonthly,6) = Math.Round(annualizedSharpeFromMonthly2,6) // true\n\n(*** condition:html, include:MonthlyRetAnnualSR ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nImagine that you have the following array of *daily* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n\n\u0060\u0060\u0060fsharp\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n//Note that the units are such that 0.1 is 10%.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: dailyRetAnnualSR, define-output: dailyRetAnnualSR ***)\n\n// Convention for daily is 252 trading days per year.\n// so annualize daily by multiplying by sqrt(252.0)\nlet annualizedSharpeFromDaily =\n    let avgRet = rets |\u003E Array.average\n    let stdevRet = rets |\u003E Seq.stDev\n    sqrt(252.0) * (avgRet/stdevRet)\n// or in multiple steps\nlet dailyAvgRet = rets |\u003E Array.average\nlet dailyStDevRet = rets |\u003E Seq.stDev\nlet annualizedSharpeFromDaily2 =\n    sqrt(252.0) * (dailyAvgRet/dailyStDevRet)\n\n(*** condition:html, include:dailyRetAnnualSR ***)\n(*** condition:html, include-fsi-output:dailyRetAnnualSR ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n"},{"uri":"/Teaching/quizzes/volatilityTiming-PracticeQuiz-2.html","title":"Volatility Timing Part 2","content":"(**\n---\ntitle: Volatility Timing Part 2\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 3\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nWe\u0027re going to use the following in the questions\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\n\nopen System\nopen FSharp.Stats\n\ntype ReturnOb = { Symbol : string; Date : DateTime; Return : float }\ntype ValueOb = { Symbol : string; Date : DateTime; Value : float }\n\nlet seed = 1\nRandom.SetSampleGenerator(Random.RandBasic(seed))   \nlet normal = Distributions.Continuous.normal 0.0 0.1\n\nlet returns =\n    [| \n        for symbol in [\u0022AAPL\u0022; \u0022TSLA\u0022] do\n        for month in [1..2] do\n        for day in [1..3] do\n            { Symbol = symbol \n              Date = DateTime(2021, month, day)\n              Return = normal.Sample()}\n    |]\n\n\n(**\n## Question 1\nTake this array of arrays, add \u00601.0\u0060 to each element of the \u0022inner\u0022 arrays,\nand then concatenate all the inner arrays together.\n*)\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: arraysAdd1, define-output: arraysAdd1 ***)\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n|\u003E Array.collect(fun xs -\u003E xs |\u003E Array.map(fun x -\u003E x \u002B 1.0))\n(*** condition:html, include:arraysAdd1 ***)\n(*** condition:html, include-fsi-output:arraysAdd1 ***)\n\n(**\nor\n*)\n\n(*** define: arraysAdd11, define-output: arraysAdd11 ***)\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n|\u003E Array.map(fun xs -\u003E xs |\u003E Array.map(fun x -\u003E x \u002B 1.0))\n|\u003E Array.concat\n\n(*** condition:html, include:arraysAdd11 ***)\n(*** condition:html, include-fsi-output:arraysAdd11 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nTake the following two-parameter function:\n*)\n\nlet add x y = x \u002B y\n\n(**\nUse the above function and [partial application](https://fsharpforfunandprofit.com/posts/partial-application/)\nto define a new function called \n\u0060add2\u0060 that adds 2 \nto it\u0027s input.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: twoParaFunction, define-output: twoParaFunction ***)\n\nlet add2 = add 2\n\n(*** condition:html, include:twoParaFunction ***)\n(*** condition:html, include-fsi-output:twoParaFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nGiven \u0060returns : ReturnOb []\u0060, use \u0060printfn\u0060 to print the whole\narray to standard output using the [structured plaintext formatter](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/plaintext-formatting). \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: printfnStructuredObject, define-output: printfnStructuredObject ***)\n\nreturns |\u003E (printfn \u0022%A\u0022)\n\n(*** condition:html, include:printfnStructuredObject ***)\n(*** condition:html, include-output:printfnStructuredObject ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven the tuple \u0060(\u0022hi\u0022, false, 20.321, 4)\u0060,\nuse \u0060printfn\u0060 and the tuple to print the following string\nto standard output:\n\u0060\u0022hi teacher, my False knowledge implies that 4%=0020.1\u0022\u0060\n\n[String formatting](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/plaintext-formatting#format-specifiers-for-printf) documentation will be useful. \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: printfnStringInterpolation, define-output: printfnStringInterpolation ***)\nlet (xString, xBool, xFloat, xInt) = (\u0022hi\u0022, false, 20.321, 4)\n(*** condition:html, include:printfnStringInterpolation ***)\n(*** condition:html, include-fsi-output:printfnStringInterpolation ***)\n\n(**\nUsing string interpolation\n*)\n\n(*** define: printfnStringInterpolation1, define-output: printfnStringInterpolation1 ***)\nprintfn $\u0022{xString} teacher, my {xBool} knowledge implies that {xInt}%%=%06.1f{xFloat}\u0022\n(*** condition:html, include:printfnStringInterpolation1 ***)\n(*** condition:html, include-output:printfnStringInterpolation1 ***)\n\n(**\nUsing old-style printfn\n*)\n\n(*** define: printfnStringInterpolation2, define-output: printfnStringInterpolation2 ***)\nprintfn \u0022%s teacher, my %b knowledge implies that %i%%=%06.1f\u0022 xString xBool xInt xFloat\n(*** condition:html, include:printfnStringInterpolation2 ***)\n(*** condition:html, include-output:printfnStringInterpolation2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nGiven \u0060returns : ReturnOb []\u0060, calculate the arithmetic average return \nfor every symbol each month.\nGive the result as a \u0060ReturnOb []\u0060 where the date is the last date for the symbol\neach month.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: arithmeticReturn, define-output: arithmeticReturn ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Return = xs|\u003E Array.averageBy(fun x -\u003E x.Return) })\n\n(*** condition:html, include:arithmeticReturn ***)\n(*** condition:html, include-fsi-output:arithmeticReturn ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nGiven \u0060returns : ReturnOb []\u0060, calculate the monthly return \nfor every symbol each month.\nGive the result as a \u0060ReturnOb []\u0060 where the date is the last date for the symbol\neach month. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: monthlyReturn, define-output: monthlyReturn ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    let monthReturnPlus1 = (1.0, xs) ||\u003E Array.fold(fun acc x -\u003E acc * (1.0 \u002B x.Return))\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Return =  monthReturnPlus1 - 1.0 })\n\n(*** condition:html, include:monthlyReturn ***)\n(*** condition:html, include-fsi-output:monthlyReturn ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven \u0060returns : ReturnOb []\u0060, calculate the standard deviation of daily returns\nfor every symbol each month.\nGive the result as a \u0060ValueOb []\u0060 where the date in each \u0060ValueOb\u0060 is the last date for the symbol\neach month. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: monthlyStdDev, define-output: monthlyStdDev ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    let sd = xs |\u003E stDevBy(fun x -\u003E x.Return)\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Value =  sd })\n\n(*** condition:html, include:monthlyStdDev ***)\n(*** condition:html, include-fsi-output:monthlyStdDev ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 8\nGiven \u0060returns : ReturnOb []\u0060, calculate the standard deviation of daily returns\nfor every symbol using rolling 3 day windows.\nGive the result as a \u0060ValueOb []\u0060 where the date in each \u0060ValueOb\u0060 is the last date for the symbol\nin the window. \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(***define:rollingStdDev, define-output:rollingStdDev ***)\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol)\n|\u003E Array.collect(fun (_symbol, xs) -\u003E\n    xs\n    |\u003E Array.sortBy(fun x -\u003E x.Date)\n    |\u003E Array.windowed 3\n    |\u003E Array.map(fun ys -\u003E \n        let last = ys |\u003E Array.last \n        { Symbol = last.Symbol\n          Date = last.Date\n          Value = ys |\u003E stDevBy(fun x -\u003E x.Return)}))\n(***condition:html,include:rollingStdDev ***)\n(***condition:html,include-fsi-output:rollingStdDev ***)\n\n(**\nBreaking this answer down,\nIf you\u0027re unsure, it\u0027s helpful to work through things step by step.\nthen build up from there.\n*)\n\n(*** define: rollingStdDev1, define-output: rollingStdDev1 ***)\nlet groups = \n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n(***condition:html,include:rollingStdDev1 ***)\n(***condition:html,include-fsi-output:rollingStdDev1 ***)\n\n(*** define: rollingStdDev2, define-output: rollingStdDev2 ***)\nlet firstGroup = groups |\u003E Array.item 0 // or groups |\u003E Array.head\nlet firstSymbol, firstObs = firstGroup // like let a,b = (1,2)\nlet windowedFirstObs = \n    firstObs\n    |\u003E Array.sortBy(fun x -\u003E x.Date)\n    |\u003E Array.windowed 3\nlet firstWindow = windowedFirstObs.[0]\nlet lastDayOfFirstWindow = firstWindow |\u003E Array.last\nlet firstWindowReturnStdDev = firstWindow |\u003E stDevBy(fun x -\u003E x.Return)\nlet firstWindowResult =\n    { Symbol = lastDayOfFirstWindow.Symbol \n      Date = lastDayOfFirstWindow.Date\n      Value = firstWindowReturnStdDev }\n(***condition:html,include:rollingStdDev2 ***)\n(***condition:html,include-fsi-output:rollingStdDev2 ***)\n\n(**\nNow take the inner-most code operating on a single window\nand make a function by copying and pasting inside a function.\noften using more general variable names\n*)\n\n(*** define: rollingStdDev3, define-output: rollingStdDev3 ***)\nlet resultForWindow window =\n    let lastDay = window |\u003E Array.last\n    let stddev = window |\u003E stDevBy(fun x -\u003E x.Return)\n    { Symbol = lastDay.Symbol \n      Date = lastDay.Date\n      Value = stddev }\n(***condition:html,include:rollingStdDev3 ***)\n(***condition:html,include-fsi-output:rollingStdDev3 ***)\n\n(**\ntest it on your window\n*)\n\n(*** define: rollingStdDev4, define-output: rollingStdDev4 ***)\nlet firstWindowFunctionResult = resultForWindow firstWindow\n(***condition:html,include:rollingStdDev4 ***)\n(***condition:html,include-fsi-output:rollingStdDev4 ***)\n\n(**\ncheck\n*)\n\n(*** define: rollingStdDev5, define-output: rollingStdDev5 ***)\nfirstWindowResult = firstWindowFunctionResult // evaluates to true\n(***condition:html,include:rollingStdDev5 ***)\n(***condition:html,include-fsi-output:rollingStdDev5 ***)\n\n(**\nnow a function to create the windows\n*)\n\n(*** define: rollingStdDev6, define-output: rollingStdDev6 ***)\nlet createWindows (days: ReturnOb array) =\n    days\n    |\u003E Array.sortBy(fun day -\u003E day.Date)\n    |\u003E Array.windowed 3\n(***condition:html,include:rollingStdDev6 ***)\n(***condition:html,include-fsi-output:rollingStdDev6 ***)\n\n(**\ncheck\n*)\n\n(*** define: rollingStdDev7, define-output: rollingStdDev7 ***)\n(createWindows firstObs) = windowedFirstObs // evaluates to true\n(***condition:html,include:rollingStdDev7 ***)\n(***condition:html,include-fsi-output:rollingStdDev7 ***)\n\n(**\nso now we can do\n*)\n\n(*** define: rollingStdDev8, define-output: rollingStdDev8 ***)\nfirstObs\n|\u003E createWindows\n|\u003E Array.map resultForWindow\n(***condition:html,include:rollingStdDev8 ***)\n(***condition:html,include-fsi-output:rollingStdDev8 ***)\n\n(**\nCool, now first obs was the obs from the first group.\nwe could do function to operate on a group.\nour group is a tuple of \u0060(string,ReturnObs array)\u0060.\nWe\u0027re not going to use the \u0060string\u0060 variable, so we\u0027ll preface it\nwith _ to let the compiler know we\u0027re leaving it out o purpose.\nthe _ is not necessary but it\u0027s good practice\n*)\n\n(*** define: rollingStdDev9, define-output: rollingStdDev9 ***)\nlet resultsForGroup (_symbol, xs) =\n    xs\n    |\u003E createWindows\n    |\u003E Array.map resultForWindow\n(***condition:html,include:rollingStdDev9 ***)\n(***condition:html,include-fsi-output:rollingStdDev9 ***)\n\n(**\ntest it on the first group\n*)\n\n(*** define: rollingStdDev10, define-output: rollingStdDev10 ***)\nresultsForGroup firstGroup\n(***condition:html,include:rollingStdDev10 ***)\n(***condition:html,include-fsi-output:rollingStdDev10 ***)\n\n(**\nnow make the group and apply my \ngroup function to each group\n*)\n\n(*** define: rollingStdDev11, define-output: rollingStdDev11 ***)\nlet resultsForEachGroup =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n    |\u003E Array.map resultsForGroup\n(***condition:html,include:rollingStdDev11 ***)\n(***condition:html,include-fsi-output:rollingStdDev11 ***)\n\n(**\nOkay, but this is an array of \u0060ValueOb arrays\u0060 (that\u0027s what \u0060ValueOb [ ][ ]\u0060 means).\nWhat happened is that I had an array of groups, and then I transformed each group.\nso it\u0027s still one result per group. For instance\n*)\n\n(*** define: rollingStdDev12, define-output: rollingStdDev12 ***)\nresultsForEachGroup.[0]\n(***condition:html,include:rollingStdDev12 ***)\n(***condition:html,include-fsi-output:rollingStdDev12 ***)\n\n(**\nis the first group of results\n*)\n\n(*** define: rollingStdDev13, define-output: rollingStdDev13 ***)\nresultsForEachGroup.[1]\n(***condition:html,include:rollingStdDev13 ***)\n(***condition:html,include-fsi-output:rollingStdDev13 ***)\n\n(**\nis the second group. I don\u0027t want an array of arrays.\nI just want one array of value obs. So \u0060concat\u0060 them.\n*)\n\n(*** define: rollingStdDev14, define-output: rollingStdDev14 ***)\nlet resultsForEachGroupConcatenated =\n    resultsForEachGroup |\u003E Array.concat\n(***condition:html,include:rollingStdDev14 ***)\n(***condition:html,include-fsi-output:rollingStdDev14 ***)\n\n(**\nwhat\u0027s the first thing in the array?\n*)\n\n(*** define: rollingStdDev15, define-output: rollingStdDev15 ***)\nresultsForEachGroupConcatenated.[0]  \n(***condition:html,include:rollingStdDev15 ***)\n(***condition:html,include-fsi-output:rollingStdDev15 ***)\n\n(**\n\u0060Collect\u0060 does the \u0060map\u0060 and \u0060concat\u0060 in one step.\n*)\n\n(*** define: rollingStdDev16, define-output: rollingStdDev16 ***)\nlet resultsForEachGroupCollected =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n    |\u003E Array.collect resultsForGroup \n(***condition:html,include:rollingStdDev16 ***)\n(***condition:html,include-fsi-output:rollingStdDev16 ***)\n\n(**\ncheck, this should evaluate to \u0060true\u0060\n*)\n\n(*** define: rollingStdDev17, define-output: rollingStdDev17 ***)\nresultsForEachGroupConcatenated.[0] = resultsForEachGroupCollected.[0]\n(***condition:html,include:rollingStdDev17 ***)\n(***condition:html,include-fsi-output:rollingStdDev17 ***)\n\n(**\nwhy did I write the answer using an anonymous function instead of functions like this?\nI use reusable functions for something I\u0027m going to use multiple times.\nIf it\u0027s something I\u0027ll do once, and it\u0027s not too many lines, then I use\nthe anonymous lambda function. As you get more experience, you can code using\nthe type signatures to tell you what everything is. And I don\u0027t actually\nhave to running it step by step.\nhowever, starting out especially, I think you\u0027ll find it helpful\nto kinda break things down like I did here.  \nAnother way you can do it, similar to the first answer using\nan anonymous lambda function, but now we\u0027ll do it with fewer\nnested arrays by concatenating/collecting the windows\ninto the parent array before doing the standard deviations.\n*)\n\n(*** define: rollingStdDev18, define-output: rollingStdDev18 ***)\nlet m2Groups =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n\nlet m2GroupsOfWindows =\n    m2Groups\n    |\u003E Array.map(fun (symbol, xs) -\u003E \n        xs\n        |\u003E Array.sortBy(fun x -\u003E x.Date)\n        |\u003E Array.windowed 3\n    )\n(***condition:html,include:rollingStdDev18 ***)\n(***condition:html,include-fsi-output:rollingStdDev18 ***)\n\n(**\nfirst group of windows\n*)\n\n(*** define: rollingStdDev19, define-output: rollingStdDev19 ***)\nm2GroupsOfWindows.[0]    \n(***condition:html,include:rollingStdDev19 ***)\n(***condition:html,include-fsi-output:rollingStdDev19 ***)\n\n(**\nsecond group of windows\n*)\n\n(*** define: rollingStdDev20, define-output: rollingStdDev20 ***)\nm2GroupsOfWindows.[1]    \n(***condition:html,include:rollingStdDev20 ***)\n(***condition:html,include-fsi-output:rollingStdDev20 ***)\n\n(**\n Now concatenate the windows.\n*)\n\n(*** define: rollingStdDev21, define-output: rollingStdDev21 ***)\nlet m2GroupsOfWindowsConcatenated = m2GroupsOfWindows |\u003E Array.concat  \n(***condition:html,include:rollingStdDev21 ***)\n(***condition:html,include-fsi-output:rollingStdDev21 ***)\n\n(**\nsame as if I\u0027d used collect instead of map and then concat\n*)\n\n(*** define: rollingStdDev22, define-output: rollingStdDev22 ***)\nlet m2GroupsOfWindowsCollected =\n    m2Groups\n    |\u003E Array.collect(fun (symbol, xs) -\u003E \n        xs\n        |\u003E Array.sortBy(fun x -\u003E x.Date)\n        |\u003E Array.windowed 3 \n    )\n(***condition:html,include:rollingStdDev22 ***)\n(***condition:html,include-fsi-output:rollingStdDev22 ***)\n\n(**\ncompare them\n*)\n\n(*** define: rollingStdDev23, define-output: rollingStdDev23 ***)\nlet m2FirstConcatenated = m2GroupsOfWindowsConcatenated.[0]    \nlet m2FirstCollected = m2GroupsOfWindowsCollected.[0]\nm2FirstCollected = m2FirstConcatenated // true. \n\n(***condition:html,include:rollingStdDev23 ***)\n(***condition:html,include-fsi-output:rollingStdDev23 ***) \n\n(**\nIf they\u0027re not true, make sure they\u0027re sorted the same before you take the first obs.\n*)\n\n(**\nNow, standard deviations of the windows\u0027 returns\n*)\n\n(*** define: rollingStdDev24, define-output: rollingStdDev24 ***)\nlet m2Result =\n    m2GroupsOfWindowsCollected\n    |\u003E Array.map(fun window -\u003E \n        let lastDay = window |\u003E Array.last \n        { Symbol = lastDay.Symbol\n          Date = lastDay.Date\n          Value = window |\u003E stDevBy(fun x -\u003E x.Return )})\n\n(***condition:html,include:rollingStdDev24 ***)\n(***condition:html,include-fsi-output:rollingStdDev24 ***) \n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/quizzes/volatilityTiming-PracticeQuiz.html","title":"Volatility Timing Part 1","content":"(**\n---\ntitle: Volatility Timing Part 1\ncategory: Practice Quizzes\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n[![Binder](../img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n\n(**\n## Question 1\nGiven the list below, filter the list so that only numbers greater than \u00602\u0060 remain.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: filter, define-output: filter ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.filter(fun x -\u003E x \u003E 2)\n\n(*** condition:html, include:filter ***)\n(*** condition:html, include-fsi-output:filter ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nGiven the list below, take elements until you find one that is greater than \u00604\u0060.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: takeWhile, define-output: takeWhile ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.takeWhile(fun x -\u003E x \u003C= 4)\n\n(*** condition:html, include:takeWhile ***)\n(*** condition:html, include-fsi-output:takeWhile ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nGiven the list below, take elements until you find one that is greater than \u00604\u0060.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: skipWhile, define-output: skipWhile ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.skipWhile(fun x -\u003E x \u003C= 4)\n\n(*** condition:html, include:skipWhile ***)\n(*** condition:html, include-fsi-output:skipWhile ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven the list below, return tuples of all consecutive pairs.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: pairwise, define-output: pairwise ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.pairwise\n\n(*** condition:html, include:pairwise ***)\n(*** condition:html, include-fsi-output:pairwise ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nGiven the list below, return sliding windows of 3 consecutive observations.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: windowed, define-output: windowed ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.windowed 3\n\n(*** condition:html, include:windowed ***)\n(*** condition:html, include-fsi-output:windowed ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nGiven the list below, use \u0060scan\u0060 to return the intermediate and final cumulative sums.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: scan, define-output: scan ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.scan (fun acc x -\u003E acc \u002B x) \n\n(*** condition:html, include:scan ***)\n(*** condition:html, include-fsi-output:scan ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven the list below, use \u0060fold\u0060 to return the final sum.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: fold, define-output: fold ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.fold (fun acc x -\u003E acc \u002B x) \n\n(*** condition:html, include:fold ***)\n(*** condition:html, include-fsi-output:fold ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 8\nGiven the list below, use \u0060mapFold\u0060 to return the intermediate and final cumulative sums.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold1, define-output: mapFold1 ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.mapFold (fun acc x -\u003E acc \u002B x, acc \u002B x)\n\n(*** condition:html, include:mapFold1 ***)\n(*** condition:html, include-fsi-output:mapFold1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 9\nGiven the list below, use \u0060mapFold\u0060 to return a tuple of\n\n1. A new list in which each element of the original list is transformed by adding \u00601\u0060 to it and then converted into a \u0060string\u0060.\n2. The final cumulative sums of the list elements.\n\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold2, define-output: mapFold2 ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.mapFold (fun acc x -\u003E string (x \u002B 1), acc \u002B x) \n\n(*** condition:html, include:mapFold2 ***)\n(*** condition:html, include-fsi-output:mapFold2 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 10\nGiven the list below, use \u0060mapFold\u0060 to return a tuple of\n\n1. The list of records with the \u0060Y\u0060 field in each record updated to \u0060Y\u002B1\u0060\n2. The sum of the \u0060Y\u0060 fields.\n\n*)\n\ntype R1 = { X : string; Y : int }\n\nlet r1xs =\n    [ { X = \u0022a\u0022; Y = 1 }\n      { X = \u0022b\u0022; Y = -4 }\n      { X = \u0022c\u0022; Y = 7 } \n      { X = \u0022d\u0022; Y = 2 }\n      { X = \u0022e\u0022; Y = -10 }]\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold3, define-output: mapFold3 ***)\n\n(0, r1xs)\n||\u003E List.mapFold (fun acc x -\u003E { x with Y = x.Y\u002B1}, acc \u002B x.Y) \n\n(*** condition:html, include:mapFold3 ***)\n(*** condition:html, include-fsi-output:mapFold3 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 11\nGiven the list below, sum all the elements.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: sum, define-output: sum ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.sum\n\n(*** condition:html, include:sum ***)\n(*** condition:html, include-fsi-output:sum ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 12\nGiven the list below, add \u00601\u0060 to all the elements and then calculate the sum.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: sumBy, define-output: sumBy ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.sumBy(fun x -\u003E x \u002B 1)\n\n(*** condition:html, include:sumBy ***)\n(*** condition:html, include-fsi-output:sumBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 13\nGiven the list below, calculate the \u0060average\u0060 of the elements in the list.\n\u0060\u0060\u0060fsharp\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: average, define-output: average ***)\n\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.average\n\n(*** condition:html, include:average ***)\n(*** condition:html, include-fsi-output:average ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n(**\n## Question 14\nGiven the list below, convert each element to a \u0060decimal\u0060 and then calculate the \u0060average\u0060 of the elements in the list.\n\n\u0060\u0060\u0060fsharp\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: averageBy, define-output: averageBy ***)\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.averageBy(fun x -\u003E decimal x)\n(*** condition:html, include: averageBy ***)\n(*** condition:html, include-fsi-output: averageBy ***)\n\n(**\nSince \u0060decimal\u0060 is a function that converts to\nthe \u0060decimal\u0060 type, you could also do.\nThe FSharp linter shouLd show you a blue squiggly\nin the above code telling you this.\n*)\n\n(*** define: averageBy1, define-output: averageBy1 ***)\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.averageBy decimal\n(*** condition:html, include: averageBy1 ***)\n(*** condition:html, include-fsi-output: averageBy1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n"}]